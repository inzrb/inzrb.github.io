(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7638],{1814:function(e,n,o){(window.__NEXT_P=window.__NEXT_P||[]).push(["/labs/spaceship",function(){return o(9358)}])},9358:function(e,n,o){"use strict";o.r(n),o.d(n,{default:function(){return k}});var r=o(1527),t=o(83),i=o(5542),s=o(6468);o(7990);var a=o(959),l=o(670),u=o(4806);function c(e){let{nodes:n,materials:o}=(0,l.L)("/models/spaceship.glb"),t=(0,a.useRef)(),i=(0,a.useRef)();return(0,r.jsx)("group",{ref:t,...e,dispose:null,children:(0,r.jsxs)("group",{position:[10,10,-80],rotation:[.1*Math.PI,0*Math.PI,.03*Math.PI],scale:4e-4,children:[(0,r.jsx)("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.mesh_0.geometry,material:o.ferrari}),(0,r.jsx)("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.mesh_0_1.geometry,material:o.raggi}),(0,r.jsx)("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.mesh_0_2.geometry,material:o.ammenita}),(0,r.jsx)("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.mesh_0_3.geometry,material:o.motore}),(0,r.jsx)("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.mesh_0_4.geometry,material:o.glow_motore}),(0,r.jsx)("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.mesh_0_5.geometry,material:o["BURCIA GLOW_int"]}),(0,r.jsx)("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.mesh_0_6.geometry,material:o["BURCIA GLOW est"]}),(0,r.jsx)("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.mesh_0_7.geometry,material:o["luce post"]}),(0,r.jsx)("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.mesh_0_8.geometry,material:o.fire,ref:i})]})})}l.L.preload("/models/spaceship.glb");var h=o(4771);let d={uFreq:new h.Uniform(new h.Vector2(2,3)),uAmp:new h.Uniform(new h.Vector2(35,10))},m=(e,n)=>{let o=d.uFreq.value,r=d.uAmp.value,t=new h.Vector3(Math.sin(e*Math.PI*o.x+n)*r.x-Math.sin(.0125*Math.PI*o.x+n)*r.x,Math.sin(e*Math.PI*o.y+n)*r.y-Math.sin(.0125*Math.PI*o.y+n)*r.y,0),i=new h.Vector3(1,1,0),s=new h.Vector3(0,0,-5);return t.multiply(i).add(s)},g={length:400,roadWidth:10,islandWidth:5,lanesPerRoad:2,fov:90,fovSpeedUp:150,speedUp:2,carLightsFade:.4,totalSideLightSticks:50,lightPairsPerRoadWay:70,shoulderLinesWidthPercentage:.05,brokenLinesWidthPercentage:.1,brokenLinesLengthPercentage:.5,lightStickWidth:[.12,.5],lightStickHeight:[1.3,1.7],movingAwaySpeed:[60,80],movingCloserSpeed:[-120,-160],carLightsLength:[20,60],carLightsRadius:[.05,.14],carWidthPercentage:[.3,.5],carShiftX:[-.2,.2],carFloorSeparation:[.05,1],colors:{roadColor:526344,islandColor:657930,background:0,shoulderLines:1250072,brokenLines:1250072,leftCars:[16736115,15158624,16715818],rightCars:[10806246,8442324,5489350],sticks:10806246}};var f=o(33);let v=(0,f.g)({uColor:new h.Color(g.colors.roadColor),uTime:0,uTravelLength:g.length,uFreq:new h.Vector2(4,8),uAmp:new h.Vector2(10,20),uPowY:new h.Vector2(20,2),uLanes:g.lanesPerRoad,uBrokenLinesColor:new h.Color(g.colors.brokenLines),uShoulderLinesColor:new h.Color(g.colors.shoulderLines),uShoulderLinesWidthPercentage:g.shoulderLinesWidthPercentage,uBrokenLinesLengthPercentage:g.brokenLinesLengthPercentage,uBrokenLinesWidthPercentage:g.brokenLinesWidthPercentage},"\nuniform float uTime;\nuniform float uTravelLength;\n\nvarying vec2 vUv; \n\n//   #include <getDistortion_vertex>\nuniform vec4 uFreq;\nuniform vec4 uAmp;\nuniform vec2 uPowY;\nfloat nsin(float val){\n    return sin(val) * 0.5+0.5;\n}\n\n#define PI 3.14159265358979\nfloat getDistortionX(float progress){\n    return \n            (\n                sin(progress * PI * uFreq.x + uTime) * uAmp.x\n            \n            );\n}\nfloat getDistortionY(float progress){\n    return \n            (\n                pow(abs(progress * uPowY.x),uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n            );\n}\nvec3 getDistortion(float progress){\n    return vec3(\n        getDistortionX(progress)-getDistortionX(0.02) ,\n        getDistortionY(progress)- getDistortionY(0.02),\n        0.\n    );\n}\n\nvoid main() {\n    vec3 transformed = position.xyz;\n\n    vec3 distortion  = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n    transformed.x += distortion.x;\n    transformed.z += distortion.y;\n    transformed.y += -1.*distortion.z;  \n    \n    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}\n","\nvarying vec2 vUv; \nuniform vec3 uColor;\nuniform float uTime;\n\n// start #include <roadMarkings_vars>\nuniform float uLanes;\nuniform vec3 uBrokenLinesColor;\nuniform vec3 uShoulderLinesColor;\nuniform float uShoulderLinesWidthPercentage;\nuniform float uBrokenLinesWidthPercentage;\nuniform float uBrokenLinesLengthPercentage;\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n// end #include <roadMarkings_vars>\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 color = vec3(uColor);\n    \n    // #include <roadMarkings_fragment>\n\n    uv.y = mod(uv.y + uTime * 0.1,1.);\n    float brokenLineWidth = 1. / uLanes * uBrokenLinesWidthPercentage;\n    // How much % of the lane's space is empty\n    float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n    // Horizontal * vertical offset\n    float brokenLines = step(1.-brokenLineWidth * uLanes,fract(uv.x * uLanes)) * step(laneEmptySpace, fract(uv.y * 100.)) ;\n    // Remove right-hand lines on the right-most lane\n    brokenLines *= step(uv.x * uLanes,uLanes-1.);\n    color = mix(color, uBrokenLinesColor, brokenLines);\n\n\n    float shoulderLinesWidth = 1. / uLanes * uShoulderLinesWidthPercentage;\n    float shoulderLines = step(1.-shoulderLinesWidth, uv.x) + step(uv.x, shoulderLinesWidth);\n    color = mix(color, uBrokenLinesColor, shoulderLines);\n\n    vec2 noiseFreq = vec2(4., 7000.);\n    float roadNoise = random( floor(uv * noiseFreq)/noiseFreq ) * 0.02 - 0.01; \n    color += roadNoise;\n\n    gl_FragColor = vec4(color,1.);\n}\n");(0,i.e)({RoadWayMaterial:v});let p=(0,f.g)({uColor:new h.Color(g.colors.islandColor),uTime:0,uTravelLength:g.length,uFreq:new h.Vector2(4,8),uAmp:new h.Vector2(10,20),uPowY:new h.Vector2(20,2)},"\nuniform float uTime;\nuniform float uTravelLength;\n\nvarying vec2 vUv; \n\n//   #include <getDistortion_vertex>\nuniform vec4 uFreq;\nuniform vec4 uAmp;\nuniform vec2 uPowY;\nfloat nsin(float val){\n    return sin(val) * 0.5+0.5;\n}\n\n#define PI 3.14159265358979\nfloat getDistortionX(float progress){\n    return \n            (\n                sin(progress * PI * uFreq.x + uTime) * uAmp.x\n            \n            );\n}\nfloat getDistortionY(float progress){\n    return \n            (\n                pow(abs(progress * uPowY.x),uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n            );\n}\nvec3 getDistortion(float progress){\n    return vec3(\n        getDistortionX(progress)-getDistortionX(0.02) ,\n        getDistortionY(progress)- getDistortionY(0.02),\n        0.\n    );\n}\n\nvoid main() {\n    vec3 transformed = position.xyz;\n\n    vec3 distortion  = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n    transformed.x += distortion.x;\n    transformed.z += distortion.y;\n    transformed.y += -1.*distortion.z;  \n    \n    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}\n","\nvarying vec2 vUv; \nuniform vec3 uColor;\nuniform float uTime;\n\n// start #include <roadMarkings_vars>\nuniform float uLanes;\nuniform vec3 uBrokenLinesColor;\nuniform vec3 uShoulderLinesColor;\nuniform float uShoulderLinesWidthPercentage;\nuniform float uBrokenLinesWidthPercentage;\nuniform float uBrokenLinesLengthPercentage;\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n// end #include <roadMarkings_vars>\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 color = vec3(uColor);\n    \n    // #include <roadMarkings_fragment>\n\n    uv.y = mod(uv.y + uTime * 0.1,1.);\n    float brokenLineWidth = 1. / uLanes * uBrokenLinesWidthPercentage;\n    // How much % of the lane's space is empty\n    float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n    // Horizontal * vertical offset\n    float brokenLines = step(1.-brokenLineWidth * uLanes,fract(uv.x * uLanes)) * step(laneEmptySpace, fract(uv.y * 100.)) ;\n    // Remove right-hand lines on the right-most lane\n    brokenLines *= step(uv.x * uLanes,uLanes-1.);\n    color = mix(color, uBrokenLinesColor, brokenLines);\n\n\n    float shoulderLinesWidth = 1. / uLanes * uShoulderLinesWidthPercentage;\n    float shoulderLines = step(1.-shoulderLinesWidth, uv.x) + step(uv.x, shoulderLinesWidth);\n    color = mix(color, uBrokenLinesColor, shoulderLines);\n\n    vec2 noiseFreq = vec2(4., 7000.);\n    float roadNoise = random( floor(uv * noiseFreq)/noiseFreq ) * 0.02 - 0.01; \n    color += roadNoise;\n\n    gl_FragColor = vec4(color,1.);\n}\n");(0,i.e)({IslandMaterial:p});let L=e=>Array.isArray(e)?Math.random()*(e[1]-e[0])+e[0]:Math.random()*e,y=e=>Array.isArray(e)?e[Math.floor(Math.random()*e.length)]:e,x=function(e,n){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.001,t=(n-e)*o;return Math.abs(t)<r&&(t=n-e),t},w=(0,f.g)({uTime:0,uTravelLength:g.length,uFade:new h.Vector2(0,1-g.carLightsFade),uFreq:new h.Vector2(2,3),uAmp:new h.Vector2(35,10)},"\nattribute vec3 aOffset;\nattribute vec3 aMetrics;\nattribute vec3 aColor;\n\n\n\nuniform float uTravelLength;\nuniform float uTime;\nuniform float uSpeed;\n\nvarying vec2 vUv; \nvarying vec3 vColor; \n\n\nuniform vec2 uFreq;\nuniform vec2 uAmp;\n#define PI 3.14159265358979\n\nvec3 getDistortion(float progress){\n\n        float camProgress = 0.0125;\n        return vec3( \n            sin(progress * PI * uFreq.x +uTime) * uAmp.x - sin(camProgress * PI * uFreq.x+uTime ) * uAmp.x,\n            sin(progress * PI * uFreq.y +uTime) * uAmp.y - sin(camProgress * PI * uFreq.y+uTime ) * uAmp.y,\n            0.\n        );\n    }\n\nvoid main() {\n    vec3 transformed = position.xyz;\n    float radius = aMetrics.r;\n    float myLength = aMetrics.g;\n    float speed = aMetrics.b;\n\n    transformed.xy *= radius ;\n    transformed.z *= myLength;\n  \n    // Add my length to make sure it loops after the lights hits the end\n    transformed.z += myLength-mod( uTime *speed + aOffset.z, uTravelLength);\n    transformed.xy += aOffset.xy;\n\n\n    float progress = abs(transformed.z / uTravelLength);\n    transformed.xyz += getDistortion(progress);\n\n    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n    vColor = aColor;\n}\n","\nvarying vec3 vColor;\nvarying vec2 vUv; \nuniform vec2 uFade;\nvoid main() {\n    vec3 color = vec3(vColor);\n    float fadeStart = 0.4;\n    float maxFade = 0.;\n    float alpha = 1.;\n\n    alpha = smoothstep(uFade.x, uFade.y, vUv.x);\n    gl_FragColor = vec4(color,alpha);\n    if (gl_FragColor.a < 0.0001) discard;\n}\n");function P(e){let{options:n,pColor:o,pSpeed:t,isLeftSide:s}=e,l=(0,a.useRef)(),u=o;(0,i.A)((e,n)=>{let o=e.clock.getElapsedTime();l.current.uTime=o});let c=new h.LineCurve3(new h.Vector3(0,0,0),new h.Vector3(0,0,-1)),d=n.roadWidth/n.lanesPerRoad,m=[],g=[],f=[];u=Array.isArray(u)?u.map(e=>new h.Color(e)):new h.Color(u);for(let e=0;e<n.lightPairsPerRoadWay;e++){let o=L(n.carLightsRadius),r=L(n.carLightsLength),i=L(t),s=e%3*d-n.roadWidth/2+d/2,a=L(n.carWidthPercentage)*d;s+=L(n.carShiftX)*d;let l=L(n.carFloorSeparation)+1.3*o,c=-L(n.length);m.push(s-a/2),m.push(l),m.push(c),m.push(s+a/2),m.push(l),m.push(c),g.push(o),g.push(r),g.push(i),g.push(o),g.push(r),g.push(i);let h=y(u);f.push(h.r),f.push(h.g),f.push(h.b),f.push(h.r),f.push(h.g),f.push(h.b)}let v=new Float32Array(m),p=new Float32Array(g),x=new Float32Array(f),w=(0,a.useRef)(),P=s?-n.roadWidth/2-n.islandWidth/2:n.roadWidth/2+n.islandWidth/2;return(0,r.jsx)("group",{ref:w,rotation:[0,0,0],position:[P,0,0],children:(0,r.jsxs)("instancedMesh",{args:[null,null,2*n.lightPairsPerRoadWay],children:[(0,r.jsxs)("tubeGeometry",{args:[c,40,1,8,!1],children:[(0,r.jsx)("instancedBufferAttribute",{attach:"attributes-aOffset",args:[v,3]}),(0,r.jsx)("instancedBufferAttribute",{attach:"attributes-aMetrics",args:[p,3]}),(0,r.jsx)("instancedBufferAttribute",{attach:"attributes-aColor",args:[x,3]})]}),(0,r.jsx)("flyLineMaterial",{ref:l})]})})}function k(){return(0,r.jsx)("section",{className:"lab_show",children:(0,r.jsxs)(t.Xz,{shadows:!0,dpr:[1,1.5],camera:{position:[0,8,-5],fov:45,near:.1,far:1e4},children:[(0,r.jsx)("color",{attach:"background",args:["#000"]}),(0,r.jsx)(C,{}),(0,r.jsx)(S,{}),(0,r.jsx)(c,{}),(0,r.jsx)(P,{color:"#f00",pSpeed:g.movingCloserSpeed,options:g,pColor:g.colors.leftCars,isLeftSide:!0}),(0,r.jsx)(P,{color:"#00f",pSpeed:g.movingCloserSpeed,options:g,pColor:g.colors.rightCars,isLeftSide:!1}),(0,r.jsx)(s.z,{})]})})}function C(){return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("color",{attach:"background",args:["#15151a"]}),(0,r.jsx)("ambientLight",{intensity:.7}),(0,r.jsx)("directionalLight",{intensity:.5,position:[-5,5,5],castShadow:!0,"shadow-mapSize":1024}),(0,r.jsx)("pointLight",{intensity:1,position:[-.15,1,0]}),(0,r.jsx)("pointLight",{intensity:1,position:[2,1,0]})]})}function S(e){let{children:n}=e,{gl:o,camera:t}=(0,i.z)(),s=(0,a.useRef)(),l=0,c=0,h=g.fov,{x:d,y:f,z:v}=(0,u.M4)({x:{value:0,min:-100,max:10,step:.01},y:{value:5,min:-10,max:100,step:.01},z:{value:10,min:-100,max:100,step:.01}});return(0,i.A)((e,n)=>{let o=Math.exp(-(-60*Math.log2(.9))*n),r=x(t.fov,h,o);l+=x(l,0,o,1e-5),c+=l*n;let i=e.clock.getElapsedTime()+c;0!==r&&(t.fov+=r*n*6),t.position.x=d,t.position.y=f,t.position.z=v,m(.025,i)}),(0,r.jsx)("group",{ref:s,children:n})}(0,i.e)({FlyLineMaterial:w})}},function(e){e.O(0,[511,83,3045,670,8517,6468,6254,9774,2888,179],function(){return e(e.s=1814)}),_N_E=e.O()}]);