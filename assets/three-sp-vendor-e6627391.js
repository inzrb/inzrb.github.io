import{_ as t}from"./r3-other-vendor-2c8fc3cb.js";import{B as e,p as n,F as r,H as i,bq as a,j as s,b as o,V as l,br as h,$ as d,ax as c,Y as u,k as p,v as f,t as m,d as g,aL as v,a as y,x as b,ag as x,aP as w,C as _,az as S,T as A,bs as O,bn as M,bt as C,bu as P,bv as D,bw as T,bx as z,by as E,bz as L,bA as I,bd as N,bc as j,bB as B,bC as U,aY as k,aH as R,bD as F,bg as V,u as G,bE as H,bF as W,bG as q,bH as $,ab as X,a7 as Y,w as K,bI as Z,S as Q,ah as J,bJ as tt,b1 as et,bK as nt,bL as rt,bM as it,bN as at,bO as st,I as ot,bP as lt,bQ as ht,aQ as dt,bR as ct,O as ut,P as pt,bS as ft,bT as mt,bU as gt,E as vt,bV as yt,Q as bt,af as xt,bW as wt,ak as _t,bX as St,bY as At,r as Ot,X as Mt,J as Ct,K as Pt}from"./three-vendor-6d04682c.js";import{j as Dt,k as Tt}from"./r3-extend-vendor-ed1023dc.js";function zt(t,n=!1){const r=null!==t[0].index,i=new Set(Object.keys(t[0].attributes)),a=new Set(Object.keys(t[0].morphAttributes)),s={},o={},l=t[0].morphTargetsRelative,h=new e;let d=0;for(let e=0;e<t.length;++e){const c=t[e];let u=0;if(r!==(null!==c.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in c.attributes){if(!i.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;void 0===s[t]&&(s[t]=[]),s[t].push(c.attributes[t]),u++}if(u!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(l!==c.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in c.morphAttributes){if(!a.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===o[t]&&(o[t]=[]),o[t].push(c.morphAttributes[t])}if(n){let t;if(r)t=c.index.count;else{if(void 0===c.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;t=c.attributes.position.count}h.addGroup(d,t,e),d+=t}}if(r){let e=0;const n=[];for(let r=0;r<t.length;++r){const i=t[r].index;for(let t=0;t<i.count;++t)n.push(i.getX(t)+e);e+=t[r].attributes.position.count}h.setIndex(n)}for(const e in s){const t=Et(s[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" attribute."),null;h.setAttribute(e,t)}for(const e in o){const t=o[e][0].length;if(0===t)break;h.morphAttributes=h.morphAttributes||{},h.morphAttributes[e]=[];for(let n=0;n<t;++n){const t=[];for(let i=0;i<o[e].length;++i)t.push(o[e][i][n]);const r=Et(t);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" morphAttribute."),null;h.morphAttributes[e].push(r)}}return h}function Et(t){let e,r,i,a=0;for(let n=0;n<t.length;++n){const s=t[n];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===e&&(e=s.array.constructor),e!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=s.itemSize),r!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===i&&(i=s.normalized),i!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;a+=s.array.length}const s=new e(a);let o=0;for(let n=0;n<t.length;++n)s.set(t[n].array,o),o+=t[n].array.length;return new n(s,r,i)}function Lt(t,e=1e-4){e=Math.max(e,Number.EPSILON);const r={},i=t.getIndex(),a=t.getAttribute("position"),s=i?i.count:a.count;let o=0;const l=Object.keys(t.attributes),h={},d={},c=[],u=["getX","getY","getZ","getW"],p=["setX","setY","setZ","setW"];for(let v=0,y=l.length;v<y;v++){const e=l[v],r=t.attributes[e];h[e]=new n(new r.array.constructor(r.count*r.itemSize),r.itemSize,r.normalized);const i=t.morphAttributes[e];i&&(d[e]=new n(new i.array.constructor(i.count*i.itemSize),i.itemSize,i.normalized))}const f=Math.log10(1/e),m=Math.pow(10,f);for(let n=0;n<s;n++){const e=i?i.getX(n):n;let a="";for(let n=0,r=l.length;n<r;n++){const r=l[n],i=t.getAttribute(r),s=i.itemSize;for(let t=0;t<s;t++)a+=~~(i[u[t]](e)*m)+","}if(a in r)c.push(r[a]);else{for(let n=0,r=l.length;n<r;n++){const r=l[n],i=t.getAttribute(r),a=t.morphAttributes[r],s=i.itemSize,c=h[r],f=d[r];for(let t=0;t<s;t++){const n=u[t],r=p[t];if(c[r](o,i[n](e)),a)for(let t=0,i=a.length;t<i;t++)f[t][r](o,a[t][n](e))}}r[a]=o,c.push(o),o++}}const g=t.clone();for(const v in t.attributes){const t=h[v];if(g.setAttribute(v,new n(t.array.slice(0,o*t.itemSize),t.itemSize,t.normalized)),v in d)for(let e=0;e<d[v].length;e++){const t=d[v][e];g.morphAttributes[v][e]=new n(t.array.slice(0,o*t.itemSize),t.itemSize,t.normalized)}}return g.setIndex(c),g}const It=new WeakMap;class Nt extends r{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,e,n,r){const a=new i(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,(t=>{this.decodeDracoFile(t,e).catch(r)}),n,r)}decodeDracoFile(t,e,n,r){const i={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:r||this.defaultAttributeTypes,useUniqueIDs:!!n};return this.decodeGeometry(t,i).then(e)}decodeGeometry(t,e){const n=JSON.stringify(e);if(It.has(t)){const e=It.get(t);if(e.key===n)return e.promise;if(0===t.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let r;const i=this.workerNextTaskID++,a=t.byteLength,s=this._getWorker(i,a).then((n=>(r=n,new Promise(((n,a)=>{r._callbacks[i]={resolve:n,reject:a},r.postMessage({type:"decode",id:i,taskConfig:e,buffer:t},[t])}))))).then((t=>this._createGeometry(t.geometry)));return s.catch((()=>!0)).then((()=>{r&&i&&this._releaseTask(r,i)})),It.set(t,{key:n,promise:s}),s}_createGeometry(t){const r=new e;t.index&&r.setIndex(new n(t.index.array,1));for(let e=0;e<t.attributes.length;e++){const i=t.attributes[e],a=i.name,s=i.array,o=i.itemSize;r.setAttribute(a,new n(s,o))}return r}_loadLibrary(t,e){const n=new i(this.manager);return n.setPath(this.decoderPath),n.setResponseType(e),n.setWithCredentials(this.withCredentials),new Promise(((e,r)=>{n.load(t,e,void 0,r)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,e=[];return t?e.push(this._loadLibrary("draco_decoder.js","text")):(e.push(this._loadLibrary("draco_wasm_wrapper.js","text")),e.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(e).then((e=>{const n=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const r=jt.toString(),i=["/* draco decoder */",n,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([i]))})),this.decoderPending}_getWorker(t,e){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const t=new Worker(this.workerSourceURL);t._callbacks={},t._taskCosts={},t._taskLoad=0,t.postMessage({type:"init",decoderConfig:this.decoderConfig}),t.onmessage=function(e){const n=e.data;switch(n.type){case"decode":t._callbacks[n.id].resolve(n);break;case"error":t._callbacks[n.id].reject(n);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+n.type+'"')}},this.workerPool.push(t)}else this.workerPool.sort((function(t,e){return t._taskLoad>e._taskLoad?-1:1}));const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[t]=e,n._taskLoad+=e,n}))}_releaseTask(t,e){t._taskLoad-=t._taskCosts[e],delete t._callbacks[e],delete t._taskCosts[e]}debug(){console.log("Task load: ",this.workerPool.map((t=>t._taskLoad)))}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,""!==this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}}function jt(){let t,e;function n(t,e,n,r,i,a){const s=a.num_components(),o=n.num_points()*s,l=o*i.BYTES_PER_ELEMENT,h=function(t,e){switch(e){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}(t,i),d=t._malloc(l);e.GetAttributeDataArrayForAllPoints(n,a,h,l,d);const c=new i(t.HEAPF32.buffer,d,o).slice();return t._free(d),{name:r,array:c,itemSize:s}}onmessage=function(r){const i=r.data;switch(i.type){case"init":t=i.decoderConfig,e=new Promise((function(e){t.onModuleLoaded=function(t){e({draco:t})},DracoDecoderModule(t)}));break;case"decode":const r=i.buffer,a=i.taskConfig;e.then((t=>{const e=t.draco,s=new e.Decoder,o=new e.DecoderBuffer;o.Init(new Int8Array(r),r.byteLength);try{const t=function(t,e,r,i){const a=i.attributeIDs,s=i.attributeTypes;let o,l;const h=e.GetEncodedGeometryType(r);if(h===t.TRIANGULAR_MESH)o=new t.Mesh,l=e.DecodeBufferToMesh(r,o);else{if(h!==t.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");o=new t.PointCloud,l=e.DecodeBufferToPointCloud(r,o)}if(!l.ok()||0===o.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+l.error_msg());const d={index:null,attributes:[]};for(const c in a){const r=self[s[c]];let l,h;if(i.useUniqueIDs)h=a[c],l=e.GetAttributeByUniqueId(o,h);else{if(h=e.GetAttributeId(o,t[a[c]]),-1===h)continue;l=e.GetAttribute(o,h)}d.attributes.push(n(t,e,o,c,r,l))}h===t.TRIANGULAR_MESH&&(d.index=function(t,e,n){const r=n.num_faces(),i=3*r,a=4*i,s=t._malloc(a);e.GetTrianglesUInt32Array(n,a,s);const o=new Uint32Array(t.HEAPF32.buffer,s,i).slice();return t._free(s),{array:o,itemSize:1}}(t,e,o));return t.destroy(o),d}(e,s,o,a),r=t.attributes.map((t=>t.array.buffer));t.index&&r.push(t.index.array.buffer),self.postMessage({type:"decode",id:i.id,geometry:t},r)}catch(l){console.error(l),self.postMessage({type:"error",id:i.id,error:l.message})}finally{e.destroy(o),e.destroy(s)}}))}}}var Bt=Object.create,Ut=Object.defineProperty,kt=Object.getOwnPropertyDescriptor,Rt=Object.getOwnPropertyNames,Ft=Object.getPrototypeOf,Vt=Object.prototype.hasOwnProperty,Gt=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Ht=(t,e,n)=>(n=null!=t?Bt(Ft(t)):{},((t,e,n,r)=>{if(e&&"object"==typeof e||"function"==typeof e)for(let i of Rt(e))!Vt.call(t,i)&&i!==n&&Ut(t,i,{get:()=>e[i],enumerable:!(r=kt(e,i))||r.enumerable});return t})(!e&&t&&t.__esModule?n:Ut(n,"default",{value:t,enumerable:!0}),t)),Wt=Gt(((t,e)=>{var n,r;n=t,r=function(){return t.importState=function(e){var n=new t;return n.importState(e),n},t;function t(){return function(t){var e=0,n=0,r=0,i=1;0==t.length&&(t=[+new Date]);var a=function(){var t=4022871197,e=function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)};return e.version="Mash 0.9",e}();e=a(" "),n=a(" "),r=a(" ");for(var s=0;s<t.length;s++)(e-=a(t[s]))<0&&(e+=1),(n-=a(t[s]))<0&&(n+=1),(r-=a(t[s]))<0&&(r+=1);a=null;var o=function(){var t=2091639*e+2.3283064365386963e-10*i;return e=n,n=r,r=t-(i=0|t)};return o.next=o,o.uint32=function(){return 4294967296*o()},o.fract53=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.version="Alea 0.9",o.args=t,o.exportState=function(){return[e,n,r,i]},o.importState=function(t){e=+t[0]||0,n=+t[1]||0,r=+t[2]||0,i=+t[3]||0},o}(Array.prototype.slice.call(arguments))}},"object"==typeof t?e.exports=r():"function"==typeof define&&define.amd?define(r):n.Alea=r()})),qt=Gt(((t,e)=>{var n,r;n=t,r=function(t){t.SVD=function(t,e,n,r,i){if(e=void 0===e||e,n=void 0===n||n,i=1e-64/(r=r||Math.pow(2,-52)),!t)throw new TypeError("Matrix a is not defined");var a,s,o,l,h,d,c,u,p,f,m,g,v=t[0].length,y=t.length;if(y<v)throw new TypeError("Invalid matrix: m < n");for(var b=[],x=[],w=[],_="f"===e?y:v,S=f=c=0;S<y;S++)x[S]=new Array(_).fill(0);for(S=0;S<v;S++)w[S]=new Array(v).fill(0);var A,O=new Array(v).fill(0);for(S=0;S<y;S++)for(a=0;a<v;a++)x[S][a]=t[S][a];for(S=0;S<v;S++){for(b[S]=c,p=0,o=S+1,a=S;a<y;a++)p+=Math.pow(x[a][S],2);if(p<i)c=0;else for(u=(d=x[S][S])*(c=d<0?Math.sqrt(p):-Math.sqrt(p))-p,x[S][S]=d-c,a=o;a<v;a++){for(p=0,s=S;s<y;s++)p+=x[s][S]*x[s][a];for(d=p/u,s=S;s<y;s++)x[s][a]=x[s][a]+d*x[s][S]}for(O[S]=c,p=0,a=o;a<v;a++)p+=Math.pow(x[S][a],2);if(p<i)c=0;else{for(u=(d=x[S][S+1])*(c=d<0?Math.sqrt(p):-Math.sqrt(p))-p,x[S][S+1]=d-c,a=o;a<v;a++)b[a]=x[S][a]/u;for(a=o;a<y;a++){for(p=0,s=o;s<v;s++)p+=x[a][s]*x[S][s];for(s=o;s<v;s++)x[a][s]=x[a][s]+p*b[s]}}f<(m=Math.abs(O[S])+Math.abs(b[S]))&&(f=m)}if(n)for(S=v-1;0<=S;S--){if(0!==c){for(u=x[S][S+1]*c,a=o;a<v;a++)w[a][S]=x[S][a]/u;for(a=o;a<v;a++){for(p=0,s=o;s<v;s++)p+=x[S][s]*w[s][a];for(s=o;s<v;s++)w[s][a]=w[s][a]+p*w[s][S]}}for(a=o;a<v;a++)w[S][a]=0,w[a][S]=0;w[S][S]=1,c=b[S],o=S}if(e){if("f"===e)for(S=v;S<y;S++){for(a=v;a<y;a++)x[S][a]=0;x[S][S]=1}for(S=v-1;0<=S;S--){for(o=S+1,c=O[S],a=o;a<_;a++)x[S][a]=0;if(0!==c){for(u=x[S][S]*c,a=o;a<_;a++){for(p=0,s=o;s<y;s++)p+=x[s][S]*x[s][a];for(d=p/u,s=S;s<y;s++)x[s][a]=x[s][a]+d*x[s][S]}for(a=S;a<y;a++)x[a][S]=x[a][S]/c}else for(a=S;a<y;a++)x[a][S]=0;x[S][S]=x[S][S]+1}}for(r*=f,s=v-1;0<=s;s--)for(var M=0;M<50;M++){for(A=!1,o=s;0<=o;o--){if(Math.abs(b[o])<=r){A=!0;break}if(Math.abs(O[o-1])<=r)break}if(!A)for(h=0,l=o-(p=1),S=o;S<s+1&&(d=p*b[S],b[S]=h*b[S],!(Math.abs(d)<=r));S++)if(c=O[S],O[S]=Math.sqrt(d*d+c*c),h=c/(u=O[S]),p=-d/u,e)for(a=0;a<y;a++)m=x[a][l],g=x[a][S],x[a][l]=m*h+g*p,x[a][S]=-m*p+g*h;if(g=O[s],o===s){if(g<0&&(O[s]=-g,n))for(a=0;a<v;a++)w[a][s]=-w[a][s];break}for(f=O[o],d=(((m=O[s-1])-g)*(m+g)+((c=b[s-1])-(u=b[s]))*(c+u))/(2*u*m),c=Math.sqrt(d*d+1),d=((f-g)*(f+g)+u*(m/(d<0?d-c:d+c)-u))/f,S=o+(p=h=1);S<s+1;S++){if(c=b[S],m=O[S],u=p*c,c*=h,g=Math.sqrt(d*d+u*u),d=f*(h=d/(b[S-1]=g))+c*(p=u/g),c=-f*p+c*h,u=m*p,m*=h,n)for(a=0;a<v;a++)f=w[a][S-1],g=w[a][S],w[a][S-1]=f*h+g*p,w[a][S]=-f*p+g*h;if(g=Math.sqrt(d*d+u*u),d=(h=d/(O[S-1]=g))*c+(p=u/g)*m,f=-p*c+h*m,e)for(a=0;a<y;a++)m=x[a][S-1],g=x[a][S],x[a][S-1]=m*h+g*p,x[a][S]=-m*p+g*h}b[o]=0,b[s]=d,O[s]=f}for(S=0;S<v;S++)O[S]<r&&(O[S]=0);return{u:x,q:O,v:w}},t.VERSION="1.1.1",Object.defineProperty(t,"__esModule",{value:!0})},"object"==typeof t&&typeof e<"u"?r(t):"function"==typeof define&&define.amd?define(["exports"],r):r((n=typeof globalThis<"u"?globalThis:n||self).SVDJS={})})),$t=Gt(((t,e)=>{var n,r;n=t,r=function(){var t=function(t,n){if(void 0===t&&(t=[]),void 0===n&&(n=e),this.data=t,this.length=this.data.length,this.compare=n,this.length>0)for(var r=(this.length>>1)-1;r>=0;r--)this._down(r)};function e(t,e){return t<e?-1:t>e?1:0}return t.prototype.push=function(t){this.data.push(t),this.length++,this._up(this.length-1)},t.prototype.pop=function(){if(0!==this.length){var t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}},t.prototype.peek=function(){return this.data[0]},t.prototype._up=function(t){for(var e=this.data,n=this.compare,r=e[t];t>0;){var i=t-1>>1,a=e[i];if(n(r,a)>=0)break;e[t]=a,t=i}e[t]=r},t.prototype._down=function(t){for(var e=this.data,n=this.compare,r=this.length>>1,i=e[t];t<r;){var a=1+(t<<1),s=e[a],o=a+1;if(o<this.length&&n(e[o],s)<0&&(a=o,s=e[o]),n(s,i)>=0)break;e[t]=s,t=a}e[t]=i},t},"object"==typeof t&&typeof e<"u"?e.exports=r():"function"==typeof define&&define.amd?define(r):(n=n||self).TinyQueue=r()})),Xt=Gt(((t,e)=>{var n=$t();function r(t,e,r){e=e||1;for(var s,o,l,h,d=0;d<t[0].length;d++){var c=t[0][d];(!d||c[0]<s)&&(s=c[0]),(!d||c[1]<o)&&(o=c[1]),(!d||c[0]>l)&&(l=c[0]),(!d||c[1]>h)&&(h=c[1])}var u=l-s,p=h-o,f=Math.min(u,p),m=f/2;if(0===f){var g=[s,o];return g.distance=0,g}for(var v=new n(void 0,i),y=s;y<l;y+=f)for(var b=o;b<h;b+=f)v.push(new a(y+m,b+m,m,t));var x=function(t){for(var e=0,n=0,r=0,i=t[0],s=0,o=i.length,l=o-1;s<o;l=s++){var h=i[s],d=i[l],c=h[0]*d[1]-d[0]*h[1];n+=(h[0]+d[0])*c,r+=(h[1]+d[1])*c,e+=3*c}return 0===e?new a(i[0][0],i[0][1],0,t):new a(n/e,r/e,0,t)}(t),w=new a(s+u/2,o+p/2,0,t);w.d>x.d&&(x=w);for(var _=v.length;v.length;){var S=v.pop();S.d>x.d&&(x=S,r&&console.log("found best %d after %d probes",Math.round(1e4*S.d)/1e4,_)),!(S.max-x.d<=e)&&(m=S.h/2,v.push(new a(S.x-m,S.y-m,m,t)),v.push(new a(S.x+m,S.y-m,m,t)),v.push(new a(S.x-m,S.y+m,m,t)),v.push(new a(S.x+m,S.y+m,m,t)),_+=4)}r&&(console.log("num probes: "+_),console.log("best distance: "+x.d));var A=[x.x,x.y];return A.distance=x.d,A}function i(t,e){return e.max-t.max}function a(t,e,n,r){this.x=t,this.y=e,this.h=n,this.d=function(t,e,n){for(var r=!1,i=1/0,a=0;a<n.length;a++)for(var o=n[a],l=0,h=o.length,d=h-1;l<h;d=l++){var c=o[l],u=o[d];c[1]>e!=u[1]>e&&t<(u[0]-c[0])*(e-c[1])/(u[1]-c[1])+c[0]&&(r=!r),i=Math.min(i,s(t,e,c,u))}return 0===i?0:(r?1:-1)*Math.sqrt(i)}(t,e,r),this.max=this.d+this.h*Math.SQRT2}function s(t,e,n,r){var i=n[0],a=n[1],s=r[0]-i,o=r[1]-a;if(0!==s||0!==o){var l=((t-i)*s+(e-a)*o)/(s*s+o*o);l>1?(i=r[0],a=r[1]):l>0&&(i+=s*l,a+=o*l)}return(s=t-i)*s+(o=e-a)*o}n.default&&(n=n.default),e.exports=r,e.exports.default=r})),Yt=Gt((t=>{!function(){var e=function(){this.init()};e.prototype={init:function(){var t=this||n;return t._counter=1e3,t._html5AudioPool=[],t.html5PoolSize=10,t._codecs={},t._howls=[],t._muted=!1,t._volume=1,t._canPlayEvent="canplaythrough",t._navigator=typeof window<"u"&&window.navigator?window.navigator:null,t.masterGain=null,t.noAudio=!1,t.usingWebAudio=!0,t.autoSuspend=!0,t.ctx=null,t.autoUnlock=!0,t._setup(),t},volume:function(t){var e=this||n;if(t=parseFloat(t),e.ctx||d(),typeof t<"u"&&t>=0&&t<=1){if(e._volume=t,e._muted)return e;e.usingWebAudio&&e.masterGain.gain.setValueAtTime(t,n.ctx.currentTime);for(var r=0;r<e._howls.length;r++)if(!e._howls[r]._webAudio)for(var i=e._howls[r]._getSoundIds(),a=0;a<i.length;a++){var s=e._howls[r]._soundById(i[a]);s&&s._node&&(s._node.volume=s._volume*t)}return e}return e._volume},mute:function(t){var e=this||n;e.ctx||d(),e._muted=t,e.usingWebAudio&&e.masterGain.gain.setValueAtTime(t?0:e._volume,n.ctx.currentTime);for(var r=0;r<e._howls.length;r++)if(!e._howls[r]._webAudio)for(var i=e._howls[r]._getSoundIds(),a=0;a<i.length;a++){var s=e._howls[r]._soundById(i[a]);s&&s._node&&(s._node.muted=!!t||s._muted)}return e},stop:function(){for(var t=this||n,e=0;e<t._howls.length;e++)t._howls[e].stop();return t},unload:function(){for(var t=this||n,e=t._howls.length-1;e>=0;e--)t._howls[e].unload();return t.usingWebAudio&&t.ctx&&typeof t.ctx.close<"u"&&(t.ctx.close(),t.ctx=null,d()),t},codecs:function(t){return(this||n)._codecs[t.replace(/^x-/,"")]},_setup:function(){var t=this||n;if(t.state=t.ctx&&t.ctx.state||"suspended",t._autoSuspend(),!t.usingWebAudio)if(typeof Audio<"u")try{typeof(new Audio).oncanplaythrough>"u"&&(t._canPlayEvent="canplay")}catch{t.noAudio=!0}else t.noAudio=!0;try{(new Audio).muted&&(t.noAudio=!0)}catch{}return t.noAudio||t._setupCodecs(),t},_setupCodecs:function(){var t=this||n,e=null;try{e=typeof Audio<"u"?new Audio:null}catch{return t}if(!e||"function"!=typeof e.canPlayType)return t;var r=e.canPlayType("audio/mpeg;").replace(/^no$/,""),i=t._navigator?t._navigator.userAgent:"",a=i.match(/OPR\/([0-6].)/g),s=a&&parseInt(a[0].split("/")[1],10)<33,o=-1!==i.indexOf("Safari")&&-1===i.indexOf("Chrome"),l=i.match(/Version\/(.*?) /),h=o&&l&&parseInt(l[1],10)<15;return t._codecs={mp3:!(s||!r&&!e.canPlayType("audio/mp3;").replace(/^no$/,"")),mpeg:!!r,opus:!!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!(e.canPlayType('audio/wav; codecs="1"')||e.canPlayType("audio/wav")).replace(/^no$/,""),aac:!!e.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!e.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(e.canPlayType("audio/x-m4a;")||e.canPlayType("audio/m4a;")||e.canPlayType("audio/aac;")).replace(/^no$/,""),m4b:!!(e.canPlayType("audio/x-m4b;")||e.canPlayType("audio/m4b;")||e.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(e.canPlayType("audio/x-mp4;")||e.canPlayType("audio/mp4;")||e.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!(h||!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,"")),webm:!(h||!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,"")),dolby:!!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(e.canPlayType("audio/x-flac;")||e.canPlayType("audio/flac;")).replace(/^no$/,"")},t},_unlockAudio:function(){var t=this||n;if(!t._audioUnlocked&&t.ctx){t._audioUnlocked=!1,t.autoUnlock=!1,!t._mobileUnloaded&&44100!==t.ctx.sampleRate&&(t._mobileUnloaded=!0,t.unload()),t._scratchBuffer=t.ctx.createBuffer(1,1,22050);var e=function(n){for(;t._html5AudioPool.length<t.html5PoolSize;)try{var r=new Audio;r._unlocked=!0,t._releaseHtml5Audio(r)}catch{t.noAudio=!0;break}for(var i=0;i<t._howls.length;i++)if(!t._howls[i]._webAudio)for(var a=t._howls[i]._getSoundIds(),s=0;s<a.length;s++){var o=t._howls[i]._soundById(a[s]);o&&o._node&&!o._node._unlocked&&(o._node._unlocked=!0,o._node.load())}t._autoResume();var l=t.ctx.createBufferSource();l.buffer=t._scratchBuffer,l.connect(t.ctx.destination),typeof l.start>"u"?l.noteOn(0):l.start(0),"function"==typeof t.ctx.resume&&t.ctx.resume(),l.onended=function(){l.disconnect(0),t._audioUnlocked=!0,document.removeEventListener("touchstart",e,!0),document.removeEventListener("touchend",e,!0),document.removeEventListener("click",e,!0),document.removeEventListener("keydown",e,!0);for(var n=0;n<t._howls.length;n++)t._howls[n]._emit("unlock")}};return document.addEventListener("touchstart",e,!0),document.addEventListener("touchend",e,!0),document.addEventListener("click",e,!0),document.addEventListener("keydown",e,!0),t}},_obtainHtml5Audio:function(){var t=this||n;if(t._html5AudioPool.length)return t._html5AudioPool.pop();var e=(new Audio).play();return e&&typeof Promise<"u"&&(e instanceof Promise||"function"==typeof e.then)&&e.catch((function(){console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")})),new Audio},_releaseHtml5Audio:function(t){var e=this||n;return t._unlocked&&e._html5AudioPool.push(t),e},_autoSuspend:function(){var t=this;if(t.autoSuspend&&t.ctx&&!(typeof t.ctx.suspend>"u")&&n.usingWebAudio){for(var e=0;e<t._howls.length;e++)if(t._howls[e]._webAudio)for(var r=0;r<t._howls[e]._sounds.length;r++)if(!t._howls[e]._sounds[r]._paused)return t;return t._suspendTimer&&clearTimeout(t._suspendTimer),t._suspendTimer=setTimeout((function(){if(t.autoSuspend){t._suspendTimer=null,t.state="suspending";var e=function(){t.state="suspended",t._resumeAfterSuspend&&(delete t._resumeAfterSuspend,t._autoResume())};t.ctx.suspend().then(e,e)}}),3e4),t}},_autoResume:function(){var t=this;if(t.ctx&&!(typeof t.ctx.resume>"u")&&n.usingWebAudio)return"running"===t.state&&"interrupted"!==t.ctx.state&&t._suspendTimer?(clearTimeout(t._suspendTimer),t._suspendTimer=null):"suspended"===t.state||"running"===t.state&&"interrupted"===t.ctx.state?(t.ctx.resume().then((function(){t.state="running";for(var e=0;e<t._howls.length;e++)t._howls[e]._emit("resume")})),t._suspendTimer&&(clearTimeout(t._suspendTimer),t._suspendTimer=null)):"suspending"===t.state&&(t._resumeAfterSuspend=!0),t}};var n=new e,r=function(t){t.src&&0!==t.src.length?this.init(t):console.error("An array of source files must be passed with any new Howl.")};r.prototype={init:function(t){var e=this;return n.ctx||d(),e._autoplay=t.autoplay||!1,e._format="string"!=typeof t.format?t.format:[t.format],e._html5=t.html5||!1,e._muted=t.mute||!1,e._loop=t.loop||!1,e._pool=t.pool||5,e._preload="boolean"!=typeof t.preload&&"metadata"!==t.preload||t.preload,e._rate=t.rate||1,e._sprite=t.sprite||{},e._src="string"!=typeof t.src?t.src:[t.src],e._volume=void 0!==t.volume?t.volume:1,e._xhr={method:t.xhr&&t.xhr.method?t.xhr.method:"GET",headers:t.xhr&&t.xhr.headers?t.xhr.headers:null,withCredentials:!(!t.xhr||!t.xhr.withCredentials)&&t.xhr.withCredentials},e._duration=0,e._state="unloaded",e._sounds=[],e._endTimers={},e._queue=[],e._playLock=!1,e._onend=t.onend?[{fn:t.onend}]:[],e._onfade=t.onfade?[{fn:t.onfade}]:[],e._onload=t.onload?[{fn:t.onload}]:[],e._onloaderror=t.onloaderror?[{fn:t.onloaderror}]:[],e._onplayerror=t.onplayerror?[{fn:t.onplayerror}]:[],e._onpause=t.onpause?[{fn:t.onpause}]:[],e._onplay=t.onplay?[{fn:t.onplay}]:[],e._onstop=t.onstop?[{fn:t.onstop}]:[],e._onmute=t.onmute?[{fn:t.onmute}]:[],e._onvolume=t.onvolume?[{fn:t.onvolume}]:[],e._onrate=t.onrate?[{fn:t.onrate}]:[],e._onseek=t.onseek?[{fn:t.onseek}]:[],e._onunlock=t.onunlock?[{fn:t.onunlock}]:[],e._onresume=[],e._webAudio=n.usingWebAudio&&!e._html5,typeof n.ctx<"u"&&n.ctx&&n.autoUnlock&&n._unlockAudio(),n._howls.push(e),e._autoplay&&e._queue.push({event:"play",action:function(){e.play()}}),e._preload&&"none"!==e._preload&&e.load(),e},load:function(){var t=this,e=null;if(n.noAudio)t._emit("loaderror",null,"No audio support.");else{"string"==typeof t._src&&(t._src=[t._src]);for(var r=0;r<t._src.length;r++){var a,o;if(t._format&&t._format[r])a=t._format[r];else{if("string"!=typeof(o=t._src[r])){t._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}(a=/^data:audio\/([^;,]+);/i.exec(o))||(a=/\.([^.]+)$/.exec(o.split("?",1)[0])),a&&(a=a[1].toLowerCase())}if(a||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),a&&n.codecs(a)){e=t._src[r];break}}if(e)return t._src=e,t._state="loading","https:"===window.location.protocol&&"http:"===e.slice(0,5)&&(t._html5=!0,t._webAudio=!1),new i(t),t._webAudio&&s(t),t;t._emit("loaderror",null,"No codec support for selected audio sources.")}},play:function(t,e){var r=this,i=null;if("number"==typeof t)i=t,t=null;else{if("string"==typeof t&&"loaded"===r._state&&!r._sprite[t])return null;if(typeof t>"u"&&(t="__default",!r._playLock)){for(var a=0,s=0;s<r._sounds.length;s++)r._sounds[s]._paused&&!r._sounds[s]._ended&&(a++,i=r._sounds[s]._id);1===a?t=null:i=null}}var o=i?r._soundById(i):r._inactiveSound();if(!o)return null;if(i&&!t&&(t=o._sprite||"__default"),"loaded"!==r._state){o._sprite=t,o._ended=!1;var l=o._id;return r._queue.push({event:"play",action:function(){r.play(l)}}),l}if(i&&!o._paused)return e||r._loadQueue("play"),o._id;r._webAudio&&n._autoResume();var h=Math.max(0,o._seek>0?o._seek:r._sprite[t][0]/1e3),d=Math.max(0,(r._sprite[t][0]+r._sprite[t][1])/1e3-h),c=1e3*d/Math.abs(o._rate),u=r._sprite[t][0]/1e3,p=(r._sprite[t][0]+r._sprite[t][1])/1e3;o._sprite=t,o._ended=!1;var f=function(){o._paused=!1,o._seek=h,o._start=u,o._stop=p,o._loop=!(!o._loop&&!r._sprite[t][2])};if(!(h>=p)){var m=o._node;if(r._webAudio){var g=function(){r._playLock=!1,f(),r._refreshBuffer(o);var t=o._muted||r._muted?0:o._volume;m.gain.setValueAtTime(t,n.ctx.currentTime),o._playStart=n.ctx.currentTime,typeof m.bufferSource.start>"u"?o._loop?m.bufferSource.noteGrainOn(0,h,86400):m.bufferSource.noteGrainOn(0,h,d):o._loop?m.bufferSource.start(0,h,86400):m.bufferSource.start(0,h,d),c!==1/0&&(r._endTimers[o._id]=setTimeout(r._ended.bind(r,o),c)),e||setTimeout((function(){r._emit("play",o._id),r._loadQueue()}),0)};"running"===n.state&&"interrupted"!==n.ctx.state?g():(r._playLock=!0,r.once("resume",g),r._clearTimer(o._id))}else{var v=function(){m.currentTime=h,m.muted=o._muted||r._muted||n._muted||m.muted,m.volume=o._volume*n.volume(),m.playbackRate=o._rate;try{var i=m.play();if(i&&typeof Promise<"u"&&(i instanceof Promise||"function"==typeof i.then)?(r._playLock=!0,f(),i.then((function(){r._playLock=!1,m._unlocked=!0,e?r._loadQueue():r._emit("play",o._id)})).catch((function(){r._playLock=!1,r._emit("playerror",o._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),o._ended=!0,o._paused=!0}))):e||(r._playLock=!1,f(),r._emit("play",o._id)),m.playbackRate=o._rate,m.paused)return void r._emit("playerror",o._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");"__default"!==t||o._loop?r._endTimers[o._id]=setTimeout(r._ended.bind(r,o),c):(r._endTimers[o._id]=function(){r._ended(o),m.removeEventListener("ended",r._endTimers[o._id],!1)},m.addEventListener("ended",r._endTimers[o._id],!1))}catch(a){r._emit("playerror",o._id,a)}};"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"===m.src&&(m.src=r._src,m.load());var y=window&&window.ejecta||!m.readyState&&n._navigator.isCocoonJS;if(m.readyState>=3||y)v();else{r._playLock=!0,r._state="loading";var b=function(){r._state="loaded",v(),m.removeEventListener(n._canPlayEvent,b,!1)};m.addEventListener(n._canPlayEvent,b,!1),r._clearTimer(o._id)}}return o._id}r._ended(o)},pause:function(t){var e=this;if("loaded"!==e._state||e._playLock)return e._queue.push({event:"pause",action:function(){e.pause(t)}}),e;for(var n=e._getSoundIds(t),r=0;r<n.length;r++){e._clearTimer(n[r]);var i=e._soundById(n[r]);if(i&&!i._paused&&(i._seek=e.seek(n[r]),i._rateSeek=0,i._paused=!0,e._stopFade(n[r]),i._node))if(e._webAudio){if(!i._node.bufferSource)continue;typeof i._node.bufferSource.stop>"u"?i._node.bufferSource.noteOff(0):i._node.bufferSource.stop(0),e._cleanBuffer(i._node)}else(!isNaN(i._node.duration)||i._node.duration===1/0)&&i._node.pause();arguments[1]||e._emit("pause",i?i._id:null)}return e},stop:function(t,e){var n=this;if("loaded"!==n._state||n._playLock)return n._queue.push({event:"stop",action:function(){n.stop(t)}}),n;for(var r=n._getSoundIds(t),i=0;i<r.length;i++){n._clearTimer(r[i]);var a=n._soundById(r[i]);a&&(a._seek=a._start||0,a._rateSeek=0,a._paused=!0,a._ended=!0,n._stopFade(r[i]),a._node&&(n._webAudio?a._node.bufferSource&&(typeof a._node.bufferSource.stop>"u"?a._node.bufferSource.noteOff(0):a._node.bufferSource.stop(0),n._cleanBuffer(a._node)):(!isNaN(a._node.duration)||a._node.duration===1/0)&&(a._node.currentTime=a._start||0,a._node.pause(),a._node.duration===1/0&&n._clearSound(a._node))),e||n._emit("stop",a._id))}return n},mute:function(t,e){var r=this;if("loaded"!==r._state||r._playLock)return r._queue.push({event:"mute",action:function(){r.mute(t,e)}}),r;if(typeof e>"u"){if("boolean"!=typeof t)return r._muted;r._muted=t}for(var i=r._getSoundIds(e),a=0;a<i.length;a++){var s=r._soundById(i[a]);s&&(s._muted=t,s._interval&&r._stopFade(s._id),r._webAudio&&s._node?s._node.gain.setValueAtTime(t?0:s._volume,n.ctx.currentTime):s._node&&(s._node.muted=!!n._muted||t),r._emit("mute",s._id))}return r},volume:function(){var t,e,r,i=this,a=arguments;if(0===a.length)return i._volume;1===a.length||2===a.length&&typeof a[1]>"u"?i._getSoundIds().indexOf(a[0])>=0?e=parseInt(a[0],10):t=parseFloat(a[0]):a.length>=2&&(t=parseFloat(a[0]),e=parseInt(a[1],10));if(!(typeof t<"u"&&t>=0&&t<=1))return(r=e?i._soundById(e):i._sounds[0])?r._volume:0;if("loaded"!==i._state||i._playLock)return i._queue.push({event:"volume",action:function(){i.volume.apply(i,a)}}),i;typeof e>"u"&&(i._volume=t),e=i._getSoundIds(e);for(var s=0;s<e.length;s++)(r=i._soundById(e[s]))&&(r._volume=t,a[2]||i._stopFade(e[s]),i._webAudio&&r._node&&!r._muted?r._node.gain.setValueAtTime(t,n.ctx.currentTime):r._node&&!r._muted&&(r._node.volume=t*n.volume()),i._emit("volume",r._id));return i},fade:function(t,e,r,i){var a=this;if("loaded"!==a._state||a._playLock)return a._queue.push({event:"fade",action:function(){a.fade(t,e,r,i)}}),a;t=Math.min(Math.max(0,parseFloat(t)),1),e=Math.min(Math.max(0,parseFloat(e)),1),r=parseFloat(r),a.volume(t,i);for(var s=a._getSoundIds(i),o=0;o<s.length;o++){var l=a._soundById(s[o]);if(l){if(i||a._stopFade(s[o]),a._webAudio&&!l._muted){var h=n.ctx.currentTime,d=h+r/1e3;l._volume=t,l._node.gain.setValueAtTime(t,h),l._node.gain.linearRampToValueAtTime(e,d)}a._startFadeInterval(l,t,e,r,s[o],typeof i>"u")}}return a},_startFadeInterval:function(t,e,n,r,i,a){var s=this,o=e,l=n-e,h=Math.abs(l/.01),d=Math.max(4,h>0?r/h:r),c=Date.now();t._fadeTo=n,t._interval=setInterval((function(){var i=(Date.now()-c)/r;c=Date.now(),o+=l*i,o=Math.round(100*o)/100,o=l<0?Math.max(n,o):Math.min(n,o),s._webAudio?t._volume=o:s.volume(o,t._id,!0),a&&(s._volume=o),(n<e&&o<=n||n>e&&o>=n)&&(clearInterval(t._interval),t._interval=null,t._fadeTo=null,s.volume(n,t._id),s._emit("fade",t._id))}),d)},_stopFade:function(t){var e=this,r=e._soundById(t);return r&&r._interval&&(e._webAudio&&r._node.gain.cancelScheduledValues(n.ctx.currentTime),clearInterval(r._interval),r._interval=null,e.volume(r._fadeTo,t),r._fadeTo=null,e._emit("fade",t)),e},loop:function(){var t,e,n,r=this,i=arguments;if(0===i.length)return r._loop;if(1===i.length){if("boolean"!=typeof i[0])return!!(n=r._soundById(parseInt(i[0],10)))&&n._loop;t=i[0],r._loop=t}else 2===i.length&&(t=i[0],e=parseInt(i[1],10));for(var a=r._getSoundIds(e),s=0;s<a.length;s++)(n=r._soundById(a[s]))&&(n._loop=t,r._webAudio&&n._node&&n._node.bufferSource&&(n._node.bufferSource.loop=t,t&&(n._node.bufferSource.loopStart=n._start||0,n._node.bufferSource.loopEnd=n._stop,r.playing(a[s])&&(r.pause(a[s],!0),r.play(a[s],!0)))));return r},rate:function(){var t,e,r,i=this,a=arguments;if(0===a.length)e=i._sounds[0]._id;else if(1===a.length){i._getSoundIds().indexOf(a[0])>=0?e=parseInt(a[0],10):t=parseFloat(a[0])}else 2===a.length&&(t=parseFloat(a[0]),e=parseInt(a[1],10));if("number"!=typeof t)return(r=i._soundById(e))?r._rate:i._rate;if("loaded"!==i._state||i._playLock)return i._queue.push({event:"rate",action:function(){i.rate.apply(i,a)}}),i;typeof e>"u"&&(i._rate=t),e=i._getSoundIds(e);for(var s=0;s<e.length;s++)if(r=i._soundById(e[s])){i.playing(e[s])&&(r._rateSeek=i.seek(e[s]),r._playStart=i._webAudio?n.ctx.currentTime:r._playStart),r._rate=t,i._webAudio&&r._node&&r._node.bufferSource?r._node.bufferSource.playbackRate.setValueAtTime(t,n.ctx.currentTime):r._node&&(r._node.playbackRate=t);var o=i.seek(e[s]),l=1e3*((i._sprite[r._sprite][0]+i._sprite[r._sprite][1])/1e3-o)/Math.abs(r._rate);(i._endTimers[e[s]]||!r._paused)&&(i._clearTimer(e[s]),i._endTimers[e[s]]=setTimeout(i._ended.bind(i,r),l)),i._emit("rate",r._id)}return i},seek:function(){var t,e,r=this,i=arguments;if(0===i.length)r._sounds.length&&(e=r._sounds[0]._id);else if(1===i.length){r._getSoundIds().indexOf(i[0])>=0?e=parseInt(i[0],10):r._sounds.length&&(e=r._sounds[0]._id,t=parseFloat(i[0]))}else 2===i.length&&(t=parseFloat(i[0]),e=parseInt(i[1],10));if(typeof e>"u")return 0;if("number"==typeof t&&("loaded"!==r._state||r._playLock))return r._queue.push({event:"seek",action:function(){r.seek.apply(r,i)}}),r;var a=r._soundById(e);if(a){if(!("number"==typeof t&&t>=0)){if(r._webAudio){var s=r.playing(e)?n.ctx.currentTime-a._playStart:0,o=a._rateSeek?a._rateSeek-a._seek:0;return a._seek+(o+s*Math.abs(a._rate))}return a._node.currentTime}var l=r.playing(e);l&&r.pause(e,!0),a._seek=t,a._ended=!1,r._clearTimer(e),!r._webAudio&&a._node&&!isNaN(a._node.duration)&&(a._node.currentTime=t);var h=function(){l&&r.play(e,!0),r._emit("seek",e)};if(l&&!r._webAudio){var d=function(){r._playLock?setTimeout(d,0):h()};setTimeout(d,0)}else h()}return r},playing:function(t){var e=this;if("number"==typeof t){var n=e._soundById(t);return!!n&&!n._paused}for(var r=0;r<e._sounds.length;r++)if(!e._sounds[r]._paused)return!0;return!1},duration:function(t){var e=this,n=e._duration,r=e._soundById(t);return r&&(n=e._sprite[r._sprite][1]/1e3),n},state:function(){return this._state},unload:function(){for(var t=this,e=t._sounds,r=0;r<e.length;r++)e[r]._paused||t.stop(e[r]._id),t._webAudio||(t._clearSound(e[r]._node),e[r]._node.removeEventListener("error",e[r]._errorFn,!1),e[r]._node.removeEventListener(n._canPlayEvent,e[r]._loadFn,!1),e[r]._node.removeEventListener("ended",e[r]._endFn,!1),n._releaseHtml5Audio(e[r]._node)),delete e[r]._node,t._clearTimer(e[r]._id);var i=n._howls.indexOf(t);i>=0&&n._howls.splice(i,1);var s=!0;for(r=0;r<n._howls.length;r++)if(n._howls[r]._src===t._src||t._src.indexOf(n._howls[r]._src)>=0){s=!1;break}return a&&s&&delete a[t._src],n.noAudio=!1,t._state="unloaded",t._sounds=[],t=null,null},on:function(t,e,n,r){var i=this["_on"+t];return"function"==typeof e&&i.push(r?{id:n,fn:e,once:r}:{id:n,fn:e}),this},off:function(t,e,n){var r=this,i=r["_on"+t],a=0;if("number"==typeof e&&(n=e,e=null),e||n)for(a=0;a<i.length;a++){var s=n===i[a].id;if(e===i[a].fn&&s||!e&&s){i.splice(a,1);break}}else if(t)r["_on"+t]=[];else{var o=Object.keys(r);for(a=0;a<o.length;a++)0===o[a].indexOf("_on")&&Array.isArray(r[o[a]])&&(r[o[a]]=[])}return r},once:function(t,e,n){return this.on(t,e,n,1),this},_emit:function(t,e,n){for(var r=this,i=r["_on"+t],a=i.length-1;a>=0;a--)(!i[a].id||i[a].id===e||"load"===t)&&(setTimeout(function(t){t.call(this,e,n)}.bind(r,i[a].fn),0),i[a].once&&r.off(t,i[a].fn,i[a].id));return r._loadQueue(t),r},_loadQueue:function(t){var e=this;if(e._queue.length>0){var n=e._queue[0];n.event===t&&(e._queue.shift(),e._loadQueue()),t||n.action()}return e},_ended:function(t){var e=this,r=t._sprite;if(!e._webAudio&&t._node&&!t._node.paused&&!t._node.ended&&t._node.currentTime<t._stop)return setTimeout(e._ended.bind(e,t),100),e;var i=!(!t._loop&&!e._sprite[r][2]);if(e._emit("end",t._id),!e._webAudio&&i&&e.stop(t._id,!0).play(t._id),e._webAudio&&i){e._emit("play",t._id),t._seek=t._start||0,t._rateSeek=0,t._playStart=n.ctx.currentTime;var a=1e3*(t._stop-t._start)/Math.abs(t._rate);e._endTimers[t._id]=setTimeout(e._ended.bind(e,t),a)}return e._webAudio&&!i&&(t._paused=!0,t._ended=!0,t._seek=t._start||0,t._rateSeek=0,e._clearTimer(t._id),e._cleanBuffer(t._node),n._autoSuspend()),!e._webAudio&&!i&&e.stop(t._id,!0),e},_clearTimer:function(t){var e=this;if(e._endTimers[t]){if("function"!=typeof e._endTimers[t])clearTimeout(e._endTimers[t]);else{var n=e._soundById(t);n&&n._node&&n._node.removeEventListener("ended",e._endTimers[t],!1)}delete e._endTimers[t]}return e},_soundById:function(t){for(var e=this,n=0;n<e._sounds.length;n++)if(t===e._sounds[n]._id)return e._sounds[n];return null},_inactiveSound:function(){var t=this;t._drain();for(var e=0;e<t._sounds.length;e++)if(t._sounds[e]._ended)return t._sounds[e].reset();return new i(t)},_drain:function(){var t=this,e=t._pool,n=0,r=0;if(!(t._sounds.length<e)){for(r=0;r<t._sounds.length;r++)t._sounds[r]._ended&&n++;for(r=t._sounds.length-1;r>=0;r--){if(n<=e)return;t._sounds[r]._ended&&(t._webAudio&&t._sounds[r]._node&&t._sounds[r]._node.disconnect(0),t._sounds.splice(r,1),n--)}}},_getSoundIds:function(t){if(typeof t>"u"){for(var e=[],n=0;n<this._sounds.length;n++)e.push(this._sounds[n]._id);return e}return[t]},_refreshBuffer:function(t){return t._node.bufferSource=n.ctx.createBufferSource(),t._node.bufferSource.buffer=a[this._src],t._panner?t._node.bufferSource.connect(t._panner):t._node.bufferSource.connect(t._node),t._node.bufferSource.loop=t._loop,t._loop&&(t._node.bufferSource.loopStart=t._start||0,t._node.bufferSource.loopEnd=t._stop||0),t._node.bufferSource.playbackRate.setValueAtTime(t._rate,n.ctx.currentTime),this},_cleanBuffer:function(t){var e=n._navigator&&n._navigator.vendor.indexOf("Apple")>=0;if(n._scratchBuffer&&t.bufferSource&&(t.bufferSource.onended=null,t.bufferSource.disconnect(0),e))try{t.bufferSource.buffer=n._scratchBuffer}catch{}return t.bufferSource=null,this},_clearSound:function(t){/MSIE |Trident\//.test(n._navigator&&n._navigator.userAgent)||(t.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")}};var i=function(t){this._parent=t,this.init()};i.prototype={init:function(){var t=this,e=t._parent;return t._muted=e._muted,t._loop=e._loop,t._volume=e._volume,t._rate=e._rate,t._seek=0,t._paused=!0,t._ended=!0,t._sprite="__default",t._id=++n._counter,e._sounds.push(t),t.create(),t},create:function(){var t=this,e=t._parent,r=n._muted||t._muted||t._parent._muted?0:t._volume;return e._webAudio?(t._node=typeof n.ctx.createGain>"u"?n.ctx.createGainNode():n.ctx.createGain(),t._node.gain.setValueAtTime(r,n.ctx.currentTime),t._node.paused=!0,t._node.connect(n.masterGain)):n.noAudio||(t._node=n._obtainHtml5Audio(),t._errorFn=t._errorListener.bind(t),t._node.addEventListener("error",t._errorFn,!1),t._loadFn=t._loadListener.bind(t),t._node.addEventListener(n._canPlayEvent,t._loadFn,!1),t._endFn=t._endListener.bind(t),t._node.addEventListener("ended",t._endFn,!1),t._node.src=e._src,t._node.preload=!0===e._preload?"auto":e._preload,t._node.volume=r*n.volume(),t._node.load()),t},reset:function(){var t=this,e=t._parent;return t._muted=e._muted,t._loop=e._loop,t._volume=e._volume,t._rate=e._rate,t._seek=0,t._rateSeek=0,t._paused=!0,t._ended=!0,t._sprite="__default",t._id=++n._counter,t},_errorListener:function(){var t=this;t._parent._emit("loaderror",t._id,t._node.error?t._node.error.code:0),t._node.removeEventListener("error",t._errorFn,!1)},_loadListener:function(){var t=this,e=t._parent;e._duration=Math.ceil(10*t._node.duration)/10,0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue()),t._node.removeEventListener(n._canPlayEvent,t._loadFn,!1)},_endListener:function(){var t=this,e=t._parent;e._duration===1/0&&(e._duration=Math.ceil(10*t._node.duration)/10,e._sprite.__default[1]===1/0&&(e._sprite.__default[1]=1e3*e._duration),e._ended(t)),t._node.removeEventListener("ended",t._endFn,!1)}};var a={},s=function(t){var e=t._src;if(a[e])return t._duration=a[e].duration,void h(t);if(/^data:[^;]+;base64,/.test(e)){for(var n=atob(e.split(",")[1]),r=new Uint8Array(n.length),i=0;i<n.length;++i)r[i]=n.charCodeAt(i);l(r.buffer,t)}else{var s=new XMLHttpRequest;s.open(t._xhr.method,e,!0),s.withCredentials=t._xhr.withCredentials,s.responseType="arraybuffer",t._xhr.headers&&Object.keys(t._xhr.headers).forEach((function(e){s.setRequestHeader(e,t._xhr.headers[e])})),s.onload=function(){var e=(s.status+"")[0];"0"===e||"2"===e||"3"===e?l(s.response,t):t._emit("loaderror",null,"Failed loading audio file with status: "+s.status+".")},s.onerror=function(){t._webAudio&&(t._html5=!0,t._webAudio=!1,t._sounds=[],delete a[e],t.load())},o(s)}},o=function(t){try{t.send()}catch{t.onerror()}},l=function(t,e){var r=function(){e._emit("loaderror",null,"Decoding audio data failed.")},i=function(t){t&&e._sounds.length>0?(a[e._src]=t,h(e,t)):r()};typeof Promise<"u"&&1===n.ctx.decodeAudioData.length?n.ctx.decodeAudioData(t).then(i).catch(r):n.ctx.decodeAudioData(t,i,r)},h=function(t,e){e&&!t._duration&&(t._duration=e.duration),0===Object.keys(t._sprite).length&&(t._sprite={__default:[0,1e3*t._duration]}),"loaded"!==t._state&&(t._state="loaded",t._emit("load"),t._loadQueue())},d=function(){if(n.usingWebAudio){try{typeof AudioContext<"u"?n.ctx=new AudioContext:typeof webkitAudioContext<"u"?n.ctx=new webkitAudioContext:n.usingWebAudio=!1}catch{n.usingWebAudio=!1}n.ctx||(n.usingWebAudio=!1);var t=/iP(hone|od|ad)/.test(n._navigator&&n._navigator.platform),e=n._navigator&&n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),r=e?parseInt(e[1],10):null;if(t&&r&&r<9){var i=/safari/.test(n._navigator&&n._navigator.userAgent.toLowerCase());n._navigator&&!i&&(n.usingWebAudio=!1)}n.usingWebAudio&&(n.masterGain=typeof n.ctx.createGain>"u"?n.ctx.createGainNode():n.ctx.createGain(),n.masterGain.gain.setValueAtTime(n._muted?0:n._volume,n.ctx.currentTime),n.masterGain.connect(n.ctx.destination)),n._setup()}};"function"==typeof define&&define.amd&&define([],(function(){return{Howler:n,Howl:r}})),typeof t<"u"&&(t.Howler=n,t.Howl=r),typeof global<"u"?(global.HowlerGlobal=e,global.Howler=n,global.Howl=r,global.Sound=i):typeof window<"u"&&(window.HowlerGlobal=e,window.Howler=n,window.Howl=r,window.Sound=i)}(),function(){var t;HowlerGlobal.prototype._pos=[0,0,0],HowlerGlobal.prototype._orientation=[0,0,-1,0,1,0],HowlerGlobal.prototype.stereo=function(t){var e=this;if(!e.ctx||!e.ctx.listener)return e;for(var n=e._howls.length-1;n>=0;n--)e._howls[n].stereo(t);return e},HowlerGlobal.prototype.pos=function(t,e,n){var r=this;return r.ctx&&r.ctx.listener?(e="number"!=typeof e?r._pos[1]:e,n="number"!=typeof n?r._pos[2]:n,"number"!=typeof t?r._pos:(r._pos=[t,e,n],typeof r.ctx.listener.positionX<"u"?(r.ctx.listener.positionX.setTargetAtTime(r._pos[0],Howler.ctx.currentTime,.1),r.ctx.listener.positionY.setTargetAtTime(r._pos[1],Howler.ctx.currentTime,.1),r.ctx.listener.positionZ.setTargetAtTime(r._pos[2],Howler.ctx.currentTime,.1)):r.ctx.listener.setPosition(r._pos[0],r._pos[1],r._pos[2]),r)):r},HowlerGlobal.prototype.orientation=function(t,e,n,r,i,a){var s=this;if(!s.ctx||!s.ctx.listener)return s;var o=s._orientation;return e="number"!=typeof e?o[1]:e,n="number"!=typeof n?o[2]:n,r="number"!=typeof r?o[3]:r,i="number"!=typeof i?o[4]:i,a="number"!=typeof a?o[5]:a,"number"!=typeof t?o:(s._orientation=[t,e,n,r,i,a],typeof s.ctx.listener.forwardX<"u"?(s.ctx.listener.forwardX.setTargetAtTime(t,Howler.ctx.currentTime,.1),s.ctx.listener.forwardY.setTargetAtTime(e,Howler.ctx.currentTime,.1),s.ctx.listener.forwardZ.setTargetAtTime(n,Howler.ctx.currentTime,.1),s.ctx.listener.upX.setTargetAtTime(r,Howler.ctx.currentTime,.1),s.ctx.listener.upY.setTargetAtTime(i,Howler.ctx.currentTime,.1),s.ctx.listener.upZ.setTargetAtTime(a,Howler.ctx.currentTime,.1)):s.ctx.listener.setOrientation(t,e,n,r,i,a),s)},Howl.prototype.init=(t=Howl.prototype.init,function(e){var n=this;return n._orientation=e.orientation||[1,0,0],n._stereo=e.stereo||null,n._pos=e.pos||null,n._pannerAttr={coneInnerAngle:typeof e.coneInnerAngle<"u"?e.coneInnerAngle:360,coneOuterAngle:typeof e.coneOuterAngle<"u"?e.coneOuterAngle:360,coneOuterGain:typeof e.coneOuterGain<"u"?e.coneOuterGain:0,distanceModel:typeof e.distanceModel<"u"?e.distanceModel:"inverse",maxDistance:typeof e.maxDistance<"u"?e.maxDistance:1e4,panningModel:typeof e.panningModel<"u"?e.panningModel:"HRTF",refDistance:typeof e.refDistance<"u"?e.refDistance:1,rolloffFactor:typeof e.rolloffFactor<"u"?e.rolloffFactor:1},n._onstereo=e.onstereo?[{fn:e.onstereo}]:[],n._onpos=e.onpos?[{fn:e.onpos}]:[],n._onorientation=e.onorientation?[{fn:e.onorientation}]:[],t.call(this,e)}),Howl.prototype.stereo=function(t,n){var r=this;if(!r._webAudio)return r;if("loaded"!==r._state)return r._queue.push({event:"stereo",action:function(){r.stereo(t,n)}}),r;var i=typeof Howler.ctx.createStereoPanner>"u"?"spatial":"stereo";if(typeof n>"u"){if("number"!=typeof t)return r._stereo;r._stereo=t,r._pos=[t,0,0]}for(var a=r._getSoundIds(n),s=0;s<a.length;s++){var o=r._soundById(a[s]);if(o){if("number"!=typeof t)return o._stereo;o._stereo=t,o._pos=[t,0,0],o._node&&(o._pannerAttr.panningModel="equalpower",(!o._panner||!o._panner.pan)&&e(o,i),"spatial"===i?typeof o._panner.positionX<"u"?(o._panner.positionX.setValueAtTime(t,Howler.ctx.currentTime),o._panner.positionY.setValueAtTime(0,Howler.ctx.currentTime),o._panner.positionZ.setValueAtTime(0,Howler.ctx.currentTime)):o._panner.setPosition(t,0,0):o._panner.pan.setValueAtTime(t,Howler.ctx.currentTime)),r._emit("stereo",o._id)}}return r},Howl.prototype.pos=function(t,n,r,i){var a=this;if(!a._webAudio)return a;if("loaded"!==a._state)return a._queue.push({event:"pos",action:function(){a.pos(t,n,r,i)}}),a;if(n="number"!=typeof n?0:n,r="number"!=typeof r?-.5:r,typeof i>"u"){if("number"!=typeof t)return a._pos;a._pos=[t,n,r]}for(var s=a._getSoundIds(i),o=0;o<s.length;o++){var l=a._soundById(s[o]);if(l){if("number"!=typeof t)return l._pos;l._pos=[t,n,r],l._node&&((!l._panner||l._panner.pan)&&e(l,"spatial"),typeof l._panner.positionX<"u"?(l._panner.positionX.setValueAtTime(t,Howler.ctx.currentTime),l._panner.positionY.setValueAtTime(n,Howler.ctx.currentTime),l._panner.positionZ.setValueAtTime(r,Howler.ctx.currentTime)):l._panner.setPosition(t,n,r)),a._emit("pos",l._id)}}return a},Howl.prototype.orientation=function(t,n,r,i){var a=this;if(!a._webAudio)return a;if("loaded"!==a._state)return a._queue.push({event:"orientation",action:function(){a.orientation(t,n,r,i)}}),a;if(n="number"!=typeof n?a._orientation[1]:n,r="number"!=typeof r?a._orientation[2]:r,typeof i>"u"){if("number"!=typeof t)return a._orientation;a._orientation=[t,n,r]}for(var s=a._getSoundIds(i),o=0;o<s.length;o++){var l=a._soundById(s[o]);if(l){if("number"!=typeof t)return l._orientation;l._orientation=[t,n,r],l._node&&(l._panner||(l._pos||(l._pos=a._pos||[0,0,-.5]),e(l,"spatial")),typeof l._panner.orientationX<"u"?(l._panner.orientationX.setValueAtTime(t,Howler.ctx.currentTime),l._panner.orientationY.setValueAtTime(n,Howler.ctx.currentTime),l._panner.orientationZ.setValueAtTime(r,Howler.ctx.currentTime)):l._panner.setOrientation(t,n,r)),a._emit("orientation",l._id)}}return a},Howl.prototype.pannerAttr=function(){var t,n,r,i=this,a=arguments;if(!i._webAudio)return i;if(0===a.length)return i._pannerAttr;if(1===a.length){if("object"!=typeof a[0])return(r=i._soundById(parseInt(a[0],10)))?r._pannerAttr:i._pannerAttr;t=a[0],typeof n>"u"&&(t.pannerAttr||(t.pannerAttr={coneInnerAngle:t.coneInnerAngle,coneOuterAngle:t.coneOuterAngle,coneOuterGain:t.coneOuterGain,distanceModel:t.distanceModel,maxDistance:t.maxDistance,refDistance:t.refDistance,rolloffFactor:t.rolloffFactor,panningModel:t.panningModel}),i._pannerAttr={coneInnerAngle:typeof t.pannerAttr.coneInnerAngle<"u"?t.pannerAttr.coneInnerAngle:i._coneInnerAngle,coneOuterAngle:typeof t.pannerAttr.coneOuterAngle<"u"?t.pannerAttr.coneOuterAngle:i._coneOuterAngle,coneOuterGain:typeof t.pannerAttr.coneOuterGain<"u"?t.pannerAttr.coneOuterGain:i._coneOuterGain,distanceModel:typeof t.pannerAttr.distanceModel<"u"?t.pannerAttr.distanceModel:i._distanceModel,maxDistance:typeof t.pannerAttr.maxDistance<"u"?t.pannerAttr.maxDistance:i._maxDistance,refDistance:typeof t.pannerAttr.refDistance<"u"?t.pannerAttr.refDistance:i._refDistance,rolloffFactor:typeof t.pannerAttr.rolloffFactor<"u"?t.pannerAttr.rolloffFactor:i._rolloffFactor,panningModel:typeof t.pannerAttr.panningModel<"u"?t.pannerAttr.panningModel:i._panningModel})}else 2===a.length&&(t=a[0],n=parseInt(a[1],10));for(var s=i._getSoundIds(n),o=0;o<s.length;o++)if(r=i._soundById(s[o])){var l=r._pannerAttr;l={coneInnerAngle:typeof t.coneInnerAngle<"u"?t.coneInnerAngle:l.coneInnerAngle,coneOuterAngle:typeof t.coneOuterAngle<"u"?t.coneOuterAngle:l.coneOuterAngle,coneOuterGain:typeof t.coneOuterGain<"u"?t.coneOuterGain:l.coneOuterGain,distanceModel:typeof t.distanceModel<"u"?t.distanceModel:l.distanceModel,maxDistance:typeof t.maxDistance<"u"?t.maxDistance:l.maxDistance,refDistance:typeof t.refDistance<"u"?t.refDistance:l.refDistance,rolloffFactor:typeof t.rolloffFactor<"u"?t.rolloffFactor:l.rolloffFactor,panningModel:typeof t.panningModel<"u"?t.panningModel:l.panningModel};var h=r._panner;h?(h.coneInnerAngle=l.coneInnerAngle,h.coneOuterAngle=l.coneOuterAngle,h.coneOuterGain=l.coneOuterGain,h.distanceModel=l.distanceModel,h.maxDistance=l.maxDistance,h.refDistance=l.refDistance,h.rolloffFactor=l.rolloffFactor,h.panningModel=l.panningModel):(r._pos||(r._pos=i._pos||[0,0,-.5]),e(r,"spatial"))}return i},Sound.prototype.init=function(t){return function(){var e=this,n=e._parent;e._orientation=n._orientation,e._stereo=n._stereo,e._pos=n._pos,e._pannerAttr=n._pannerAttr,t.call(this),e._stereo?n.stereo(e._stereo):e._pos&&n.pos(e._pos[0],e._pos[1],e._pos[2],e._id)}}(Sound.prototype.init),Sound.prototype.reset=function(t){return function(){var e=this,n=e._parent;return e._orientation=n._orientation,e._stereo=n._stereo,e._pos=n._pos,e._pannerAttr=n._pannerAttr,e._stereo?n.stereo(e._stereo):e._pos?n.pos(e._pos[0],e._pos[1],e._pos[2],e._id):e._panner&&(e._panner.disconnect(0),e._panner=void 0,n._refreshBuffer(e)),t.call(this)}}(Sound.prototype.reset);var e=function(t,e){"spatial"===(e=e||"spatial")?(t._panner=Howler.ctx.createPanner(),t._panner.coneInnerAngle=t._pannerAttr.coneInnerAngle,t._panner.coneOuterAngle=t._pannerAttr.coneOuterAngle,t._panner.coneOuterGain=t._pannerAttr.coneOuterGain,t._panner.distanceModel=t._pannerAttr.distanceModel,t._panner.maxDistance=t._pannerAttr.maxDistance,t._panner.refDistance=t._pannerAttr.refDistance,t._panner.rolloffFactor=t._pannerAttr.rolloffFactor,t._panner.panningModel=t._pannerAttr.panningModel,typeof t._panner.positionX<"u"?(t._panner.positionX.setValueAtTime(t._pos[0],Howler.ctx.currentTime),t._panner.positionY.setValueAtTime(t._pos[1],Howler.ctx.currentTime),t._panner.positionZ.setValueAtTime(t._pos[2],Howler.ctx.currentTime)):t._panner.setPosition(t._pos[0],t._pos[1],t._pos[2]),typeof t._panner.orientationX<"u"?(t._panner.orientationX.setValueAtTime(t._orientation[0],Howler.ctx.currentTime),t._panner.orientationY.setValueAtTime(t._orientation[1],Howler.ctx.currentTime),t._panner.orientationZ.setValueAtTime(t._orientation[2],Howler.ctx.currentTime)):t._panner.setOrientation(t._orientation[0],t._orientation[1],t._orientation[2])):(t._panner=Howler.ctx.createStereoPanner(),t._panner.pan.setValueAtTime(t._stereo,Howler.ctx.currentTime)),t._panner.connect(t._node),t._paused||t._parent.pause(t._id,!0).play(t._id,!0)}}()})),Kt=Gt(((t,e)=>{e.exports=function(t,e){for(var n=t.split("."),r=e.split("."),i=0;i<3;i++){var a=Number(n[i]),s=Number(r[i]);if(a>s)return 1;if(s>a)return-1;if(!isNaN(a)&&isNaN(s))return 1;if(isNaN(a)&&!isNaN(s))return-1}return 0}}));function Zt(t,e){return Object.setPrototypeOf(t,e),t}function Qt(t){return Array.isArray(t)?t:[t]}var Jt="object"==typeof global&&global&&global.Object===Object&&global,te="object"==typeof self&&self&&self.Object===Object&&self,ee=Jt||te||Function("return this")(),ne=ee.Symbol,re=Object.prototype,ie=re.hasOwnProperty,ae=re.toString,se=ne?ne.toStringTag:void 0;var oe=function(t){var e=ie.call(t,se),n=t[se];try{t[se]=void 0;var r=!0}catch{}var i=ae.call(t);return r&&(e?t[se]=n:delete t[se]),i},le=Object.prototype.toString;var he=function(t){return le.call(t)},de=ne?ne.toStringTag:void 0;var ce=function(t){return null==t?void 0===t?"[object Undefined]":"[object Null]":de&&de in Object(t)?oe(t):he(t)};var ue=function(t){return null!=t&&"object"==typeof t};var pe=function(t){return"symbol"==typeof t||ue(t)&&"[object Symbol]"==ce(t)};var fe=function(t,e){for(var n=-1,r=null==t?0:t.length,i=Array(r);++n<r;)i[n]=e(t[n],n,t);return i},me=Array.isArray,ge=ne?ne.prototype:void 0,ve=ge?ge.toString:void 0;var ye=function t(e){if("string"==typeof e)return e;if(me(e))return fe(e,t)+"";if(pe(e))return ve?ve.call(e):"";var n=e+"";return"0"==n&&1/e==-Infinity?"-0":n};var be=function(t){var e=typeof t;return null!=t&&("object"==e||"function"==e)};var xe=function(t){return t};var we,_e=function(t){if(!be(t))return!1;var e=ce(t);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e},Se=ee["__core-js_shared__"],Ae=(we=/[^.]+$/.exec(Se&&Se.keys&&Se.keys.IE_PROTO||""))?"Symbol(src)_1."+we:"";var Oe=function(t){return!!Ae&&Ae in t},Me=Function.prototype.toString;var Ce=function(t){if(null!=t){try{return Me.call(t)}catch{}try{return t+""}catch{}}return""},Pe=/^\[object .+?Constructor\]$/,De=Function.prototype,Te=Object.prototype,ze=De.toString,Ee=Te.hasOwnProperty,Le=RegExp("^"+ze.call(Ee).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");var Ie=function(t){return!(!be(t)||Oe(t))&&(_e(t)?Le:Pe).test(Ce(t))};var Ne=function(t,e){return null==t?void 0:t[e]};var je=function(t,e){var n=Ne(t,e);return Ie(n)?n:void 0},Be=je(ee,"WeakMap"),Ue=Object.create,ke=function(){function t(){}return function(e){if(!be(e))return{};if(Ue)return Ue(e);t.prototype=e;var n=new t;return t.prototype=void 0,n}}(),Re=ke;var Fe=function(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)};var Ve=function(t,e){var n=-1,r=t.length;for(e||(e=Array(r));++n<r;)e[n]=t[n];return e},Ge=Date.now;var He=function(t){var e=0,n=0;return function(){var r=Ge(),i=16-(r-n);if(n=r,i>0){if(++e>=800)return arguments[0]}else e=0;return t.apply(void 0,arguments)}};var We=function(t){return function(){return t}},qe=function(){try{var t=je(Object,"defineProperty");return t({},"",{}),t}catch{}}(),$e=qe,Xe=$e?function(t,e){return $e(t,"toString",{configurable:!0,enumerable:!1,value:We(e),writable:!0})}:xe,Ye=He(Xe);var Ke=function(t,e){for(var n=-1,r=null==t?0:t.length;++n<r&&!1!==e(t[n],n,t););return t},Ze=/^(?:0|[1-9]\d*)$/;var Qe=function(t,e){var n=typeof t;return!!(e=e??9007199254740991)&&("number"==n||"symbol"!=n&&Ze.test(t))&&t>-1&&t%1==0&&t<e};var Je=function(t,e,n){"__proto__"==e&&$e?$e(t,e,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[e]=n};var tn=function(t,e){return t===e||t!=t&&e!=e},en=Object.prototype.hasOwnProperty;var nn=function(t,e,n){var r=t[e];(!en.call(t,e)||!tn(r,n)||void 0===n&&!(e in t))&&Je(t,e,n)};var rn=function(t,e,n,r){var i=!n;n||(n={});for(var a=-1,s=e.length;++a<s;){var o=e[a],l=r?r(n[o],t[o],o,n,t):void 0;void 0===l&&(l=t[o]),i?Je(n,o,l):nn(n,o,l)}return n},an=Math.max;var sn=function(t,e,n){return e=an(void 0===e?t.length-1:e,0),function(){for(var r=arguments,i=-1,a=an(r.length-e,0),s=Array(a);++i<a;)s[i]=r[e+i];i=-1;for(var o=Array(e+1);++i<e;)o[i]=r[i];return o[e]=n(s),Fe(t,this,o)}};var on=function(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=9007199254740991};var ln=function(t){return null!=t&&on(t.length)&&!_e(t)},hn=Object.prototype;var dn=function(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||hn)};var cn=function(t,e){for(var n=-1,r=Array(t);++n<t;)r[n]=e(n);return r};var un=function(t){return ue(t)&&"[object Arguments]"==ce(t)},pn=Object.prototype,fn=pn.hasOwnProperty,mn=pn.propertyIsEnumerable,gn=un(function(){return arguments}())?un:function(t){return ue(t)&&fn.call(t,"callee")&&!mn.call(t,"callee")},vn=gn;var yn=function(){return!1},bn="object"==typeof exports&&exports&&!exports.nodeType&&exports,xn=bn&&"object"==typeof module&&module&&!module.nodeType&&module,wn=xn&&xn.exports===bn?ee.Buffer:void 0,_n=(wn?wn.isBuffer:void 0)||yn,Sn={};Sn["[object Float32Array]"]=Sn["[object Float64Array]"]=Sn["[object Int8Array]"]=Sn["[object Int16Array]"]=Sn["[object Int32Array]"]=Sn["[object Uint8Array]"]=Sn["[object Uint8ClampedArray]"]=Sn["[object Uint16Array]"]=Sn["[object Uint32Array]"]=!0,Sn["[object Arguments]"]=Sn["[object Array]"]=Sn["[object ArrayBuffer]"]=Sn["[object Boolean]"]=Sn["[object DataView]"]=Sn["[object Date]"]=Sn["[object Error]"]=Sn["[object Function]"]=Sn["[object Map]"]=Sn["[object Number]"]=Sn["[object Object]"]=Sn["[object RegExp]"]=Sn["[object Set]"]=Sn["[object String]"]=Sn["[object WeakMap]"]=!1;var An=function(t){return ue(t)&&on(t.length)&&!!Sn[ce(t)]};var On=function(t){return function(e){return t(e)}},Mn="object"==typeof exports&&exports&&!exports.nodeType&&exports,Cn=Mn&&"object"==typeof module&&module&&!module.nodeType&&module,Pn=Cn&&Cn.exports===Mn&&Jt.process,Dn=function(){try{return Cn&&Cn.require&&Cn.require("util").types||Pn&&Pn.binding&&Pn.binding("util")}catch{}}(),Tn=Dn&&Dn.isTypedArray,zn=Tn?On(Tn):An,En=Object.prototype.hasOwnProperty;var Ln=function(t,e){var n=me(t),r=!n&&vn(t),i=!n&&!r&&_n(t),a=!n&&!r&&!i&&zn(t),s=n||r||i||a,o=s?cn(t.length,String):[],l=o.length;for(var h in t)(e||En.call(t,h))&&(!s||!("length"==h||i&&("offset"==h||"parent"==h)||a&&("buffer"==h||"byteLength"==h||"byteOffset"==h)||Qe(h,l)))&&o.push(h);return o};var In=function(t,e){return function(n){return t(e(n))}},Nn=In(Object.keys,Object),jn=Object.prototype.hasOwnProperty;var Bn=function(t){if(!dn(t))return Nn(t);var e=[];for(var n in Object(t))jn.call(t,n)&&"constructor"!=n&&e.push(n);return e};var Un=function(t){return ln(t)?Ln(t):Bn(t)};var kn=function(t){var e=[];if(null!=t)for(var n in Object(t))e.push(n);return e},Rn=Object.prototype.hasOwnProperty;var Fn=function(t){if(!be(t))return kn(t);var e=dn(t),n=[];for(var r in t)"constructor"==r&&(e||!Rn.call(t,r))||n.push(r);return n};var Vn=function(t){return ln(t)?Ln(t,!0):Fn(t)},Gn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Hn=/^\w*$/;var Wn=function(t,e){if(me(t))return!1;var n=typeof t;return!("number"!=n&&"symbol"!=n&&"boolean"!=n&&null!=t&&!pe(t))||(Hn.test(t)||!Gn.test(t)||null!=e&&t in Object(e))},qn=je(Object,"create");var $n=function(){this.__data__=qn?qn(null):{},this.size=0};var Xn=function(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e},Yn=Object.prototype.hasOwnProperty;var Kn=function(t){var e=this.__data__;if(qn){var n=e[t];return"__lodash_hash_undefined__"===n?void 0:n}return Yn.call(e,t)?e[t]:void 0},Zn=Object.prototype.hasOwnProperty;var Qn=function(t){var e=this.__data__;return qn?void 0!==e[t]:Zn.call(e,t)};var Jn=function(t,e){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=qn&&void 0===e?"__lodash_hash_undefined__":e,this};function tr(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}tr.prototype.clear=$n,tr.prototype.delete=Xn,tr.prototype.get=Kn,tr.prototype.has=Qn,tr.prototype.set=Jn;var er=tr;var nr=function(){this.__data__=[],this.size=0};var rr=function(t,e){for(var n=t.length;n--;)if(tn(t[n][0],e))return n;return-1},ir=Array.prototype.splice;var ar=function(t){var e=this.__data__,n=rr(e,t);return!(n<0)&&(n==e.length-1?e.pop():ir.call(e,n,1),--this.size,!0)};var sr=function(t){var e=this.__data__,n=rr(e,t);return n<0?void 0:e[n][1]};var or=function(t){return rr(this.__data__,t)>-1};var lr=function(t,e){var n=this.__data__,r=rr(n,t);return r<0?(++this.size,n.push([t,e])):n[r][1]=e,this};function hr(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}hr.prototype.clear=nr,hr.prototype.delete=ar,hr.prototype.get=sr,hr.prototype.has=or,hr.prototype.set=lr;var dr=hr,cr=je(ee,"Map");var ur=function(){this.size=0,this.__data__={hash:new er,map:new(cr||dr),string:new er}};var pr=function(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t};var fr=function(t,e){var n=t.__data__;return pr(e)?n["string"==typeof e?"string":"hash"]:n.map};var mr=function(t){var e=fr(this,t).delete(t);return this.size-=e?1:0,e};var gr=function(t){return fr(this,t).get(t)};var vr=function(t){return fr(this,t).has(t)};var yr=function(t,e){var n=fr(this,t),r=n.size;return n.set(t,e),this.size+=n.size==r?0:1,this};function br(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}br.prototype.clear=ur,br.prototype.delete=mr,br.prototype.get=gr,br.prototype.has=vr,br.prototype.set=yr;var xr=br;function wr(t,e){if("function"!=typeof t||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var n=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=n.cache;if(a.has(i))return a.get(i);var s=t.apply(this,r);return n.cache=a.set(i,s)||a,s};return n.cache=new(wr.Cache||xr),n}wr.Cache=xr;var _r=wr;var Sr=function(t){var e=_r(t,(function(t){return 500===n.size&&n.clear(),t})),n=e.cache;return e},Ar=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Or=/\\(\\)?/g,Mr=Sr((function(t){var e=[];return 46===t.charCodeAt(0)&&e.push(""),t.replace(Ar,(function(t,n,r,i){e.push(r?i.replace(Or,"$1"):n||t)})),e})),Cr=Mr;var Pr=function(t){return null==t?"":ye(t)};var Dr=function(t,e){return me(t)?t:Wn(t,e)?[t]:Cr(Pr(t))};var Tr=function(t){if("string"==typeof t||pe(t))return t;var e=t+"";return"0"==e&&1/t==-Infinity?"-0":e};var zr=function(t,e){for(var n=0,r=(e=Dr(e,t)).length;null!=t&&n<r;)t=t[Tr(e[n++])];return n&&n==r?t:void 0};var Er=function(t,e){for(var n=-1,r=e.length,i=t.length;++n<r;)t[i+n]=e[n];return t},Lr=ne?ne.isConcatSpreadable:void 0;var Ir=function(t){return me(t)||vn(t)||!!(Lr&&t&&t[Lr])};var Nr=function t(e,n,r,i,a){var s=-1,o=e.length;for(r||(r=Ir),a||(a=[]);++s<o;){var l=e[s];n>0&&r(l)?n>1?t(l,n-1,r,i,a):Er(a,l):i||(a[a.length]=l)}return a};var jr=function(t){return(null==t?0:t.length)?Nr(t,1):[]};var Br=function(t){return Ye(sn(t,void 0,jr),t+"")},Ur=In(Object.getPrototypeOf,Object),kr=Function.prototype,Rr=Object.prototype,Fr=kr.toString,Vr=Rr.hasOwnProperty,Gr=Fr.call(Object);var Hr=function(t){if(!ue(t)||"[object Object]"!=ce(t))return!1;var e=Ur(t);if(null===e)return!0;var n=Vr.call(e,"constructor")&&e.constructor;return"function"==typeof n&&n instanceof n&&Fr.call(n)==Gr};var Wr=function(t,e,n){var r=-1,i=t.length;e<0&&(e=-e>i?0:i+e),(n=n>i?i:n)<0&&(n+=i),i=e>n?0:n-e>>>0,e>>>=0;for(var a=Array(i);++r<i;)a[r]=t[r+e];return a};var qr=function(){this.__data__=new dr,this.size=0};var $r=function(t){var e=this.__data__,n=e.delete(t);return this.size=e.size,n};var Xr=function(t){return this.__data__.get(t)};var Yr=function(t){return this.__data__.has(t)};var Kr=function(t,e){var n=this.__data__;if(n instanceof dr){var r=n.__data__;if(!cr||r.length<199)return r.push([t,e]),this.size=++n.size,this;n=this.__data__=new xr(r)}return n.set(t,e),this.size=n.size,this};function Zr(t){var e=this.__data__=new dr(t);this.size=e.size}Zr.prototype.clear=qr,Zr.prototype.delete=$r,Zr.prototype.get=Xr,Zr.prototype.has=Yr,Zr.prototype.set=Kr;var Qr=Zr;var Jr=function(t,e){return t&&rn(e,Un(e),t)};var ti=function(t,e){return t&&rn(e,Vn(e),t)},ei="object"==typeof exports&&exports&&!exports.nodeType&&exports,ni=ei&&"object"==typeof module&&module&&!module.nodeType&&module,ri=ni&&ni.exports===ei?ee.Buffer:void 0,ii=ri?ri.allocUnsafe:void 0;var ai=function(t,e){if(e)return t.slice();var n=t.length,r=ii?ii(n):new t.constructor(n);return t.copy(r),r};var si=function(t,e){for(var n=-1,r=null==t?0:t.length,i=0,a=[];++n<r;){var s=t[n];e(s,n,t)&&(a[i++]=s)}return a};var oi=function(){return[]},li=Object.prototype.propertyIsEnumerable,hi=Object.getOwnPropertySymbols,di=hi?function(t){return null==t?[]:(t=Object(t),si(hi(t),(function(e){return li.call(t,e)})))}:oi,ci=di;var ui=function(t,e){return rn(t,ci(t),e)},pi=Object.getOwnPropertySymbols?function(t){for(var e=[];t;)Er(e,ci(t)),t=Ur(t);return e}:oi,fi=pi;var mi=function(t,e){return rn(t,fi(t),e)};var gi=function(t,e,n){var r=e(t);return me(t)?r:Er(r,n(t))};var vi=function(t){return gi(t,Un,ci)};var yi=function(t){return gi(t,Vn,fi)},bi=je(ee,"DataView"),xi=je(ee,"Promise"),wi=je(ee,"Set"),_i="[object Map]",Si="[object Promise]",Ai="[object Set]",Oi="[object WeakMap]",Mi="[object DataView]",Ci=Ce(bi),Pi=Ce(cr),Di=Ce(xi),Ti=Ce(wi),zi=Ce(Be),Ei=ce;(bi&&Ei(new bi(new ArrayBuffer(1)))!=Mi||cr&&Ei(new cr)!=_i||xi&&Ei(xi.resolve())!=Si||wi&&Ei(new wi)!=Ai||Be&&Ei(new Be)!=Oi)&&(Ei=function(t){var e=ce(t),n="[object Object]"==e?t.constructor:void 0,r=n?Ce(n):"";if(r)switch(r){case Ci:return Mi;case Pi:return _i;case Di:return Si;case Ti:return Ai;case zi:return Oi}return e});var Li=Ei,Ii=Object.prototype.hasOwnProperty;var Ni=function(t){var e=t.length,n=new t.constructor(e);return e&&"string"==typeof t[0]&&Ii.call(t,"index")&&(n.index=t.index,n.input=t.input),n},ji=ee.Uint8Array;var Bi=function(t){var e=new t.constructor(t.byteLength);return new ji(e).set(new ji(t)),e};var Ui=function(t,e){var n=e?Bi(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.byteLength)},ki=/\w*$/;var Ri=function(t){var e=new t.constructor(t.source,ki.exec(t));return e.lastIndex=t.lastIndex,e},Fi=ne?ne.prototype:void 0,Vi=Fi?Fi.valueOf:void 0;var Gi=function(t){return Vi?Object(Vi.call(t)):{}};var Hi=function(t,e){var n=e?Bi(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.length)};var Wi=function(t,e,n){var r=t.constructor;switch(e){case"[object ArrayBuffer]":return Bi(t);case"[object Boolean]":case"[object Date]":return new r(+t);case"[object DataView]":return Ui(t,n);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":case"[object Uint16Array]":case"[object Uint32Array]":return Hi(t,n);case"[object Map]":case"[object Set]":return new r;case"[object Number]":case"[object String]":return new r(t);case"[object RegExp]":return Ri(t);case"[object Symbol]":return Gi(t)}};var qi=function(t){return"function"!=typeof t.constructor||dn(t)?{}:Re(Ur(t))};var $i=function(t){return ue(t)&&"[object Map]"==Li(t)},Xi=Dn&&Dn.isMap,Yi=Xi?On(Xi):$i;var Ki=function(t){return ue(t)&&"[object Set]"==Li(t)},Zi=Dn&&Dn.isSet,Qi=Zi?On(Zi):Ki,Ji="[object Arguments]",ta="[object Function]",ea="[object Object]",na={};na[Ji]=na["[object Array]"]=na["[object ArrayBuffer]"]=na["[object DataView]"]=na["[object Boolean]"]=na["[object Date]"]=na["[object Float32Array]"]=na["[object Float64Array]"]=na["[object Int8Array]"]=na["[object Int16Array]"]=na["[object Int32Array]"]=na["[object Map]"]=na["[object Number]"]=na[ea]=na["[object RegExp]"]=na["[object Set]"]=na["[object String]"]=na["[object Symbol]"]=na["[object Uint8Array]"]=na["[object Uint8ClampedArray]"]=na["[object Uint16Array]"]=na["[object Uint32Array]"]=!0,na["[object Error]"]=na[ta]=na["[object WeakMap]"]=!1;var ra=function t(e,n,r,i,a,s){var o,l=1&n,h=2&n,d=4&n;if(r&&(o=a?r(e,i,a,s):r(e)),void 0!==o)return o;if(!be(e))return e;var c=me(e);if(c){if(o=Ni(e),!l)return Ve(e,o)}else{var u=Li(e),p=u==ta||"[object GeneratorFunction]"==u;if(_n(e))return ai(e,l);if(u==ea||u==Ji||p&&!a){if(o=h||p?{}:qi(e),!l)return h?mi(e,ti(o,e)):ui(e,Jr(o,e))}else{if(!na[u])return a?e:{};o=Wi(e,u,l)}}s||(s=new Qr);var f=s.get(e);if(f)return f;s.set(e,o),Qi(e)?e.forEach((function(i){o.add(t(i,n,r,i,e,s))})):Yi(e)&&e.forEach((function(i,a){o.set(a,t(i,n,r,a,e,s))}));var m=c?void 0:(d?h?yi:vi:h?Vn:Un)(e);return Ke(m||e,(function(i,a){m&&(i=e[a=i]),nn(o,a,t(i,n,r,a,e,s))})),o};var ia=function(t){return ra(t,5)};var aa=function(t){return this.__data__.set(t,"__lodash_hash_undefined__"),this};var sa=function(t){return this.__data__.has(t)};function oa(t){var e=-1,n=null==t?0:t.length;for(this.__data__=new xr;++e<n;)this.add(t[e])}oa.prototype.add=oa.prototype.push=aa,oa.prototype.has=sa;var la=oa;var ha=function(t,e){for(var n=-1,r=null==t?0:t.length;++n<r;)if(e(t[n],n,t))return!0;return!1};var da=function(t,e){return t.has(e)};var ca=function(t,e,n,r,i,a){var s=1&n,o=t.length,l=e.length;if(o!=l&&!(s&&l>o))return!1;var h=a.get(t),d=a.get(e);if(h&&d)return h==e&&d==t;var c=-1,u=!0,p=2&n?new la:void 0;for(a.set(t,e),a.set(e,t);++c<o;){var f=t[c],m=e[c];if(r)var g=s?r(m,f,c,e,t,a):r(f,m,c,t,e,a);if(void 0!==g){if(g)continue;u=!1;break}if(p){if(!ha(e,(function(t,e){if(!da(p,e)&&(f===t||i(f,t,n,r,a)))return p.push(e)}))){u=!1;break}}else if(f!==m&&!i(f,m,n,r,a)){u=!1;break}}return a.delete(t),a.delete(e),u};var ua=function(t){var e=-1,n=Array(t.size);return t.forEach((function(t,r){n[++e]=[r,t]})),n};var pa=function(t){var e=-1,n=Array(t.size);return t.forEach((function(t){n[++e]=t})),n},fa=ne?ne.prototype:void 0,ma=fa?fa.valueOf:void 0;var ga=function(t,e,n,r,i,a,s){switch(n){case"[object DataView]":if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(t.byteLength!=e.byteLength||!a(new ji(t),new ji(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return tn(+t,+e);case"[object Error]":return t.name==e.name&&t.message==e.message;case"[object RegExp]":case"[object String]":return t==e+"";case"[object Map]":var o=ua;case"[object Set]":var l=1&r;if(o||(o=pa),t.size!=e.size&&!l)return!1;var h=s.get(t);if(h)return h==e;r|=2,s.set(t,e);var d=ca(o(t),o(e),r,i,a,s);return s.delete(t),d;case"[object Symbol]":if(ma)return ma.call(t)==ma.call(e)}return!1},va=Object.prototype.hasOwnProperty;var ya=function(t,e,n,r,i,a){var s=1&n,o=vi(t),l=o.length;if(l!=vi(e).length&&!s)return!1;for(var h=l;h--;){var d=o[h];if(!(s?d in e:va.call(e,d)))return!1}var c=a.get(t),u=a.get(e);if(c&&u)return c==e&&u==t;var p=!0;a.set(t,e),a.set(e,t);for(var f=s;++h<l;){var m=t[d=o[h]],g=e[d];if(r)var v=s?r(g,m,d,e,t,a):r(m,g,d,t,e,a);if(!(void 0===v?m===g||i(m,g,n,r,a):v)){p=!1;break}f||(f="constructor"==d)}if(p&&!f){var y=t.constructor,b=e.constructor;y!=b&&"constructor"in t&&"constructor"in e&&!("function"==typeof y&&y instanceof y&&"function"==typeof b&&b instanceof b)&&(p=!1)}return a.delete(t),a.delete(e),p},ba="[object Arguments]",xa="[object Array]",wa="[object Object]",_a=Object.prototype.hasOwnProperty;var Sa=function(t,e,n,r,i,a){var s=me(t),o=me(e),l=s?xa:Li(t),h=o?xa:Li(e),d=(l=l==ba?wa:l)==wa,c=(h=h==ba?wa:h)==wa,u=l==h;if(u&&_n(t)){if(!_n(e))return!1;s=!0,d=!1}if(u&&!d)return a||(a=new Qr),s||zn(t)?ca(t,e,n,r,i,a):ga(t,e,l,n,r,i,a);if(!(1&n)){var p=d&&_a.call(t,"__wrapped__"),f=c&&_a.call(e,"__wrapped__");if(p||f){var m=p?t.value():t,g=f?e.value():e;return a||(a=new Qr),i(m,g,n,r,a)}}return!!u&&(a||(a=new Qr),ya(t,e,n,r,i,a))};var Aa=function t(e,n,r,i,a){return e===n||(null==e||null==n||!ue(e)&&!ue(n)?e!=e&&n!=n:Sa(e,n,r,i,t,a))};var Oa=function(t,e){return null!=t&&e in Object(t)};var Ma=function(t,e,n){for(var r=-1,i=(e=Dr(e,t)).length,a=!1;++r<i;){var s=Tr(e[r]);if(!(a=null!=t&&n(t,s)))break;t=t[s]}return a||++r!=i?a:!!(i=null==t?0:t.length)&&on(i)&&Qe(s,i)&&(me(t)||vn(t))};var Ca=function(t,e){return null!=t&&Ma(t,e,Oa)};var Pa=function(t){var e=null==t?0:t.length;return e?t[e-1]:void 0};var Da=function(t,e){return e.length<2?t:zr(t,Wr(e,0,-1))};var Ta=function(t,e){return Aa(t,e)};var za=function(t,e){return e=Dr(e,t),null==(t=Da(t,e))||delete t[Tr(Pa(e))]};var Ea=function(t){return Hr(t)?void 0:t},La=Br((function(t,e){var n={};if(null==t)return n;var r=!1;e=fe(e,(function(e){return e=Dr(e,t),r||(r=e.length>1),e})),rn(t,yi(t),n),r&&(n=ra(n,7,Ea));for(var i=e.length;i--;)za(n,e[i]);return n})),Ia=La;var Na=function(t,e,n,r){if(!be(t))return t;for(var i=-1,a=(e=Dr(e,t)).length,s=a-1,o=t;null!=o&&++i<a;){var l=Tr(e[i]),h=n;if("__proto__"===l||"constructor"===l||"prototype"===l)return t;if(i!=s){var d=o[l];void 0===(h=r?r(d,l,o):void 0)&&(h=be(d)?d:Qe(e[i+1])?[]:{})}nn(o,l,h),o=o[l]}return t};var ja=function(t,e,n){for(var r=-1,i=e.length,a={};++r<i;){var s=e[r],o=zr(t,s);n(o,s)&&Na(a,Dr(s,t),o)}return a};var Ba=function(t,e){return ja(t,e,(function(e,n){return Ca(t,n)}))},Ua=Br((function(t,e){return null==t?{}:Ba(t,e)})),ka=Ua,Ra=class{modifyById(t,e){let n=this;if(void 0===n[t])throw new Error("not expected");{let r={...n,[t]:e};return Object.setPrototypeOf(r,Ra.prototype),r}}add(t,e){var n;return(null==(n=this.runOp({type:1,id:t,data:e}))?void 0:n.data)??this}runOp(t){let e=this;if(1===t.type){let n,r=e[t.id];n=void 0===r?{type:2,id:t.id}:{type:1,id:t.id,data:r};let{id:i,data:a}=t,s={...e,[i]:a};return Object.setPrototypeOf(s,Ra.prototype),{data:s,actual:t,reverse:n}}if(2===t.type){let{id:n}=t,r=e[n];if(void 0===r)return null;{let i={...e};return Object.setPrototypeOf(i,Ra.prototype),delete i[n],{data:i,actual:t,reverse:{type:1,id:n,data:r}}}}return null}};function Fa(t){if(void 0!==t.deepFreeze)return void t.deepFreeze(t);let e=Object.getOwnPropertyNames(t);for(let n of e){let e=t[n];e&&"object"==typeof e&&Fa(e)}return Object.freeze(t)}var Va=class extends Error{};function Ga(t){let e={...t};return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),e}function Ha(t,e,n){if(void 0===t?void 0===e?(t=0,e=10):t=e-10:void 0===e&&(e=t+10),t>e){let n=t;t=e,e=n}let r=[],i=1/(n+1);for(let a=0;a<n;a++){let n=t+(e-t)*(a+.75+.5*Math.random())*i;r.push(n)}return r}function Wa(t){return t instanceof Uint8Array||t instanceof Uint16Array||t instanceof Uint32Array||t instanceof Int8Array||t instanceof Int16Array||t instanceof Int32Array||t instanceof Float32Array||t instanceof Float64Array}function qa(t,e){for(let n of t)!0!==e(n.id,n.data)&&qa(n.children,e)}function $a(t,e){if(!0!==e(t.id,t.data))for(let n of t.children)$a(n,e)}var Xa,Ya=class extends Array{constructor(...t){super(...t),Object.setPrototypeOf(this,Ya.prototype)}deepFreeze(){let t=0;for(;t<this.length;)Fa(this[t]),t++}fillCaches0(t,e){this.objCaches.set(t.id,t),this.parentCaches.set(t.id,e);for(let n of t.children)this.fillCaches0(n,t.id)}fillCaches(){if(void 0===this.objCaches){this.objCaches=new Map,this.parentCaches=new Map;for(let t of this)this.fillCaches0(t,null)}}randomId(){this.fillCaches();let t=Array.from(this.objCaches.keys());if(0!==t.length)return t[Math.max(0,Math.floor(Math.random()*t.length)-1)]}nonExistOrDescendantOf(t,e){if(!this.has(t))return!0;for(;t;){let n=this.parent(t);if(n===e)return!0;t=n}return!1}rootAcestor(t){for(;t;){let e=this.parent(t);if(!e)return t;t=e}return t}isDescendantOf(t,e){for(;t;){let n=this.parent(t);if(n===e)return!0;t=n}return!1}data(t){var e;return null==(e=this.get(t))?void 0:e.data}has(t){return void 0!==this.childrenOf(t)}get(t){return this.fillCaches(),this.objCaches.get(t)}childrenOf(t){var e;return null===t?this:null==(e=this.get(t))?void 0:e.children}traverseFrom(t,e){if(null===t)this.traverse(e);else{let n=this.get(t);n&&$a(n,e)}}traverse(t){qa(this,t)}totalSize(){return this.fillCaches(),this.objCaches.size}parent(t){return this.fillCaches(),this.parentCaches.get(t)}childrenArray(t){return null===t?this:this.get(t).children}modifyById(t,e){if(void 0===this.get(t))throw new Error("not expected");{let n=this.parent(t),r=this.childrenArray(n),i=r.findIndex((e=>e.id===t));if(i<0)throw new Error("not expected");let a=r[i];return r=[...r],r[i]={...a,data:e},this.modifyArrayBy(n,r)}}modifyArrayBy(t,e){let n=t,r=e;for(;null!==n;){let t=r,e=n;if(n=this.parent(n),void 0===n)throw new Error;r=this.childrenArray(n);let i=r.findIndex((t=>t.id===e));if(i<0)throw new Error;r=[...r],r[i]={...r[i],children:t}}Object.setPrototypeOf(r,Ya.prototype);let i=r;return i.fillCaches(),i}runOp(t){switch(t.type){case 7:return this.addOp(t);case 8:return this.deleteOp(t);case 9:return this.moveOp(t)}return null}checkDuplicatedIdRec({id:t,children:e}){if(void 0!==this.get(t))return!0;for(let n of e)if(this.checkDuplicatedIdRec(n))return!0;return!1}addOp(t){let{parent:e,fi:n,id:r,data:i,children:a}=t;if(null!==e&&void 0===this.get(e))return null;if(this.checkDuplicatedIdRec(t))return null;{let s=e,o=this.childrenArray(s),l={fi:n,id:r,data:i,children:a};return o=[...o,l],o.sort(((t,e)=>t.fi-e.fi)),t.localIndex=o.indexOf(l),{data:this.modifyArrayBy(s,o),actual:t,reverse:{type:8,id:r}}}}deleteOp(t){let{id:e}=t;if(null===this.get(e))return null;{let n=this.parent(e);if(void 0===n)return null;let r=this.childrenArray(n),i=r.findIndex((t=>t.id===e));t.localIndex=i,r=[...r];let a=r.splice(i,1)[0];return{data:this.modifyArrayBy(n,r),actual:t,reverse:{type:7,...a,parent:n}}}}moveOp(t){let{parent:e,fi:n,id:r}=t;if(null!==e&&void 0===this.get(e))return this.deleteOp({type:8,id:r});if(null!==e){let t=e;for(;null!==t;){if(void 0===t)throw new Error;if(t===r)throw new Va("cyclic tree");t=this.parent(t)}}let i=this.parent(r);if(void 0===i)return null;let a=i,s=this.childrenArray(i),o=s.findIndex((t=>t.id===r));s=[...s];let l=s.splice(o,1)[0],h=this.modifyArrayBy(i,s);i=e,s=h.childrenArray(i);let d=l.fi;return l={...l,fi:n},s=[...s,l],s.sort(((t,e)=>t.fi-e.fi)),t.localIndex=s.indexOf(l),h=h.modifyArrayBy(i,s),{data:h,actual:t,reverse:{type:9,parent:a,fi:d,id:r}}}previous(t,e){if(null===e){let e=this.childrenArray(t);return 0===e.length?null:e[e.length-1].id}let n=null;for(let r of this.childrenArray(t)){if(r.id===e)return n;n=r.id}return null}traverseSortNext(t){let e=this.parent(t);if(void 0!==e){let n=this.childrenArray(e),r=n.findIndex((e=>e.id===t))+1;if(r<n.length)return n[r].id;if(e)return this.traverseSortNext(e)}}sortNext(t){let e=this.childrenArray(t);return e.length>0?e[0].id:this.traverseSortNext(t)}traverseSortPrevious(t){let e=this.childrenArray(t);return e.length>0?this.traverseSortPrevious(e[e.length-1].id):t}sortPrevious(t){let e=this.parent(t);if(void 0!==e){let n=this.childrenArray(e),r=n.findIndex((e=>e.id===t))-1;return r>=0?this.traverseSortPrevious(n[r].id):e}}getAllSorted(t){let e=[];for(let n of t){let t=this.getWithSortKey(n.id);void 0!==t&&e.push({...n,...t})}e.sort(((t,e)=>function(t,e){let n=0;for(;n<t.length&&n<e.length;){if(t[n]<e[n])return-1;if(t[n]>e[n])return 1;n+=1}return n!==e.length?-1:n!==t.length?1:0}(t.sortKey,e.sortKey)));for(let n of e)delete n.sortKey;return e}getWithSortKey(t){var e=t;let n=[],r=this.get(e),i=r;if(void 0!==r){for(;e;)n.splice(0,0,r.fi),null!==(e=this.parent(e))&&(r=this.get(e));return{...i,sortKey:n}}}insertBeforeHelper(t,e,n){return this.insertAfterHelper(t,this.previous(t,e),n)}insertAfterHelper(t,e,n){let r=this.childrenArray(t);if(null===e){if(0===r.length)return Ha(0,n,n);{let t=r[0].fi;return Ha(t-n,t,n)}}{let i=this.get(e);if(void 0===i||this.parent(e)!==t)throw new Error("illegal args");let a=r.find((t=>t.fi>i.fi));if(void 0===a){let t=r[r.length-1].fi;return Ha(t,t+n,n)}return Ha(i.fi,a.fi,n)}}};(Xa||(Xa={})).runOp=function(t,e){if(0!==e.type)return null;if(Array.isArray(t)){let n=e.props,r={},i=[...t],a=!1;if(n)for(let t of Object.keys(n)){let e=parseInt(t);if(isNaN(e))throw new Error("wrong index");r[t]=i[e],i[e]=n[t],a=!0}return a?{data:i,actual:e,reverse:{type:0,props:r}}:null}{let n=e.props,r={},i={...t},a=!1;if(n)for(let t of Object.keys(n)){r[t]=i[t];let e=n[t];void 0===e?delete i[t]:i[t]=e,a=!0}return a?{data:i,actual:e,reverse:{type:0,props:r}}:null}};var Ka=class extends Array{constructor(...t){super(...t),Object.setPrototypeOf(this,Ka.prototype)}deepFreeze(){let t=0;for(;t<this.length;)Fa(this[t]),t++}fillCaches0(t){this.objCaches.set(t.id,t)}fillCaches(){if(void 0===this.objCaches){this.objCaches=new Map,Object.getOwnPropertyDescriptor(this,"objCaches").enumerable=!1;for(let t of this)this.fillCaches0(t)}}randomId(){this.fillCaches();let t=Array.from(this.objCaches.keys());if(0!==t.length)return t[Math.max(0,Math.floor(Math.random()*t.length)-1)]}data(t){var e;return null==(e=this.get(t))?void 0:e.data}get(t){return this.fillCaches(),this.objCaches.get(t)}modifyById(t,e){if(void 0===this.get(t))throw new Error("not expected");{let n=this,r=n.findIndex((e=>e.id===t));if(r<0)throw new Error("not expected");let i=n[r];return n=[...n],n[r]={...i,data:e},this.modifyArrayBy(n)}}modifyArrayBy(t){Object.setPrototypeOf(t,Ka.prototype);let e=t;return typeof process<"u"||e.fillCaches(),e}runOp(t){switch(t.type){case 4:return this.addOp(t);case 5:return this.deleteOp(t);case 6:return this.moveOp(t)}return null}addOp(t){let{fi:e,id:n,data:r}=t,i=this,a={fi:e,id:n,data:r};return i=[...i,a],i.sort(((t,e)=>t.fi-e.fi)),t.localIndex=i.indexOf(a),{data:this.modifyArrayBy(i),actual:t,reverse:{type:5,id:n}}}deleteOp(t){let{id:e}=t,n=this,r=n.findIndex((t=>t.id===e));if(-1===r)return null;t.localIndex=r,n=[...n];let i=n.splice(r,1)[0];return{data:this.modifyArrayBy(n),actual:t,reverse:{type:4,...i}}}moveOp(t){let{fi:e,id:n}=t,r=this;r=[...r];let i=r.findIndex((t=>t.id===n));if(-1===i)return null;let a=r[i].fi,s={...r[i],fi:e};return r[i]=s,r.sort(((t,e)=>t.fi-e.fi)),t.localIndex=r.indexOf(s),{data:this.modifyArrayBy(r),actual:t,reverse:{type:6,fi:a,id:n}}}previous(t){if(null===t)return 0===this.length?null:this[this.length-1].id;let e=null;for(let n of this){if(n.id===t)return e;e=n.id}return null}insertBeforeHelper(t,e){return this.insertAfterHelper(this.previous(t),e)}insertAfterHelper(t,e){let n=this;if(null===t){if(0===n.length)return Ha(0,e,e);{let t=n[0].fi;return Ha(t-e,t,e)}}{let r=this.get(t);if(void 0===r)throw new Error("illegal args");let i=n.find((t=>t.fi>r.fi));if(void 0===i){let t=n[n.length-1].fi;return Ha(t,t+e,e)}return Ha(r.fi,i.fi,e)}}};function Za(t){return t&&"object"==typeof t&&t instanceof rs}var Qa,Ja,ts,es,ns,rs=class{unusedFunOverridesTable(t){}runOp(t){let e=[],n=this,r=0,i={};for(;r<t.path.length;){if(e.push(n),n=void 0===n?void 0:n[t.path[r]],void 0!==n&&!Za(n))return null;r+=1}n=n?Ga(n):new rs;for(let[a,s]of Object.entries(t.props)){let t=n[a];i[a]=t,void 0===s?delete n[a]:n[a]=s}for(;r>0;){if(0===Object.keys(n).length){let i=e[r-1];i&&(n=Ga(i),delete n[t.path[r-1]])}else{let i=e[r-1];if(i){let e=Ga(i);e[t.path[r-1]]=n,n=e}else{let e=new rs;e[t.path[r-1]]=n,n=e}}r-=1}return{data:Object.setPrototypeOf(n,rs.prototype),actual:t,reverse:{...t,props:i}}}};function is(t,e){if(void 0===e)return;let n=!1,r=t.map((t=>{let r=t.id,i=as(t.data,e[r]);if(n=n||void 0!==i,void 0===i&&(i=t.data),t.children){let a=is(t.children,e);return void 0!==a?n=!0:a=t.children,{...t,id:r,data:i,children:a}}return{...t,id:r,data:i}}));return n?r:void 0}function as(t,e){if(!Za(e))return e;if(t instanceof Ya){let n=is(t,e);return void 0!==n&&Object.setPrototypeOf(n,Object.getPrototypeOf(t)),n}if(t instanceof Ka)return function(t,e){if(void 0===e)return;let n=!1,r=t.map((t=>{let r=t.id,i=as(t.data,e[r]);return n=n||void 0!==i,void 0===i&&(i=t.data),{...t,id:r,data:i}}));return n?(Object.setPrototypeOf(r,Object.getPrototypeOf(t)),r):void 0}(t,e);if(Array.isArray(t)){let n=!1,r=t.map(((t,r)=>{let i=as(t,e[r]);return n=n||void 0!==i,void 0===i&&(i=t),i}));return n?(Object.setPrototypeOf(r,Object.getPrototypeOf(t)),r):void 0}if(t instanceof rs)return ss(t,e);if(t&&"object"==typeof t){let n={},r=!1;for(let[i,a]of Object.entries(t)){let t=as(a,e[i]);r=r||void 0!==t,void 0===t&&(t=a),n[i]=t}return r?(Object.setPrototypeOf(n,Object.getPrototypeOf(t)),n):void 0}}function ss(t,e){if(void 0===t)return e;if(void 0===e)return t;if(!Za(e))return e;if(!Za(t))return Qa.apply(t,e);let n=new Set;for(let i of Object.keys(t))n.add(i);for(let i of Object.keys(e))n.add(i);let r=new rs;for(let i of n){let n=ss(void 0===t?void 0:t[i],void 0===e?void 0:e[i]);r[i]=n}return r}function os(t,e){let n={cur:[],result:[],len:0};return[t=cs(t,e,n)??t,n.result]}function ls(t,e){return null===t?null:(t.cur[t.len]=e,t.len+=1,t)}function hs(t){t&&(t.len-=1)}function ds(t,e,n){let r=!1,i=t.map((t=>{let i=t.id,a=e[i];if(void 0!==a&&"string"==typeof a&&(r=!0,i=a,null!==n))throw new Error("not supported");let s=cs(t.data,e,ls(n,i));hs(n),r=r||void 0!==s,void 0===s&&(s=t.data);let o=ds(t.children,e,n);return void 0!==o?r=!0:o=t.children,{...t,id:i,data:s,children:o}}));if(r)return i}function cs(t,e,n){if(t instanceof Ya){let r=ds(t,e,n);return void 0!==r&&Object.setPrototypeOf(r,Object.getPrototypeOf(t)),r}if(t instanceof Ka)return function(t,e,n){let r=!1,i=t.map((t=>{let i=t.id,a=e[i];if(void 0!==a&&"string"==typeof a&&(r=!0,i=a,null!==n))throw new Error("not supported");let s=cs(t.data,e,ls(n,i));return hs(n),r=r||void 0!==s,void 0===s&&(s=t.data),{...t,id:i,data:s}}));if(r)return Object.setPrototypeOf(i,Object.getPrototypeOf(t)),i}(t,e,n);if(Array.isArray(t)){let r=!1,i=t.map(((t,i)=>{let a=cs(t,e,ls(n,i));return hs(n),r=r||void 0!==a,void 0===a&&(a=t),a}));return r?(Object.setPrototypeOf(i,Object.getPrototypeOf(t)),i):void 0}if(t&&"object"==typeof t&&!Wa(t)){let r={},i=!1;for(let[a,s]of Object.entries(t))if("name"!==a){let t=e[a];if("string"==typeof t){if(null!==n)throw new Error("not supported");i=!0,a=t}let o=cs(s,e,ls(n,a));hs(n),i=i||void 0!==o,void 0===o&&(o=s),r[a]=o}else r[a]=s;return i?(Object.setPrototypeOf(r,Object.getPrototypeOf(t)),r):void 0}if("string"==typeof t){let r=e[t];return void 0!==r&&function(t){if(null===t)return null;t.result.push(t.cur.slice(0,t.len))}(n),r}}(Ja=Qa||(Qa={})).apply=function(t,e){return as(t,e)??t},Ja.merge=function(t,e){return ss(t,e)},Ja.filterOp=function(t,e){let n=0,r=e.path,i=t;for(;n<r.length&&void 0!==i;){if(i=As.zoomOnce(i,r[n]),void 0===i)return e;if(!Za(i))return;n+=1}if(void 0===i)return e;if(Za(i)){if(0===e.type){let t={...e.props};for(let e of Object.keys(i))delete t[e];return{...e,props:t}}if(1===e.type||4===e.type||7===e.type){let t=is([e],i);return t?(console.log(t),t):e}return e}},(ts||(ts={})).replaceProps=function(t,e){let n=As.zoom(e,t.path);if("object"==typeof n){let e={};for(let r of Object.keys(t.props))e[r]=n[r];return{...t,props:e}}return{...t,props:{}}},(t=>{function e(t,e){var n,r;let i=e.path;for(var a=[];;){let s;if(t instanceof rs&&0===e.type&&(s=t.runOp({...e,path:i.slice(a.length)}),null===s&&(s=void 0)),void 0===s&&a.length===i.length&&(s=t instanceof Ya||t instanceof Ka||t instanceof Ra?t.runOp(e):Xa.runOp(t,e)),void 0!==s){if(null!==s){let t=s.data;for(let e=a.length-1;e>=0;e--){let n=i[e],r=a[e];if(r instanceof Ya){if("number"==typeof n)throw new Error("illegal arg");t=r.modifyById(n,t)}else if(r instanceof Ka){if("number"==typeof n)throw new Error("illegal arg");t=r.modifyById(n,t)}else if(r instanceof Ra){if("number"==typeof n)throw new Error("illegal arg");t=r.modifyById(n,t)}else if(r instanceof rs){let e={...r,[n]:t};t=Object.setPrototypeOf(e,rs.prototype)}else{if("object"!=typeof r)return null;if(Array.isArray(r)){if("string"==typeof n&&(n=parseInt(n),isNaN(n)))throw new Error("Invalid path");let e=t;t=[...r],t[n]=e}else t={...r,[n]:t}}}return{data:t,actual:{...s.actual,path:i},reverse:{...s.reverse,path:i}}}return null}let o,l=i[a.length];if(t instanceof Ya){if("number"==typeof l)throw new Error("");o=null==(n=t.get(l))?void 0:n.data}else if(t instanceof Ka){if("number"==typeof l)throw new Error("");o=null==(r=t.get(l))?void 0:r.data}else null!==t&&(o=t[l]);if(void 0===o)return null;a.push(t),t=o}}function n(t,e){for(let n=0;n<t.length&&n<e.length;n++)if(t[n]!==e[n])return!0;return!1}function r(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}t.drop=function(t,e){return{...t,path:t.path.slice(e)}},t.applySimple=function(t,n){var r;return(null==(r=e(t,n))?void 0:r.data)??t},t.apply=e,t.pathDisjoint=n,t.pathEq=r,t.commutative=function(t,e){return n(t.path,e.path)},t.subsumed=function(t,e){return!(0!==t.type||0!==e.type||!r(t.path,e.path))&&Object.keys(t.props).every((t=>void 0!==e.props[t]))}})(es||(es={})),(t=>{function e(t,e){var n=t;let r=[],i=[];for(let s of e)try{if(3===s.type||5===s.type&&"variables"===s.path[s.path.length-1]){let t,e,a;if(3===s.type?(t=As.zoom(n,[...s.path,s.id]),a=es.apply(n,{...s,type:2})):(t=As.zoom(n,[...s.path,s.id,"value"]),a=es.apply(n,s)),null!==a){n=a.data;let[o,l]=os(n,{[s.id]:t});n=o;for(let a=0;a<l.length;a++){let o=l[a],h=o.pop();if("number"==typeof h){let r=[h];for(let t=a+1;t<l.length;t++){let e=l[t],n=e[e.length-1];if("number"!=typeof n||!As.equal(o,e.slice(0,e.length-1)))break;r.push(n),l.splice(t,1)}let i=As.zoom(n,o);e=i.map(((t,e)=>r.includes(e)?s.id:t)),t=i,h=o.pop()}else e=s.id;r.push({type:0,path:o,props:{[h]:t}}),i.push({type:0,path:o,props:{[h]:e}})}i.push(a.reverse),r.push(a.actual)}}else{let t=es.apply(n,s);null!==t&&(r.push(t.actual),n=t.data,i.push(t.reverse))}}catch(a){if(a instanceof Va)return null;throw a}return{data:n,actual:r,reverse:i.reverse()}}t.empty=function(){return[]},t.removePrefix=function(t,e){let n=[];for(let r of t){let[t,...i]=r.path;t===e&&n.push({...r,path:i})}return n},t.addPrefix=function(t,e){return t.map((t=>({...t,path:[e,...t.path]})))},t.concat=function(t,e){return[...t,...e]},t.compress=function(t,e){return[...t.filter((t=>!e.some((e=>es.subsumed(t,e))))),...e]},t.commutative=function(t,e){return t.every((t=>e.every((e=>es.commutative(t,e)))))},t.applyAll=function(t,n){for(let r of n){let n=e(t,r);null!==n&&(t=n.data)}return t},t.apply=e})(ns||(ns={}));var us=Symbol(),ps=Symbol(),fs=Symbol(),ms=class{reportOp(t,e,n=[]){let r=this;if(null===e)return;r._current=e.data;let i=n;for(;!(r instanceof Os);){let t=r._path,e=r._current;if(""!==t&&i.splice(0,0,t),r=r._parent,null===r)return;r.update(t,e)}r.push(i,t,e.actual,e.reverse)}deleteChildren(t){if(this._children){let e=this._children[t];if(e){let n=e[fs];n&&n(),delete this._children[t]}}}},gs=class extends ms{constructor(t,e,n){super(),this._parent=t,this._path=e,this._current=n}update(t,e){if(Array.isArray(this._current)){if("string"==typeof t&&(t=parseInt(t),isNaN(t)))throw new Error("Invalid path");this._current=[...this._current],this._current[t]=e}else this._current={...this._current,[t]:e}}runOp(t){this.reportOp(t,Xa.runOp(this._current,t),t.path)}},vs=class extends ms{constructor(t,e,n){super(),this._parent=t,this._path=e,this._current=n}update(t,e){this._current={...this._current,[t]:e},Object.setPrototypeOf(this._current,Ra.prototype)}runOp(t){this.reportOp(t,this._current.runOp(t))}},ys={get(t,e){if(e===fs)return()=>{t._parent=null};if(e===us)return t._current;if(e===ps)return t;let{_current:n,_children:r}=t;if("push"===e&&Array.isArray(n))throw new Error("not supported to expand array");let i=void 0===r?void 0:r[e];if(void 0!==i)return i;let a=n[e],s=Ms(t,e,a);return s!==a?(void 0===r&&(r={},t._children=r),r[e]=s,s):a},has:(t,e)=>e in t._current,ownKeys:t=>Reflect.ownKeys(t._current),defineProperty(){throw Error("not supported")},getPrototypeOf:t=>Object.getPrototypeOf(t._current),setPrototypeOf(){throw Error("not supported")},getOwnPropertyDescriptor(t,e){let n=t._current,r=Reflect.getOwnPropertyDescriptor(n,e);return r&&{writable:!0,configurable:!0,enumerable:r.enumerable,value:n[e]}}},bs={...ys,set(t,e,n){let r={type:0,props:{[e]:Ds(n)??n}};return t.deleteChildren(e),t.runOp(r),!0},deleteProperty(t,e){let n={type:0,props:{[e]:void 0}};return t.deleteChildren(e),t.runOp(n),!0}},xs={...ys,set(t,e,n){return void 0===n?this.deleteProperty(t,e):(t.deleteChildren(e),t.runOp({type:1,id:e,data:n})),!0},deleteProperty:(t,e)=>(t.runOp({type:2,id:e}),!0)},ws=class extends ms{constructor(t,e,n){super(),this._children={},this._parent=t,this._path=e,this._current=n,this[fs]=()=>{this._parent=null}}unproxy(){return this._current}update(t,e){this._current=this._current.modifyById(t,e)}runOp(t){this.reportOp(t,this._current.runOp(t))}randomId(){return this._current.randomId()}isDescendantOf(t,e){return this._current.isDescendantOf(t,e)}childrenOf(t){return this._current.childrenOf(t)}traverse(t){return this._current.traverse(t)}get(t){return this._current.get(t)}parent(t){return this._current.parent(t)}traverse(t){this._current.traverse(((e,n)=>{t(e,this.data(e))}))}data(t){var e;let{_current:n,_children:r}=this,i=void 0===r?void 0:r[t];if(void 0!==i)return i;let a=null==(e=n.get(t))?void 0:e.data,s=Ms(this,t,a);return s!==a?(void 0===r&&(r={},this._children=r),r[t]=s,s):a}add(t,e,n,r,i){this.runOp({type:7,parent:t,fi:e,id:n,data:r,children:i})}move(t,e,n){this.runOp({type:9,parent:t,fi:e,id:n})}insertAfter(t,e,n){let r=this._current.insertAfterHelper(t,e,n.length);for(let i=0;i<n.length;i++){let e=n[i];this.add(t,r[i],e.id,e.data,e.children)}}insertBefore(t,e,n){let r=this._current.insertBeforeHelper(t,e,n.length);for(let i=0;i<n.length;i++){let e=n[i];this.add(t,r[i],e.id,e.data,e.children)}}moveAfter(t,e,n){let r=this._current.insertAfterHelper(t,e,n.length);for(let i=0;i<n.length;i++){let e=n[i];this.move(t,r[i],e)}}moveBefore(t,e,n){let r=this._current.insertBeforeHelper(t,e,n.length);for(let i=0;i<n.length;i++){let e=n[i];this.move(t,r[i],e)}}delete(t){this.deleteChildren(t),this.runOp({type:8,id:t})}sortNext(t){return this._current.sortNext(t)}sortPrevious(t){return this._current.sortPrevious(t)}getAllSorted(t){return this._current.getAllSorted(t)}},_s=class extends ms{constructor(t,e,n){super(),this._children={},this._parent=t,this._path=e,this._current=n,this[fs]=()=>{this._parent=null}}unproxy(){return this._current}get length(){return this._current.length}forEach(t){let e=this.length;for(let n=0;n<e;n++){let e=this._current[n].id,r=this._current[n].fi;t(this.data(this._current[n].id),e,r)}}find(t){let e=this.length;for(let n=0;n<e;n++){let e=this._current[n].id;if(t(this.data(e),e))return this.get(e)}}update(t,e){this._current=this._current.modifyById(t,e)}randomId(){return this._current.randomId()}get(t){return{...this._current.get(t),data:this.data(t)}}data(t){var e;let{_current:n,_children:r}=this,i=void 0===r?void 0:r[t];if(void 0!==i)return i;let a=null==(e=n.get(t))?void 0:e.data,s=Ms(this,t,a);return s!==a?(void 0===r&&(r={},this._children=r),r[t]=s,s):a}runOp(t){this.reportOp(t,this._current.runOp(t))}add(t,e,n){this.runOp({type:4,fi:t,id:e,data:n})}move(t,e){this.runOp({type:6,fi:t,id:e})}insertAfter(t,e){let n=this._current.insertAfterHelper(t,e.length);for(let r=0;r<e.length;r++){let t=e[r];this.add(n[r],t.id,t.data)}}insertBefore(t,e){let n=this._current.insertBeforeHelper(t,e.length);for(let r=0;r<e.length;r++){let t=e[r];this.add(n[r],t.id,t.data)}}moveAfter(t,e){let n=this._current.insertAfterHelper(t,e.length);for(let r=0;r<e.length;r++){let t=e[r];this.move(n[r],t)}}moveBefore(t,e){let n=this._current.insertBeforeHelper(t,e.length);for(let r=0;r<e.length;r++){let t=e[r];this.move(n[r],t)}}delete(t){this.deleteChildren(t),this.runOp({type:5,id:t})}};function Ss(t,e,n){if(t.length>0){let r=t[t.length-1];if(0===r.type&&0===e.type&&As.equal(r.path,n))return void Object.assign(r.props,e.props)}t.push({...e,path:n})}var As,Os=class extends ms{constructor(t){super(),this.ts=[],this.actual=[],this.reverse=[],this._current=t}update(t,e){if(""!==t)throw new Error("");this._current=e}push(t,e,n,r){Ss(this.ts,e,t),Ss(this.actual,n,t),Ss(this.reverse,r,t)}result(){return{data:this._current,ts:this.ts,actual:this.actual,reverse:this.reverse.reverse()}}};function Ms(t,e,n){return n instanceof Ya?new ws(t,e,n):n instanceof Ka?new _s(t,e,n):n instanceof Ra?new Proxy(new vs(t,e,n),xs):null!==n&&"object"==typeof n?Wa(n)?n:new Proxy(new gs(t,e,n),bs):n}function Cs(t){let e=new Os(t);return[Ms(e,"",t),e]}function Ps(t,e){let[n,r]=Cs(t);return e(n),r.result()}function Ds(t){return t instanceof ws||t instanceof _s?t._current:null!==t&&"object"==typeof t?t[us]:t}function Ts(t,e){let n=[];if(!(e.length<=t.length))return null;for(var r=0;r<e.length;){if("*"===e[r])n.push(t[r]);else if(t[r]!==e[r])return null;r+=1}return n}(t=>{function e(t,e){return(t instanceof Ya||t instanceof ws)&&"string"==typeof e||(t instanceof Ka||t instanceof _s)&&"string"==typeof e?t.data(e):"number"==typeof e&&Array.isArray(t)||"string"==typeof e&&"object"==typeof t&&null!==t?t[e]:void 0}function n(t,n,r=0){for(;r<n.length&&void 0!==t;)t=e(t,n[r]),r+=1;return t}t.equal=function(t,e){if(e.length!==t.length)return!1;for(var n=0;n<t.length;){if(t[n]!==e[n])return!1;n+=1}return!0},t.removeOverridden=function(t,e,r){let i=n(r,t);if(void 0!==i&&"object"==typeof i&&null!==i){let t={...e};return Object.keys(i).forEach((e=>{delete t[e]})),t}return e},t.zoomOnce=e,t.zoom=n})(As||(As={}));var zs,Es=class{},Ls=class extends Es{constructor(t){super(),this.id=t}},Is=class extends Es{constructor(t){super(),this.data=t}};try{zs=new TextDecoder}catch{}var Ns,js,Bs,Us,ks,Rs,Fs,Vs=0,Gs={},Hs=0,Ws=0,qs=[],$s={useRecords:!1,mapsAsObjects:!0},Xs=class{},Ys=new Xs;Ys.name="MessagePack 0xC1";var Ks=!1,Zs=class{constructor(t){t&&(!1===t.useRecords&&void 0===t.mapsAsObjects&&(t.mapsAsObjects=!0),t.structures?t.structures.sharedLength=t.structures.length:t.getStructures&&((t.structures=[]).uninitialized=!0,t.structures.sharedLength=0)),Object.assign(this,t)}unpack(t,e){if(Ns)return So((()=>(Ao(),this?this.unpack(t,e):Zs.prototype.unpack.call($s,t,e))));js=e>-1?e:t.length,Vs=0,Ws=0,Us=null,ks=null,Ns=t;try{Fs=t.dataView||(t.dataView=new DataView(t.buffer,t.byteOffset,t.byteLength))}catch(Ja){throw Ns=null,t instanceof Uint8Array?Ja:new Error("Source must be a Uint8Array or Buffer but was a "+(t&&"object"==typeof t?t.constructor.name:typeof t))}if(this instanceof Zs){if(Gs=this,this.structures)return Bs=this.structures,Qs();(!Bs||Bs.length>0)&&(Bs=[])}else Gs=$s,(!Bs||Bs.length>0)&&(Bs=[]);return Qs()}unpackMultiple(t,e){let n,r=0;try{Ks=!0;let i=t.length,a=this?this.unpack(t,i):Mo.unpack(t,i);if(!e){for(n=[a];Vs<i;)r=Vs,n.push(Qs());return n}for(e(a);Vs<i;)if(r=Vs,!1===e(Qs()))return}catch(pl){throw pl.lastPosition=r,pl.values=n,pl}finally{Ks=!1,Ao()}}_mergeStructures(t,e){for(let n=0,r=(t=t||[]).length;n<r;n++){let e=t[n];e&&(e.isShared=!0,n>=32&&(e.highByte=n-32>>5))}t.sharedLength=t.length;for(let n in e||[])if(n>=0){let r=t[n],i=e[n];i&&(r&&((t.restoreStructures||(t.restoreStructures=[]))[n]=r),t[n]=i)}return this.structures=t}decode(t,e){return this.unpack(t,e)}};function Qs(){try{if(!Gs.trusted&&!Ks){let t=Bs.sharedLength||0;t<Bs.length&&(Bs.length=t)}let t=to();if(Vs==js)Bs.restoreStructures&&Js(),Bs=null,Ns=null,Rs&&(Rs=null);else{if(Vs>js){let t=new Error("Unexpected end of MessagePack data");throw t.incomplete=!0,t}if(!Ks)throw new Error("Data read, but end of buffer not reached")}return t}catch(we){throw Bs.restoreStructures&&Js(),Ao(),(we instanceof RangeError||we.message.startsWith("Unexpected end of buffer"))&&(we.incomplete=!0),we}}function Js(){for(let t in Bs.restoreStructures)Bs[t]=Bs.restoreStructures[t];Bs.restoreStructures=null}function to(){let t=Ns[Vs++];if(t<160){if(t<128){if(t<64)return t;{let e=Bs[63&t]||Gs.getStructures&&io()[63&t];return e?(e.read||(e.read=no(e,63&t)),e.read()):t}}if(t<144){if(t-=128,Gs.mapsAsObjects){let e={};for(let n=0;n<t;n++)e[bo()]=to();return e}{let e=new Map;for(let n=0;n<t;n++)e.set(to(),to());return e}}{t-=144;let e=new Array(t);for(let n=0;n<t;n++)e[n]=to();return e}}if(t<192){let e=t-160;if(Ws>=Vs)return Us.slice(Vs-Hs,(Vs+=e)-Hs);if(0==Ws&&js<140){let t=e<16?mo(e):fo(e);if(null!=t)return t}return ao(e)}{let e;switch(t){case 192:return null;case 193:return ks?(e=to(),e>0?ks[1].slice(ks.position1,ks.position1+=e):ks[0].slice(ks.position0,ks.position0-=e)):Ys;case 194:return!1;case 195:return!0;case 196:return go(Ns[Vs++]);case 197:return e=Fs.getUint16(Vs),Vs+=2,go(e);case 198:return e=Fs.getUint32(Vs),Vs+=4,go(e);case 199:return vo(Ns[Vs++]);case 200:return e=Fs.getUint16(Vs),Vs+=2,vo(e);case 201:return e=Fs.getUint32(Vs),Vs+=4,vo(e);case 202:if(e=Fs.getFloat32(Vs),Gs.useFloat32>2){let t=Oo[(127&Ns[Vs])<<1|Ns[Vs+1]>>7];return Vs+=4,(t*e+(e>0?.5:-.5)>>0)/t}return Vs+=4,e;case 203:return e=Fs.getFloat64(Vs),Vs+=8,e;case 204:return Ns[Vs++];case 205:return e=Fs.getUint16(Vs),Vs+=2,e;case 206:return e=Fs.getUint32(Vs),Vs+=4,e;case 207:return Gs.int64AsNumber?(e=4294967296*Fs.getUint32(Vs),e+=Fs.getUint32(Vs+4)):e=Fs.getBigUint64(Vs),Vs+=8,e;case 208:return Fs.getInt8(Vs++);case 209:return e=Fs.getInt16(Vs),Vs+=2,e;case 210:return e=Fs.getInt32(Vs),Vs+=4,e;case 211:return Gs.int64AsNumber?(e=4294967296*Fs.getInt32(Vs),e+=Fs.getUint32(Vs+4)):e=Fs.getBigInt64(Vs),Vs+=8,e;case 212:if(e=Ns[Vs++],114==e)return xo(63&Ns[Vs++]);{let t=qs[e];if(t)return t.read?(Vs++,t.read(to())):t.noBuffer?(Vs++,t()):t(Ns.subarray(Vs,++Vs));throw new Error("Unknown extension "+e)}case 213:return e=Ns[Vs],114==e?(Vs++,xo(63&Ns[Vs++],Ns[Vs++])):vo(2);case 214:return vo(4);case 215:return vo(8);case 216:return vo(16);case 217:return e=Ns[Vs++],Ws>=Vs?Us.slice(Vs-Hs,(Vs+=e)-Hs):so(e);case 218:return e=Fs.getUint16(Vs),Ws>=(Vs+=2)?Us.slice(Vs-Hs,(Vs+=e)-Hs):oo(e);case 219:return e=Fs.getUint32(Vs),Ws>=(Vs+=4)?Us.slice(Vs-Hs,(Vs+=e)-Hs):lo(e);case 220:return e=Fs.getUint16(Vs),Vs+=2,co(e);case 221:return e=Fs.getUint32(Vs),Vs+=4,co(e);case 222:return e=Fs.getUint16(Vs),Vs+=2,uo(e);case 223:return e=Fs.getUint32(Vs),Vs+=4,uo(e);default:if(t>=224)return t-256;if(void 0===t){let t=new Error("Unexpected end of MessagePack data");throw t.incomplete=!0,t}throw new Error("Unknown MessagePack token "+t)}}}var eo=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;function no(t,e){function n(){if(n.count++>2){let n=t.read=new Function("r","return function(){return {"+t.map((t=>eo.test(t)?t+":r()":"["+JSON.stringify(t)+"]:r()")).join(",")+"}}")(to);return 0===t.highByte&&(t.read=ro(e,t.read)),n()}let r={};for(let e=0,n=t.length;e<n;e++){r[t[e]]=to()}return r}return n.count=0,0===t.highByte?ro(e,n):n}var ro=(t,e)=>function(){let n=Ns[Vs++];if(0===n)return e();let r=t<32?-(t+(n<<5)):t+(n<<5),i=Bs[r]||io()[r];if(!i)throw new Error("Record id is not defined for "+r);return i.read||(i.read=no(i,t)),i.read()};function io(){let t=So((()=>(Ns=null,Gs.getStructures())));return Bs=Gs._mergeStructures(t,Bs)}var ao=ho,so=ho,oo=ho,lo=ho;function ho(t){let e;if(t<16&&(e=mo(t)))return e;if(t>64&&zs)return zs.decode(Ns.subarray(Vs,Vs+=t));let n=Vs+t,r=[];for(e="";Vs<n;){let t=Ns[Vs++];if(0==(128&t))r.push(t);else if(192==(224&t)){let e=63&Ns[Vs++];r.push((31&t)<<6|e)}else if(224==(240&t)){let e=63&Ns[Vs++],n=63&Ns[Vs++];r.push((31&t)<<12|e<<6|n)}else if(240==(248&t)){let e=(7&t)<<18|(63&Ns[Vs++])<<12|(63&Ns[Vs++])<<6|63&Ns[Vs++];e>65535&&(e-=65536,r.push(e>>>10&1023|55296),e=56320|1023&e),r.push(e)}else r.push(t);r.length>=4096&&(e+=po.apply(String,r),r.length=0)}return r.length>0&&(e+=po.apply(String,r)),e}function co(t){let e=new Array(t);for(let n=0;n<t;n++)e[n]=to();return e}function uo(t){if(Gs.mapsAsObjects){let e={};for(let n=0;n<t;n++)e[bo()]=to();return e}{let e=new Map;for(let n=0;n<t;n++)e.set(to(),to());return e}}var po=String.fromCharCode;function fo(t){let e=Vs,n=new Array(t);for(let r=0;r<t;r++){let t=Ns[Vs++];if((128&t)>0)return void(Vs=e);n[r]=t}return po.apply(String,n)}function mo(t){if(t<4){if(t<2){if(0===t)return"";{let t=Ns[Vs++];return(128&t)>1?void(Vs-=1):po(t)}}{let e=Ns[Vs++],n=Ns[Vs++];if((128&e)>0||(128&n)>0)return void(Vs-=2);if(t<3)return po(e,n);let r=Ns[Vs++];return(128&r)>0?void(Vs-=3):po(e,n,r)}}{let e=Ns[Vs++],n=Ns[Vs++],r=Ns[Vs++],i=Ns[Vs++];if((128&e)>0||(128&n)>0||(128&r)>0||(128&i)>0)return void(Vs-=4);if(t<6){if(4===t)return po(e,n,r,i);{let t=Ns[Vs++];return(128&t)>0?void(Vs-=5):po(e,n,r,i,t)}}if(t<8){let a=Ns[Vs++],s=Ns[Vs++];if((128&a)>0||(128&s)>0)return void(Vs-=6);if(t<7)return po(e,n,r,i,a,s);let o=Ns[Vs++];return(128&o)>0?void(Vs-=7):po(e,n,r,i,a,s,o)}{let a=Ns[Vs++],s=Ns[Vs++],o=Ns[Vs++],l=Ns[Vs++];if((128&a)>0||(128&s)>0||(128&o)>0||(128&l)>0)return void(Vs-=8);if(t<10){if(8===t)return po(e,n,r,i,a,s,o,l);{let t=Ns[Vs++];return(128&t)>0?void(Vs-=9):po(e,n,r,i,a,s,o,l,t)}}if(t<12){let h=Ns[Vs++],d=Ns[Vs++];if((128&h)>0||(128&d)>0)return void(Vs-=10);if(t<11)return po(e,n,r,i,a,s,o,l,h,d);let c=Ns[Vs++];return(128&c)>0?void(Vs-=11):po(e,n,r,i,a,s,o,l,h,d,c)}{let h=Ns[Vs++],d=Ns[Vs++],c=Ns[Vs++],u=Ns[Vs++];if((128&h)>0||(128&d)>0||(128&c)>0||(128&u)>0)return void(Vs-=12);if(t<14){if(12===t)return po(e,n,r,i,a,s,o,l,h,d,c,u);{let t=Ns[Vs++];return(128&t)>0?void(Vs-=13):po(e,n,r,i,a,s,o,l,h,d,c,u,t)}}{let p=Ns[Vs++],f=Ns[Vs++];if((128&p)>0||(128&f)>0)return void(Vs-=14);if(t<15)return po(e,n,r,i,a,s,o,l,h,d,c,u,p,f);let m=Ns[Vs++];return(128&m)>0?void(Vs-=15):po(e,n,r,i,a,s,o,l,h,d,c,u,p,f,m)}}}}}function go(t){return Gs.copyBuffers?Uint8Array.prototype.slice.call(Ns,Vs,Vs+=t):Ns.subarray(Vs,Vs+=t)}function vo(t){let e=Ns[Vs++];if(qs[e])return qs[e](Ns.subarray(Vs,Vs+=t));throw new Error("Unknown extension type "+e)}var yo=new Array(4096);function bo(){let t=Ns[Vs++];if(!(t>=160&&t<192))return Vs--,to();if(t-=160,Ws>=Vs)return Us.slice(Vs-Hs,(Vs+=t)-Hs);if(!(0==Ws&&js<180))return ao(t);let e,n=4095&(t<<5^(t>1?Fs.getUint16(Vs):t>0?Ns[Vs]:0)),r=yo[n],i=Vs,a=Vs+t-3,s=0;if(r&&r.bytes==t){for(;i<a;){if(e=Fs.getUint32(i),e!=r[s++]){i=1879048192;break}i+=4}for(a+=3;i<a;)if(e=Ns[i++],e!=r[s++]){i=1879048192;break}if(i===a)return Vs=i,r.string;a-=3,i=Vs}for(r=[],yo[n]=r,r.bytes=t;i<a;)e=Fs.getUint32(i),r.push(e),i+=4;for(a+=3;i<a;)e=Ns[i++],r.push(e);let o=t<16?mo(t):fo(t);return r.string=null!=o?o:ao(t)}var xo=(t,e)=>{var n=to();let r=t;void 0!==e&&(t=t<32?-((e<<5)+t):(e<<5)+t,n.highByte=e);let i=Bs[t];return i&&i.isShared&&((Bs.restoreStructures||(Bs.restoreStructures=[]))[t]=i),Bs[t]=n,n.read=no(n,r),n.read()},wo="object"==typeof self?self:global;qs[0]=()=>{},qs[0].noBuffer=!0,qs[101]=()=>{let t=to();return(wo[t[0]]||Error)(t[1])},qs[105]=t=>{let e=Fs.getUint32(Vs-4);Rs||(Rs=new Map);let n,r=Ns[Vs];n=r>=144&&r<160||220==r||221==r?[]:{};let i={target:n};Rs.set(e,i);let a=to();return i.used?Object.assign(n,a):(i.target=a,a)},qs[112]=t=>{let e=Fs.getUint32(Vs-4),n=Rs.get(e);return n.used=!0,n.target},qs[115]=()=>new Set(to());var _o=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map((t=>t+"Array"));function So(t){let e=js,n=Vs,r=Hs,i=Ws,a=Us,s=Rs,o=ks,l=new Uint8Array(Ns.slice(0,js)),h=Bs,d=Bs.slice(0,Bs.length),c=Gs,u=Ks,p=t();return js=e,Vs=n,Hs=r,Ws=i,Us=a,Rs=s,ks=o,Ns=l,Ks=u,(Bs=h).splice(0,Bs.length,...d),Gs=c,Fs=new DataView(Ns.buffer,Ns.byteOffset,Ns.byteLength),p}function Ao(){Ns=null,Rs=null,Bs=null}qs[116]=t=>{let e=t[0],n=_o[e];if(!n)throw new Error("Could not find typed array for code "+e);return new wo[n](Uint8Array.prototype.slice.call(t,1).buffer)},qs[120]=()=>{let t=to();return new RegExp(t[0],t[1])},qs[98]=t=>{let e=(t[0]<<24)+(t[1]<<16)+(t[2]<<8)+t[3],n=Vs;Vs+=e-4,(ks=[to(),to()]).position0=0,ks.position1=0;let r=Vs;Vs=n;try{return to()}finally{Vs=r}},qs[255]=t=>4==t.length?new Date(1e3*(16777216*t[0]+(t[1]<<16)+(t[2]<<8)+t[3])):8==t.length?new Date(((t[0]<<22)+(t[1]<<14)+(t[2]<<6)+(t[3]>>2))/1e6+1e3*(4294967296*(3&t[3])+16777216*t[4]+(t[5]<<16)+(t[6]<<8)+t[7])):12==t.length?new Date(((t[0]<<24)+(t[1]<<16)+(t[2]<<8)+t[3])/1e6+1e3*((128&t[4]?-281474976710656:0)+1099511627776*t[6]+4294967296*t[7]+16777216*t[8]+(t[9]<<16)+(t[10]<<8)+t[11])):new Date("invalid");var Oo=new Array(147);for(let Ly=0;Ly<256;Ly++)Oo[Ly]=+("1e"+Math.floor(45.15-.30103*Ly));var Mo=new Zs({useRecords:!1});Mo.unpack,Mo.unpackMultiple,Mo.unpack;var Co,Po=new Float32Array(1);new Uint8Array(Po.buffer,0,4);try{Co=new TextEncoder}catch{}var Do,To,zo,Eo,Lo,Io=typeof Buffer<"u",No=Io?Buffer.allocUnsafeSlow:Uint8Array,jo=Io?Buffer:Uint8Array,Bo=Io?4294967296:2144337920,Uo=0,ko=null,Ro=/[\u0080-\uFFFF]/,Fo=Symbol("record-id"),Vo=class extends Zs{constructor(t){super(t),this.offset=0;let e,n,r,i,a,s=0,o=jo.prototype.utf8Write?function(t,e,n){return zo.utf8Write(t,e,n)}:!(!Co||!Co.encodeInto)&&function(t,e){return Co.encodeInto(t,zo.subarray(e)).written},l=this;t||(t={});let h=t&&t.sequential,d=t.structures||t.saveStructures,c=t.maxSharedStructures;if(null==c&&(c=d?32:0),c>8160)throw new Error("Maximum maxSharedStructure is 8160");let u=t.maxOwnStructures;null==u&&(u=d?32:64),h&&!t.saveStructures&&(this.structures=[]);let p=c>32||u+c>64,f=c+64,m=c+u+64;if(m>8256)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let g=[],v=0,y=0;this.pack=this.encode=function(t,o){if(zo||(zo=new No(8192),Eo=new DataView(zo.buffer,0,8192),Uo=0),(Lo=zo.length-10)-Uo<2048?(zo=new No(zo.length),Eo=new DataView(zo.buffer,0,zo.length),Lo=zo.length-10,Uo=0):Uo=Uo+7&2147483640,e=Uo,a=l.structuredClone?new Map:null,l.bundleStrings?(ko=["",""],zo[Uo++]=214,zo[Uo++]=98,ko.position=Uo-e,Uo+=4):ko=null,n=l.structures,n){n.uninitialized&&(n=l._mergeStructures(l.getStructures()));let t=n.sharedLength||0;if(t>c)throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+n.sharedLength);if(!n.transitions){n.transitions=Object.create(null);for(let e=0;e<t;e++){let t=n[e];if(!t)continue;let r,i=n.transitions;for(let e=0,n=t.length;e<n;e++){let n=t[e];r=i[n],r||(r=i[n]=Object.create(null)),i=r}i[Fo]=e+64}s=t}h||(n.nextId=t+64)}r&&(r=!1),i=n||[];try{if(b(t),ko){Eo.setUint32(ko.position+e,Uo-ko.position-e);let t=ko;ko=null,b(t[0]),b(t[1])}if(l.offset=Uo,a&&a.idsToInsert){(Uo+=6*a.idsToInsert.length)>Lo&&w(Uo),l.offset=Uo;let t=function(t,e){let n,r=6*e.length,i=t.length-r;for(e.sort(((t,e)=>t.offset>e.offset?1:-1));n=e.pop();){let e=n.offset,a=n.id;t.copyWithin(e+r,e,i),r-=6;let s=e+r;t[s++]=214,t[s++]=105,t[s++]=a>>24,t[s++]=a>>16&255,t[s++]=a>>8&255,t[s++]=255&a,i=e}return t}(zo.subarray(e,Uo),a.idsToInsert);return a=null,t}return o&Yo?(zo.start=e,zo.end=Uo,zo):zo.subarray(e,Uo)}finally{if(n){if(y<10&&y++,v>1e4)n.transitions=null,y=0,v=0,g.length>0&&(g=[]);else if(g.length>0&&!h){for(let t=0,e=g.length;t<e;t++)g[t][Fo]=0;g=[]}if(r&&l.saveStructures){let r=n.sharedLength||c;n.length>r&&(n=n.slice(0,r));let i=zo.subarray(e,Uo);return!1===l.saveStructures(n,s)?(l._mergeStructures(l.getStructures()),l.pack(t)):(s=r,i)}}o&Ko&&(Uo=e)}};let b=t=>{Uo>Lo&&(zo=w(Uo));var n,r=typeof t;if("string"===r){let e,r=t.length;if(ko&&r>=8&&r<4096){let e=Ro.test(t);return ko[e?0:1]+=t,zo[Uo++]=193,void b(e?-r:r)}e=r<32?1:r<256?2:r<65536?3:5;let i=3*r;if(Uo+i>Lo&&(zo=w(Uo+i)),r<64||!o){let i,a,s,o=Uo+e;for(i=0;i<r;i++)a=t.charCodeAt(i),a<128?zo[o++]=a:a<2048?(zo[o++]=a>>6|192,zo[o++]=63&a|128):55296==(64512&a)&&56320==(64512&(s=t.charCodeAt(i+1)))?(a=65536+((1023&a)<<10)+(1023&s),i++,zo[o++]=a>>18|240,zo[o++]=a>>12&63|128,zo[o++]=a>>6&63|128,zo[o++]=63&a|128):(zo[o++]=a>>12|224,zo[o++]=a>>6&63|128,zo[o++]=63&a|128);n=o-Uo-e}else n=o(t,Uo+e,i);n<32?zo[Uo++]=160|n:n<256?(e<2&&zo.copyWithin(Uo+2,Uo+1,Uo+1+n),zo[Uo++]=217,zo[Uo++]=n):n<65536?(e<3&&zo.copyWithin(Uo+3,Uo+2,Uo+2+n),zo[Uo++]=218,zo[Uo++]=n>>8,zo[Uo++]=255&n):(e<5&&zo.copyWithin(Uo+5,Uo+3,Uo+3+n),zo[Uo++]=219,Eo.setUint32(Uo,n),Uo+=4),Uo+=n}else if("number"===r)if(t>>>0===t)t<64?zo[Uo++]=t:t<256?(zo[Uo++]=204,zo[Uo++]=t):t<65536?(zo[Uo++]=205,zo[Uo++]=t>>8,zo[Uo++]=255&t):(zo[Uo++]=206,Eo.setUint32(Uo,t),Uo+=4);else if(t>>0===t)t>=-32?zo[Uo++]=256+t:t>=-128?(zo[Uo++]=208,zo[Uo++]=t+256):t>=-32768?(zo[Uo++]=209,Eo.setInt16(Uo,t),Uo+=2):(zo[Uo++]=210,Eo.setInt32(Uo,t),Uo+=4);else{let e;if((e=this.useFloat32)>0&&t<4294967296&&t>=-2147483648){let n;if(zo[Uo++]=202,Eo.setFloat32(Uo,t),e<4||(n=t*Oo[(127&zo[Uo])<<1|zo[Uo+1]>>7])>>0===n)return void(Uo+=4);Uo--}zo[Uo++]=203,Eo.setFloat64(Uo,t),Uo+=8}else if("object"===r)if(t){if(a){let n=a.get(t);if(n){if(!n.id){let t=a.idsToInsert||(a.idsToInsert=[]);n.id=t.push(n)}return zo[Uo++]=214,zo[Uo++]=112,Eo.setUint32(Uo,n.id),void(Uo+=4)}a.set(t,{offset:Uo-e})}let r=t.constructor;if(r===Object)x(t,!0);else if(r===Array){(n=t.length)<16?zo[Uo++]=144|n:n<65536?(zo[Uo++]=220,zo[Uo++]=n>>8,zo[Uo++]=255&n):(zo[Uo++]=221,Eo.setUint32(Uo,n),Uo+=4);for(let e=0;e<n;e++)b(t[e])}else if(r===Map){(n=t.size)<16?zo[Uo++]=128|n:n<65536?(zo[Uo++]=222,zo[Uo++]=n>>8,zo[Uo++]=255&n):(zo[Uo++]=223,Eo.setUint32(Uo,n),Uo+=4);for(let[e,n]of t)b(e),b(n)}else{for(let e=0,n=Do.length;e<n;e++){if(t instanceof To[e]){let n=Do[e];if(n.write)return n.type&&(zo[Uo++]=212,zo[Uo++]=n.type,zo[Uo++]=0),void b(n.write.call(this,t));let r,i=zo,a=Eo,s=Uo;zo=null;try{r=n.pack.call(this,t,(t=>(zo=i,i=null,(Uo+=t)>Lo&&w(Uo),{target:zo,targetView:Eo,position:Uo-t})),b)}finally{i&&(Eo=a,Uo=s,Lo=(zo=i).length-10)}return void(r&&(r.length+Uo>Lo&&w(r.length+Uo),Uo=Wo(r,zo,Uo,n.type)))}}x(t,!t.hasOwnProperty)}}else zo[Uo++]=192;else if("boolean"===r)zo[Uo++]=t?195:194;else if("bigint"===r){if(t<BigInt(1)<<BigInt(63)&&t>=-(BigInt(1)<<BigInt(63)))zo[Uo++]=211,Eo.setBigInt64(Uo,t);else if(t<BigInt(1)<<BigInt(64)&&t>0)zo[Uo++]=207,Eo.setBigUint64(Uo,t);else{if(!this.largeBigIntToFloat)throw new RangeError(t+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");zo[Uo++]=203,Eo.setFloat64(Uo,Number(t))}Uo+=8}else if("undefined"===r)this.encodeUndefinedAsNil?zo[Uo++]=192:(zo[Uo++]=212,zo[Uo++]=0,zo[Uo++]=0);else{if("function"!==r)throw new Error("Unknown type: "+r);b(this.writeFunction&&this.writeFunction())}},x=!1===this.useRecords?this.variableMapSize?t=>{let e,n=Object.keys(t),r=n.length;r<16?zo[Uo++]=128|r:r<65536?(zo[Uo++]=222,zo[Uo++]=r>>8,zo[Uo++]=255&r):(zo[Uo++]=223,Eo.setUint32(Uo,r),Uo+=4);for(let i=0;i<r;i++)b(e=n[i]),b(t[e])}:(t,n)=>{zo[Uo++]=222;let r=Uo-e;Uo+=2;let i=0;for(let e in t)(n||t.hasOwnProperty(e))&&(b(e),b(t[e]),i++);zo[r+++e]=i>>8,zo[r+e]=255&i}:t=>{let e,n=Object.keys(t),a=i.transitions||(i.transitions=Object.create(null)),s=0;for(let r=0,i=n.length;r<i;r++){let t=n[r];e=a[t],e||(e=a[t]=Object.create(null),s++),a=e}let o=a[Fo];if(o)o>=96&&p?(zo[Uo++]=96+(31&(o-=96)),zo[Uo++]=o>>5):zo[Uo++]=o;else{o=i.nextId,o||(o=64),o<f&&this.shouldShareStructure&&!this.shouldShareStructure(n)?(o=i.nextOwnId,o<m||(o=f),i.nextOwnId=o+1):(o>=m&&(o=f),i.nextId=o+1);let t=n.highByte=o>=96&&p?o-96>>5:-1;a[Fo]=o,i[o-64]=n,o<f?(n.isShared=!0,i.sharedLength=o-63,r=!0,t>=0?(zo[Uo++]=96+(31&o),zo[Uo++]=t):zo[Uo++]=o):(t>=0?(zo[Uo++]=213,zo[Uo++]=114,zo[Uo++]=96+(31&o),zo[Uo++]=t):(zo[Uo++]=212,zo[Uo++]=114,zo[Uo++]=o),s&&(v+=y*s),g.length>=u&&(g.shift()[Fo]=0),g.push(a),b(n))}for(let r=0,i=n.length;r<i;r++)b(t[n[r]])},w=t=>{let n;if(t>16777216){if(t-e>Bo)throw new Error("Packed buffer would be larger than maximum buffer size");n=Math.min(Bo,4096*Math.round(Math.max((t-e)*(t>67108864?1.25:2),4194304)/4096))}else n=1+(Math.max(t-e<<2,zo.length-1)>>12)<<12;let r=new No(n);return Eo=new DataView(r.buffer,0,n),zo.copy?zo.copy(r,0,e,t):r.set(zo.slice(e,t)),Uo-=e,e=0,Lo=r.length-10,zo=r}}useBuffer(t){zo=t,Eo=new DataView(zo.buffer,zo.byteOffset,zo.byteLength),Uo=0}};function Go(t,e,n,r){let i=t.byteLength;if(i+1<256){var{target:a,position:s}=n(4+i);a[s++]=199,a[s++]=i+1}else if(i+1<65536){var{target:a,position:s}=n(5+i);a[s++]=200,a[s++]=i+1>>8,a[s++]=i+1&255}else{var{target:a,position:s,targetView:o}=n(7+i);a[s++]=201,o.setUint32(s,i+1),s+=4}a[s++]=116,a[s++]=e,a.set(new Uint8Array(t.buffer,t.byteOffset,t.byteLength),s)}function Ho(t,e){let n=t.byteLength;var r,i;if(n<256){var{target:r,position:i}=e(n+2);r[i++]=196,r[i++]=n}else if(n<65536){var{target:r,position:i}=e(n+3);r[i++]=197,r[i++]=n>>8,r[i++]=255&n}else{var{target:r,position:i,targetView:a}=e(n+5);r[i++]=198,a.setUint32(i,n),i+=4}r.set(t,i)}function Wo(t,e,n,r){let i=t.length;switch(i){case 1:e[n++]=212;break;case 2:e[n++]=213;break;case 4:e[n++]=214;break;case 8:e[n++]=215;break;case 16:e[n++]=216;break;default:i<256?(e[n++]=199,e[n++]=i):i<65536?(e[n++]=200,e[n++]=i>>8,e[n++]=255&i):(e[n++]=201,e[n++]=i>>24,e[n++]=i>>16&255,e[n++]=i>>8&255,e[n++]=255&i)}return e[n++]=r,e.set(t,n),n+=i}function qo(t){if(t.Class){if(!t.pack&&!t.write)throw new Error("Extension has no pack or write function");if(t.pack&&!t.type)throw new Error("Extension has no type (numeric code to identify the extension)");To.unshift(t.Class),Do.unshift(t)}!function(t){t.unpack?qs[t.type]=t.unpack:qs[t.type]=t}(t)}To=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor,Xs],Do=[{pack(t,e,n){let r=t.getTime()/1e3;if((this.useTimestamp32||0===t.getMilliseconds())&&r>=0&&r<4294967296){let{target:t,targetView:n,position:i}=e(6);t[i++]=214,t[i++]=255,n.setUint32(i,r)}else if(r>0&&r<17179869184){let{target:n,targetView:i,position:a}=e(10);n[a++]=215,n[a++]=255,i.setUint32(a,4e6*t.getMilliseconds()+(r/1e3/4294967296>>0)),i.setUint32(a+4,r)}else if(isNaN(r)){if(this.onInvalidDate)return e(0),n(this.onInvalidDate());let{target:t,targetView:r,position:i}=e(3);t[i++]=212,t[i++]=255,t[i++]=255}else{let{target:n,targetView:i,position:a}=e(15);n[a++]=199,n[a++]=12,n[a++]=255,i.setUint32(a,1e6*t.getMilliseconds()),i.setBigInt64(a+4,BigInt(Math.floor(r)))}}},{pack(t,e,n){let r=Array.from(t),{target:i,position:a}=e(this.structuredClone?3:0);this.structuredClone&&(i[a++]=212,i[a++]=115,i[a++]=0),n(r)}},{pack(t,e,n){let{target:r,position:i}=e(this.structuredClone?3:0);this.structuredClone&&(r[i++]=212,r[i++]=101,r[i++]=0),n([t.name,t.message])}},{pack(t,e,n){let{target:r,position:i}=e(this.structuredClone?3:0);this.structuredClone&&(r[i++]=212,r[i++]=120,r[i++]=0),n([t.source,t.flags])}},{pack(t,e){this.structuredClone?Go(t,16,e):Ho(Io?Buffer.from(t):new Uint8Array(t),e)}},{pack(t,e){let n=t.constructor;n!==jo&&this.structuredClone?Go(t,_o.indexOf(n.name),e):Ho(t,e)}},{pack(t,e){let{target:n,position:r}=e(1);n[r]=193}}];var $o=new Vo({useRecords:!1});$o.pack,$o.pack;var Xo,Yo=512,Ko=1024,Zo=new Vo({structuredClone:!0});function Qo(t){if(Wa(t))return t;if(Array.isArray(t))return t.map(Qo);if("object"==typeof t&&null!==t){let e={};for(let n of Object.keys(t).sort())e[n]=Qo(t[n]);return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),e}return t}qo({Class:Ra.prototype.constructor,type:1,write:t=>({...t}),read:t=>(Object.setPrototypeOf(t,Ra.prototype),t)}),qo({Class:Ka.prototype.constructor,type:2,write:t=>[...t],read:t=>(Object.setPrototypeOf(t,Ka.prototype),t)}),qo({Class:Ya.prototype.constructor,type:3,write:t=>[...t],read:t=>(Object.setPrototypeOf(t,Ya.prototype),t)}),qo({Class:Ls.prototype.constructor,type:4,write:t=>t.id,read:t=>new Ls(t)}),qo({Class:Is.prototype.constructor,type:5,write:t=>t.data,read:t=>new Is(t)}),qo({Class:rs.prototype.constructor,type:6,write:t=>({...t}),read:t=>(Object.setPrototypeOf(t,rs.prototype),t)}),(t=>{function e(t){return Zo.pack(t)}t.serialize=e,t.deserialize=function(t){return Zo.unpack(t)},t.checksum=function(t){return function(t){var e=0;if(0===t.length)return e;for(let n=0;n<t.length;n++)e=(e<<5)-e+t[n],e&=e;return e}(e(Qo(t))).toString()}})(Xo||(Xo={}));var Jo,tl,el,nl,rl,il,al,sl,ol,ll,hl,dl,cl,ul,pl,fl,ml,gl,vl,yl="personal camera",bl="a218fcc3-276b-49b9-b485-49037fd14f5f",xl=5526619;function wl(t){return"string"==typeof t&&36===t.length&&/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(t)}(tl=Jo||(Jo={})).isEqual=function(t,e){return t[0]===e[0]&&t[1]===e[1]},tl.lerp=function(t,e,n){return[t[0]+(e[0]-t[0])*n,t[1]+(e[1]-t[1])*n]},(nl=el||(el={})).isEqual=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]},nl.add=function(t,e){return[t[0]+e[0],t[1]+e[1],t[2]+e[2]]},nl.sub=function(t,e){return[t[0]-e[0],t[1]-e[1],t[2]-e[2]]},nl.div=function(t,e){return[t[0]/e[0],t[1]/e[1],t[2]/e[2]]},nl.mul=function(t,e){return[t[0]*e[0],t[1]*e[1],t[2]*e[2]]},nl.dist=function(t,e){return Math.hypot(t[0]-e[0],t[1]-e[1],t[2]-e[2])},nl.lerp=function(t,e,n){return[t[0]+(e[0]-t[0])*n,t[1]+(e[1]-t[1])*n,t[2]+(e[2]-t[2])*n]},(t=>{t.isEqual=function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]},t.lerp=function(t,e,n){return[t[0]+(e[0]-t[0])*n,t[1]+(e[1]-t[1])*n,t[2]+(e[2]-t[2])*n,t[3]+(e[3]-t[3])*n]}})(rl||(rl={})),(al=il||(il={})).identity=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],al.isEqual=function(t,e){for(let n=0;n<16;n++)if(t[n]!==e[n])return!1;return!0},al.simplify=function(t){return t??al.identity},al.applyMatrix4=function(t,e){let n=e.slice(0);for(var r=0,i=e.length;r<i;r+=3){let i=t[3]*e[r]+t[7]*e[r+1]+t[11]*e[r+2]+t[15];n[r]=(t[0]*e[r]+t[4]*e[r+1]+t[8]*e[r+2]+t[12])/i,n[r+1]=(t[1]*e[r]+t[5]*e[r+1]+t[9]*e[r+2]+t[13])/i,n[r+2]=(t[2]*e[r]+t[6]*e[r+1]+t[10]*e[r+2]+t[14])/i}return n},(ol=sl||(sl={})).isRGB=function(t){return"object"==typeof t&&"number"==typeof t.r&&"number"==typeof t.g&&"number"==typeof t.b},ol.white={r:1,g:1,b:1},ol.red={r:1,g:0,b:0},ol.black={r:0,g:0,b:0},ol.toRgb255a1=function(t){return{r:Math.round(255*t.r),g:Math.round(255*t.g),b:Math.round(255*t.b),a:1}},ol.clone=function(t){return{r:t.r,g:t.g,b:t.b}},ol.fromHex=function(t){return{r:((t=Math.floor(t))>>16&255)/255,g:(t>>8&255)/255,b:(255&t)/255}},ol.toHex=function(t){return 65536*Math.round(255*t.r)+256*Math.round(255*t.g)+Math.round(255*t.b)},ol.equals=function(t,e){return t.r===e.r&&t.g===e.g&&t.b===e.b},ol.lerp=function(t,e,n){return{r:t.r+(e.r-t.r)*n,g:t.g+(e.g-t.g)*n,b:t.b+(e.b-t.b)*n}},(t=>{t.white={...sl.white,a:1},t.transparent={...sl.white,a:0},t.from0to1=function(t){return{r:t[0],g:t[1],b:t[2],a:t[3]}},t.fromHexAndA=function(t,e){return{...sl.fromHex(t),a:e}},t.toRgb255a1=function(t){return{r:Math.round(255*t.r),g:Math.round(255*t.g),b:Math.round(255*t.b),a:t.a}},t.equals=function(t,e){return sl.equals(t,e)&&t.a===e.a},t.lerp=function(t,e,n){return{r:t.r+(e.r-t.r)*n,g:t.g+(e.g-t.g)*n,b:t.b+(e.b-t.b)*n,a:t.a+(e.a-t.a)*n}}})(ll||(ll={})),(hl||(hl={})).identity={position:[0,0,0],rotation:[0,0,0],scale:[1,1,1]},(dl||(dl={})).defaultData={mass:1,stiffness:80,damping:10,velocity:0},(cl||(cl={})).defaultData={control1:[.5,0],control2:[.5,1]},(pl=ul||(ul={})).linear=[0,0,1,1],pl.ease=[.25,.1,.25,1],pl.easeIn=[.42,0,1,1],pl.easeOut=[0,0,.58,1],pl.easeInOut=[.42,0,.58,1],(t=>{t.all=["PerspectiveCamera","OrthographicCamera"],t.is=function(e){return t.all.includes(e)}})(fl||(fl={})),(t=>{t.DefaultUp=[0,1,0],t.DefaultTargetOffset=1e3,t.defaultData={far:1e5,type:"OrthographicCamera",perspective:{near:70,fov:45,zoom:1},orthographic:{near:-1e5,zoom:1},up:t.DefaultUp,isUpVectorFlipped:!1,targetOffset:t.DefaultTargetOffset},t.getZoom=function(t){return"PerspectiveCamera"===t.type?t.perspective.zoom:t.orthographic.zoom}})(ml||(ml={})),(t=>{t.defaultData=function(t,e=.1){return{disabled:!1,type:"linear",hideBase:!1,count:3,radial:{radius:2*Math.max(t[0],t[1]),start:0,end:360,alignment:!1,axis:"y",scale:[1,1,1],rotation:[0,0,0],position:[0,0,0]},toObject:{object:"",spreadType:"random",scale:[0,0,0],rotation:[0,0,0],position:[0,0,0],axis:"x",seed:0,count:99,align:"normal"},linear:{scale:[1,1,1],rotation:[0,0,0],position:[t[0]+t[0]*e,0,0]},grid:{count:[2,2,2],size:t.map((t=>t*(1+e))),useCenter:!0},randomness:!1,randomnessObject:{strength:100,scale:[0,0,0],rotation:[0,0,0],position:[0,0,0],movement:1,seed:0,freqScale:10,noiseType:"perlin"}}},t.merge=function(t,e){let n={...t};if(El.forEach((r=>{Object.assign(n,{[r]:e[r]??t[r]})})),n.radial={...t.radial},e.radial){let r=t.radial,i=e.radial;Ll.forEach((t=>{Object.assign(n.radial,{[t]:i[t]??r[t]})}))}if(n.linear={...t.linear},e.linear){let r=t.linear,i=e.linear;Il.forEach((t=>{Object.assign(n.linear,{[t]:i[t]??r[t]})}))}if(n.grid={...t.grid},e.grid){let r=t.grid,i=e.grid;Nl.forEach((t=>{Object.assign(n.grid,{[t]:i[t]??r[t]})}))}if(n.toObject={...t.toObject},e.toObject){let r=t.toObject,i=e.toObject;jl.forEach((t=>{Object.assign(n.toObject,{[t]:i[t]??r[t]})}))}if(n.randomnessObject={...t.randomnessObject},e.randomnessObject){let r=t.randomnessObject,i=e.randomnessObject;Bl.forEach((t=>{Object.assign(n.randomnessObject,{[t]:i[t]??r[t]})}))}return n}})(gl||(gl={})),(t=>{t.defaultData={radial:{},linear:{},grid:{},toObject:{},randomnessObject:{}};let e=["radial","linear","grid","toObject","randomnessObject"];t.toOps=function(t,n){let r=[];void 0!==t.count&&r.push({type:0,path:n,props:{count:t.count}});for(let i of e){let e=t[i];e&&Object.keys(e).length>0&&r.push({type:0,path:[...n,i],props:e})}return r}})(vl||(vl={}));var _l,Sl,Al,Ol,Ml,Cl,Pl,Dl,Tl,zl,El=["count"],Ll=["radius","start","end","position","scale","rotation"],Il=["position","scale","rotation"],Nl=["count","size"],jl=["count","position","scale","rotation"],Bl=["strength","scale","rotation","position","movement","seed","freqScale"];(t=>{t.all=["PointLight","SpotLight","DirectionalLight","HemisphereLight"],t.is=function(e){return t.all.includes(e)}})(_l||(_l={})),(Sl||(Sl={})).defaultData=function(t){return function(t){if("PointLight"===t)return{type:t,color:ll.white,intensity:1,distance:2e3,decay:1,shadows:!0,shadowResolution:1024,shadowRadius:1,penumbraSize:.5,depth:1e5};if("SpotLight"===t)return{type:t,color:ll.white,intensity:1,distance:2e3,decay:1,shadows:!0,penumbra:0,angle:30/180*Math.PI,depth:1e5,penumbraSize:.5,shadowResolution:1024,shadowRadius:1};if("DirectionalLight"===t)return{type:t,color:ll.white,intensity:1,shadows:!0,size:2e3,depth:1e5,penumbraSize:.5,shadowResolution:1024,shadowRadius:1};throw new Error("not implemented")}(t)},(Al||(Al={})).defaultData={enabled:"visibility",fusedBody:!0,rigidBody:"positioned",density:1,pointMass:0,gravityScale:1,friction:.5,damping:0,restitution:.2,colliderType:"convex",enabledRotation:[!0,!0,!0],enabledTranslation:[!0,!0,!0]},(t=>{t.defaultData={castShadow:!0,receiveShadow:!0},t.equals=function(t,e){return t.castShadow===e.castShadow&&t.receiveShadow===e.receiveShadow}})(Ol||(Ol={})),(t=>{t.defaultData={flatShading:!1,wireframe:!1,side:0},t.equals=function(t,e){return t.flatShading===e.flatShading&&t.side===e.side&&t.wireframe===e.wireframe}})(Ml||(Ml={})),(Cl||(Cl={})).defaultData={...Ml.defaultData,...Ol.defaultData},(Pl||(Pl={})).getMaterialData=function(t,e){var n,r;let i=[];if("material"in t){let r="string"==typeof t.material?e.materials[t.material]??(null==(n=e.lib.materials[t.material])?void 0:n.asset):t.material;r&&i.push(r)}else if("materials"in t)for(let a of t.materials){let t="string"==typeof a?e.materials[a]??(null==(r=e.lib.materials[a])?void 0:r.asset):a;t&&i.push(t)}return i},(t=>{t.defaultVideo={data:"",thumb:"/_assets/_videos/catThumb.png",type:"video",name:"Cat video"},t.maxSize=3e7})(Dl||(Dl={})),(Tl||(Tl={})).is=function(t){return"texture"===t||"video"===t||"color"===t||"depth"===t||"normal"===t||"gradient"===t||"noise"===t||"fresnel"===t||"rainbow"===t||"toon"===t||"outline"===t||"transmission"===t||"matcap"===t||"displace"===t||"pattern"===t||"light"===t},(zl||(zl={})).is=function(t){return"phong"===t||"toon"===t||"lambert"===t||"physical"===t};var Ul,kl,Rl,Fl,Vl=["mode","gradientType","noiseType","displacementType","projection","cnormal","crop","axis","side"],Gl=["wrapping","image","video","name"];(t=>{t.patch=function(t,e){let{texture:n,...r}=e;if(Object.assign(t,r),n){let e=t.texture;e&&Object.assign(e,n)}},t.defaultData=function(t,e){return"light"===t&&e?function(t){let e={mode:0,isMask:!1,visible:!0,bumpMap:void 0,bumpMapIntensity:5,roughnessMap:void 0,alphaOverride:1};switch(t){case"phong":return{...e,category:"phong",specular:{r:.2,g:.2,b:.2},shininess:5,type:"light",visible:!0,mode:0,occlusion:!0,alpha:.6};case"toon":return{...e,category:"toon",specular:{r:.2,g:.2,b:.2},shininess:10,type:"light",alpha:1};case"lambert":return{...e,category:"lambert",emissive:{r:0,g:0,b:0},type:"light",alpha:1,visible:!0,mode:0,occlusion:!0};case"physical":return{...e,category:"physical",roughness:.2,metalness:.2,reflectivity:.2,type:"light",alpha:1,visible:!0,mode:0,occlusion:!0}}}(e):function(t){let e={alpha:1,mode:0,isMask:!1,visible:!0};switch(t){case"texture":return{...e,type:"texture",size:[128,128],blending:0,axis:"x",side:2,projection:0,texture:{image:"image_0",wrapping:1e3,repeat:[1,1],offset:[0,0]},crop:!1};case"video":return{...e,type:"video",size:[128,128],blending:0,axis:"x",side:2,projection:0,texture:{video:Dl.defaultVideo,wrapping:1001,repeat:[1,1],offset:[0,0]},crop:!1};case"color":return{...e,type:"color",color:sl.fromHex(xl)};case"depth":return{...e,type:"depth",gradientType:1,smooth:!1,isVector:!0,isWorldSpace:!1,origin:[0,0,0],direction:[1,0,0],colors:[[1,1,1,1],[0,0,0,1]],steps:[0,1],near:50,far:200};case"normal":return{...e,type:"normal",cnormal:[1,1,1]};case"gradient":return{...e,type:"gradient",gradientType:0,smooth:!1,colors:[[0,0,0,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]],steps:[0,1,1,1,1,1,1,1,1,1],num:2,angle:0,offset:[0,0],morph:[0,0]};case"noise":return{...e,type:"noise",size:[100,100,100],noiseType:0,scale:1,move:1,colorA:{...sl.fromHex(6710886),a:1},colorB:{...sl.fromHex(6710886),a:1},colorC:{...sl.fromHex(16777215),a:1},colorD:{...sl.fromHex(16777215),a:1},distortion:[1,1],fA:[1.7,9.2],fB:[8.3,2.8],voronoiStyle:0,highCut:1,lowCut:0,smoothness:.3,seed:0,quality:1};case"fresnel":return{...e,type:"fresnel",color:ll.fromHexAndA(16777215,1),bias:.1,scale:1,intensity:2,factor:1};case"rainbow":return{...e,type:"rainbow",filmThickness:30,movement:0,wavelengths:[0,0,0],noiseStrength:0,noiseScale:1,offset:[0,0,0]};case"toon":return{...e,type:"toon",positioning:2,colors:[[0,0,0,1],[.5,.5,.5,1],[.5,.5,.5,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]],steps:[0,.475,.525,1,1,1,1,1,1,1],num:4,source:[0,1e3,0],isWorldSpace:!0,noiseStrength:0,noiseScale:1,shadowColor:ll.fromHexAndA(0,0),offset:[0,0,0]};case"outline":return{...e,type:"outline",outlineColor:ll.fromHexAndA(0,1),contourColor:ll.fromHexAndA(0,1),outlineWidth:2,contourWidth:5,outlineThreshold:.4,contourThreshold:0,outlineSmoothing:0,contourFrequency:10,contourDirection:[0,1,0],positionalLines:!1,compensation:!0};case"matcap":return{...e,type:"matcap",texture:{image:"matcap_0",wrapping:1001,repeat:[1,1],offset:[0,0]}};case"transmission":return{...e,type:"transmission",thickness:10,ior:1.5,roughness:1};case"displace":return{visible:!0,type:"displace",displacementType:"noise",noiseType:0,scale:10,movement:1,offset:[0,0,0],intensity:8,voronoiStyle:0,smoothness:.3,seed:0,highCut:1,lowCut:0,quality:1};case"pattern":return{...e,type:"pattern",style:0,projection:0,axis:"y",blending:0,offset:[0,0],colorA:{...sl.fromHex(0),a:1},colorB:{...sl.fromHex(16777215),a:1},frequency:[10,10],size:.5,variation:0,smoothness:.5,zigzag:0,rotation:0,vertical:[0,1],horizontal:[0,1],sides:6}}}(t)}})(Ul||(Ul={})),(t=>{function e(t,e="layer1",n="layer2"){let r=new Ka;return r.push({fi:0,data:Ul.defaultData("light",t),id:e}),r.push({fi:1,data:Ul.defaultData("color"),id:n}),{layers:r}}t.isMergable=function(t){return!t.layers.some((t=>"texture"===t.data.type&&0!==t.data.projection||"depth"===t.data.type&&!t.data.isWorldSpace||"noise"===t.data.type||"displace"===t.data.type))},t.getHash=function(t){let e="";return t.layers.forEach((t=>{Object.entries(t.data).forEach((([t,n])=>{e+=`${t}${n}`,Array.isArray(n)?n.forEach((t=>e+=`${t}`)):"object"==typeof n?Object.values(n).forEach((t=>{e+="number"==typeof t?`${t.toFixed(4)}`:`${t}`})):e+=`${n}`}))})),e},t.defaultEmptyData=function(){return{layers:new Ka}},t.defaultData=function(t="layer1",n="layer2"){return e("phong",t,n)},t.withName=function(t,e){return{...t,name:e}},t.defaultTwoLayerData=e,t.defaultTwoLayerTextureData=function(t,e="phong",n="layer1",r="layer2"){let i=Ul.defaultData("texture");Object.assign(i.texture,{image:t});let a=new Ka;return a.push({fi:0,data:i,id:n}),a.push({fi:1,data:Ul.defaultData("light",e),id:r}),{layers:a}},t.defaultTwoLayerVideoTextureData=function(t,e="phong",n="layer1",r="layer2"){let i=Ul.defaultData("video");Object.assign(i.texture,{video:t});let a=new Ka;return a.push({fi:0,data:i,id:n}),a.push({fi:1,data:Ul.defaultData("light",e),id:r}),{layers:a}}})(kl||(kl={})),(Rl||(Rl={})).defaultData=function(){return{points:new Ka,roundness:0,shapeHoles:[],isClosed:!1}},(Fl||(Fl={})).defaultData=function(){return{points:new Ka,lastInsertionPlane:null,subdivisions:12,isClosed:!1}};var Hl,Wl={type:"Ellipse",width:50,height:50,spikes:16,angle:360,innerRadius:0};(Hl||(Hl={})).merge=function(t,e){let n={...t};return Ih.forEach((r=>{Object.assign(n,{[r]:e[r]??t[r]})})),n};var ql,$l,Xl,Yl,Kl,Zl,Ql,Jl,th,eh,nh,rh,ih,ah,sh,oh,lh,hh,dh,ch,uh,ph,fh,mh,gh,vh,yh,bh,xh,wh,_h,Sh,Ah,Oh,Mh,Ch,Ph,Dh,Th,zh,Eh,Lh={shape:Wl,depth:1,offset:0,bevel:50,bevelSides:6,angle:0,twist:0,startScale:1,endScale:1,capType:"flat"},Ih=["depth","offset","angle","twist","startScale","endScale"];function Nh(t){t.layers.forEach((t=>{if("depth"===t.type&&void 0!==t.colorA){let e=t.colorA,n=t.colorB,r=[[e.r,e.g,e.b,e.a],[n.r,n.g,n.b,n.a]],i=[0,1];for(let t=2;t<10;t++)r.push(r[1]),i.push(1);let a={...ka(Ds(t),"type","visible","isVector","isWorldSpace","origin","alpha","mode"),near:Math.max(0,t.near),far:Math.max(0,t.far),colors:r,steps:i,num:2,direction:[1,0,0],smooth:!1,gradientType:1};Object.assign(t,a)}else if("depth"===t.type&&1===t.gradientType&&(t.near<0||t.far<0)){let e={...Ds(t),near:Math.max(t.near,0),far:Math.max(t.far,0)};Object.assign(t,e)}}))}function jh(t,e){Object.values(t.shared.materials).forEach((t=>e(t)))}function Bh(t,e){t.scene.objects.traverse(((t,n)=>{"materials"in n?n.materials.forEach(((t,r)=>{void 0===t&&(n.materials[r]=kl.defaultData(),t=n.materials[r]),"string"!=typeof t&&e(t)})):"material"in n?"string"!=typeof n.material&&(void 0===n.material&&(n.material=kl.defaultData()),e(n.material)):"Mesh"===n.type&&(void 0===n.material&&(n.material=kl.defaultData()),e(n.material)),"overrides"in n&&Object.values(n.overrides).forEach((t=>{t.material&&"string"!=typeof t.material&&e(t.material)}))}))}function Uh(t){void 0===t.layers&&Object.assign(t,kl.defaultTwoLayerData("lambert"))}function kh(t){!t.layers||t.layers.forEach((t=>{if("depth"===t.type&&10===t.colors.length){let e=[...t.colors];e.push(t.colors[9]);let n=[...t.steps];n.push(t.steps[9]);let r={...Ds(t),colors:e,steps:n};Object.assign(t,r)}}))}function Rh(t){t.scene.objects.traverse(((t,e)=>{"materials"in e?e.materials.forEach((t=>{"string"!=typeof t&&kh(t)})):"material"in e&&"string"!=typeof e.material&&kh(e.material)})),Object.values(t.shared.materials).forEach((t=>kh(t)))}function Fh(t){t.layers&&t.layers.forEach((t=>{"depth"===t.type&&void 0!==t.num&&(t.colors=t.colors.slice(0,t.num),t.steps=t.steps.slice(0,t.num),delete t.num)}))}function Vh(t){t.layers&&t.layers.forEach((t=>{(function(t){return"displace"!==t.type})(t)&&void 0===t.isMask&&(t.isMask=!1),("texture"===t.type||"video"===t.type)&&void 0===t.blending&&(t.blending=0),("noise"===t.type||"displace"===t.type&&"noise"===t.displacementType)&&(void 0===t.voronoiStyle&&(t.voronoiStyle=0),void 0===t.highCut&&(t.highCut=1),void 0===t.lowCut&&(t.lowCut=0),void 0===t.smoothness&&(t.smoothness=.3),void 0===t.seed&&(t.seed=0),void 0===t.quality&&(t.quality=1))}))}function Gh(t){var e;let n=null==(e=t.layers.find((t=>"light"===t.type)))?void 0:e.data;if("basic"===(null==n?void 0:n.category)){let t=Ul.defaultData("light","phong"),e=n;Object.assign(e,t),e.visible=!1}}function Hh(t){jh(t,Gh),Bh(t,Gh)}function Wh(t){t.layers.forEach((t=>{"light"===t.type&&"toon"!==t.category&&void 0===t.occlusion&&(t.occlusion=!0)}))}function qh(t){t.layers&&t.layers.forEach((t=>{"light"===t.type&&void 0===t.bumpMapIntensity&&(t.bumpMapIntensity=5)}))}function $h(t,e){if(e<1&&(Bh(t,Nh),jh(t,Nh),t.schema=1),e<2&&(function(t){Object.assign(t.scene.publish,{orbitControls:{...gh.defaultData,...Ds(t.scene.publish.orbitControls)}})}(t),t.schema=2),e<3&&(function(t){function e(t){if(t.layers)for(let e of Object.values(t.layers))if(e)for(let[t,n]of Object.entries(e))if((Vl.includes(t)||"boolean"==typeof n)&&delete e[t],"texture"===t)for(let[e,r]of Object.entries(n))(Gl.includes(e)||"boolean"==typeof r)&&delete n[e]}t.scene.objects.traverse(((t,n)=>{n.states.forEach((t=>{let n=t;n.material?e(n.material):n.materials&&n.materials.forEach((t=>{e(t)}))}))}))}(t),t.schema=3),e<4&&(function(t){t.scene.publish.withBackground=!0}(t),t.schema=4),e<5&&(function(t){t.scene.publish.settings.web={compress:!0,preload:!0,preset:1,logo:!0,hint:!1}}(t),t.schema=5),e<6&&(function(t){t.scene.objects.traverse(((t,e)=>{let n=e.cloner;n&&(n.radial.scale=n.radial.scale.map((t=>t+1)),n.linear.scale=n.linear.scale.map((t=>t+1)))}))}(t),t.schema=6),e<7&&(function(t){t.scene.objects.traverse(((t,e)=>{let n=e.geometry;n&&("DodecahedronGeometry"===n.type||"IcosahedronGeometry"===n.type)&&(n.detail=Math.round(n.detail))}))}(t),t.schema=7),e<8&&(t.schema=8),e<9&&(Rh(t),t.schema=9),e<10&&(function(t){t.scene.objects.traverse(((t,e)=>{"Mesh"===e.type&&("BooleanGeometry"===e.geometry.type||"SubdivGeometry"===e.geometry.type)&&(e.geometry.phongAngle=35)}))}(t),t.schema=10),e<11&&(function(t){t.scene.environment.ambientLight.softShadows=!1,t.scene.environment.ambientLight.softShadowQuality="low",t.scene.objects.traverse(((t,e)=>{("DirectionalLight"===e.type||"SpotLight"===e.type)&&(e.shadowResolution=1024,e.shadowRadius=1,e.depth=1e5)})),t.shared.penumbraSize=new Array(5).fill(.5)}(t),t.schema=11),e<12&&(Rh(t),t.schema=12),e<13&&(function(t){t.shared.audios=Zt({},Ra.prototype)}(t),t.schema=13),e<14&&(function(t){let e=t.shared.materials;Object.entries(e).forEach((([t,n])=>{if(!n.layers){let n={name:"Untitled Material",layers:[{fi:0,data:{type:"light",category:"phong",alpha:.6,visible:!0,mode:0,specular:{r:.2,g:.2,b:.2},shininess:5},id:"layer1"},{fi:1,data:{type:"color",alpha:1,visible:!0,mode:0,color:{r:.2823529411764706,g:.2823529411764706,b:.30196078431372547}},id:"layer2"}]};Object.assign(e,{[t]:n})}}))}(t),t.schema=14),e<15&&(function(t){Object.entries(Ds(t.shared.images)).filter((t=>!1===t[1].asset)).map((t=>t[0])).forEach((e=>{delete t.shared.images[e]})),Object.entries(Ds(t.shared.audios)).filter((t=>!1===t[1].asset)).map((t=>t[0])).forEach((e=>{delete t.shared.audios[e]}))}(t),t.schema=15),e<16&&(function(t){t.scene.publish.settings.web.preload=!1}(t),t.schema=16),e<17&&(Bh(t,Fh),jh(t,Fh),t.schema=17),e<18&&(Bh(t,Uh),jh(t,Uh),t.schema=18),e<19&&(function(t){Object.assign(t.scene.publish.settings,{video:{...vh.defaultData.settings.video,...Ds(t.scene.publish.settings.video)}})}(t),t.schema=19),e<20&&(function(t){t.shared.fonts=Zt({},Ra.prototype)}(t),function(t){let e=[];t.scene.objects.traverse(((n,r)=>{let i=r;if("TextFrame"===i.type){let r=kl.defaultTwoLayerData("phong"),a="string"==typeof i.color?t.shared.colors[i.color]:i.color;r.layers[1].data.color={r:a.r,g:a.g,b:a.b},r.layers[1].data.alpha=i.alpha;let s=function(t){return t.replace(".typeface","").replace(/optimer/gi,"open sans").replace("space_mono","space mono").replace(/alma_mono/gi,"varela round").replace(/droid_sans_mono/gi,"noto sans mono").replace(/droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi,"roboto").replace(/droid_serif/gi,"roboto slab").replace("_sans"," sans").replace("crimson_text","crimson text").replace("medium_medium","medium").replace("fatface_fatface","fatface").replace("100hairline","thin").replace("200thin","extralight").replace("300light","light").replace("500medium","medium").replace("600semi","semibold").replace("800heavy","extrabold").replace("900black","black").replace(/bodoni_(11|16|24|36|48|72|96)([^_])/gi,"bodoni_$1_$2").replace(/bodoni_(11|16|24|36|48|72|96)/gi,"bodoni moda").replace(/(thin|hairline)(_regular)?/gi,"100").replace(/(extra|ultra)light(_regular)?/gi,"200").replace(/light(_regular)?/gi,"300").replace(/_book|_normal|_roman/gi,"_regular").replace(/medium(_regular)?/gi,"500").replace(/(semi|demi)bold(_regular)?/gi,"600").replace(/(extra|ultra)bold(_regular)?/gi,"800").replace(/bold(_regular)?/gi,"700").replace(/(black|heavy|fatface)(_regular)?/gi,"900").replace(/([1-9]00)_italic/gi,"$1italic").replace(/regularitalic/gi,"italic").replace(/regularitalic/gi,"italic").split(" ").map((t=>t.charAt(0).toUpperCase()+t.slice(1))).join(" ")}(i.font);void 0===t.shared.fonts[s]&&(t.shared.fonts[s]={name:s});let o={name:i.name,...ah.defaultData,...lh.defaultData,flatShading:!1,wireframe:!1,geometry:{...Xl.defaultData("TextGeometry"),width:i.width,height:i.height,font:s,depth:0,horizontalAlign:i.horizontalAlign,verticalAlign:i.verticalAlign,fontSize:1.40625*i.fontSize,lineHeight:i.lineHeight/1.40625,letterSpacing:i.letterSpacing-1,text:i.text,textTransform:i.textTransform,extrudeBevelSize:0,extrudeBevelSegments:1},material:r,states:Ds(i.states),events:Ds(i.events),visible:i.visible,raycastLock:i.raycastLock,position:i.position,rotation:i.rotation,scale:i.scale,hiddenMatrix:i.hiddenMatrix},l=Ds(t.scene.objects).parent(n);t.scene.objects.insertAfter(l??null,n,[{id:n+"new",data:o,children:[]}]),e.push(n)}})),e.forEach((e=>{t.scene.objects.delete(e)}))}(t),t.schema=20),e<21&&(function(t){let e={0:"MouseDown",1:"MouseUp",2:"MouseHover",5:"KeyDown",6:"KeyUp",7:"Start",9:"LookAt",10:"Follow",11:"Scroll",12:"Audio",13:"GameControl"};t.scene.objects.traverse(((t,n)=>{n.events.forEach((t=>{if(e[Number(t.type)])if(Object.assign(t,{type:e[Number(t.type)]}),"Audio"===t.type&&"audioEvent"in t&&(Object.assign(t,{playAudio:t.audioEvent}),delete t.audioEvent),"GameControl"===t.type)Object.assign(t,{gameActions:{idle:new Ka,move:new Ka,jump:new Ka}});else{let e=new Ka;Object.assign(t,{actions:e}),("MouseDown"===t.type||"MouseUp"===t.type||"KeyDown"===t.type||"KeyUp"===t.type)&&"url"in t&&e.push({fi:0,id:x.generateUUID(),data:{type:"Link",url:t.url,delay:0}}),"targets"in t&&(t.targets.forEach(((t,n,r)=>{let i={easing:t.easing,duration:t.duration};6===t.easing?Object.assign(i,ka(t,"mass","stiffness","damping","velocity")):5===t.easing&&Object.assign(i,{control1:{...t.control1},control2:{...t.control2}});let a={repeat:t.repeat?-1:0,delay:t.delay,delayDirection:t.delayDirection,direction:t.cycle&&t.rewind?"pingpong-rewind":t.cycle?"pingpong":"normal"},s={state:t.state,...a,...i},o={allowSlerp:!0,type:"Transition",object:t.object,repeat:0,delay:0,delayDirection:void 0,direction:"normal",tweens:new Ka({fi:0,id:x.generateUUID(),data:{state:void 0,repeat:0,delay:0,delayDirection:void 0,direction:"normal",duration:0,easing:4}},{fi:1,id:x.generateUUID(),data:s})};e.push({fi:r,id:n,data:o})})),delete t.targets)}}))}))}(t),function(t){t.scene.objects.traverse(((t,e)=>{function n(t,n){var r;let i=new Ka,a=[];if(e.events.forEach(((t,e,r)=>{if("Audio"===t.type&&t.trigger===n){let n;a.push(e),"play"===t.interaction?n={...ka(t,"interaction","audio","delay","volume","loop"),triggerAfter:"after"in t?t.after:void 0,toggle:"after"in t?t.toggle:void 0,type:"Audio"}:("pause"===t.interaction||"stop"===t.interaction)&&(n={...ka(t,"interaction","delay","object","playAudio"),type:"Audio"}),n&&i.push({fi:r,id:e,data:n})}})),a.forEach((t=>e.events.delete(t))),i.length){let n=null==(r=e.events.find((e=>e.type===t)))?void 0:r.data;n?"actions"in n&&n.actions.insertBefore(null,i):e.events.insertBefore(null,[{id:x.generateUUID(),data:{type:t,actions:i}}])}}n("Start","start"),n("MouseDown","mouseDown"),n("MouseUp","mouseUp"),n("KeyDown","keyDown"),n("KeyUp","keyUp")}))}(t),t.schema=21),e<22&&(Hh(t),t.schema=22),e<23&&(function(t){t.scene.objects.traverse(((t,e)=>{"Mesh"===e.type&&"SubdivGeometry"===e.geometry.type&&(e.geometry.scaleBaked||(e.geometry.scaleBaked=[1,1,1]))}))}(t),t.schema=23),e<24&&(function(t){t.scene.objects.traverse(((t,e)=>{("Empty"===e.type||"Mesh"===e.type)&&e.cloner&&!e.cloner.randomnessObject&&!e.cloner.toObject&&!e.cloner.randomness&&(e.cloner={...e.cloner,toObject:{object:"",spreadType:"random",scale:[0,0,0],rotation:[0,0,0],position:[0,0,0],axis:"x",seed:0,count:99,align:"normal"},randomness:!1,randomnessObject:{strength:100,scale:[0,0,0],rotation:[0,0,0],position:[0,0,0],movement:1,seed:0,freqScale:10,noiseType:"perlin"}})}))}(t),t.schema=24),(e<25||void 0===t.shared.videos)&&(function(t){t.shared.videos=Zt({},Ra.prototype)}(t),e<25&&(t.schema=25)),e<26&&(function(t){t.scene.objects.traverse(((e,n)=>{let r=t.scene.objects.unproxy().parent(e);if(r){let e=Ds(t.scene.objects.data(r));e&&"Mesh"===e.type&&"BooleanGeometry"===e.geometry.type&&"Mesh"===n.type&&(n.visible=!0!==Ds(n).booleanExclude)}}))}(t),t.schema=26),e<27&&(function(t){t.scene.objects.traverse(((t,e)=>{if("Mesh"===e.type){let t=e;"NonParametricGeometry"===e.geometry.type?void 0!==t.material&&delete t.material:void 0!==t.materials&&delete t.materials}}))}(t),t.schema=27),e<28&&(Hh(t),t.schema=28),e<29&&(function(t){function e(t){Object.setPrototypeOf(t,rs.prototype),t.texture&&Object.setPrototypeOf(t.texture,rs.prototype)}function n(t){Object.setPrototypeOf(t,rs.prototype);for(let n in t)e(t[n])}t.scene.objects.traverse(((t,e)=>{e.states.forEach((t=>{let e=t;if(e.material){let t=Ds(e.material).layers;n(t),e.material.layers=t}if(e.materials)for(let r=0;r<e.materials.length;r++){let t=e.materials[r],i=Ds(t).layers;n(i),t.layers=i}}))}))}(t),t.schema=29),e<30&&(function(t){t.scene.objects.traverse(((t,e)=>{"Mesh"===e.type&&"NonParametricGeometry"===e.geometry.type&&!("material"in e)&&!("materials"in e)&&(e.material=kl.defaultTwoLayerData("phong"))}))}(t),t.schema=30),e<31&&(function(t){void 0===t.scene.publish.orbitControls.autoZoom&&(t.scene.publish.orbitControls.autoZoom=!1),t.scene.objects.traverse(((t,e)=>{("OrthographicCamera"===e.type||"PerspectiveCamera"===e.type)&&(void 0===e.orthographic.autoZoom&&(e.orthographic.autoZoom=!1),void 0===e.orthographic.autoZoomFrustumSize&&(e.orthographic.autoZoomFrustumSize=790))}))}(t),t.schema=31),e<33&&(function(t){t.scene.objects.traverse(((t,e)=>{void 0===e.pathSnapping&&(e.pathSnapping={pathId:null,slide:0,offset:0,orientation:"tangential"}),void 0===e.pathSnapping.offset&&(e.pathSnapping.offset=0)}))}(t),t.schema=33),e<34&&(function(t){void 0===t.scene.publish.mouseEventTarget&&(t.scene.publish.mouseEventTarget="canvas"),void 0===t.scene.publish.settings.web.hint&&(t.scene.publish.settings.web.hint=!1)}(t),t.schema=34),e<35&&(function(t){let{video:e}=t.scene.publish.settings;"gif"===e.format&&e.fps>48&&(e.fps=15)}(t),t.schema=35),e<36&&(function(t){t.scene.objects.traverse(((t,e)=>{e.events.forEach((t=>{"GameControl"===t.type&&(t.resetYPosition=Math.abs(t.resetYPosition-e.position[1]))}))}))}(t),t.schema=36),e<37&&(function(t){let e=t.scene.environment.usePhysics;t.scene.objects.traverse(((t,n)=>{e&&null===n.physics?n.collision=!1:n.collision="visibility"}))}(t),t.schema=37),e<38&&(Bh(t,Vh),jh(t,Vh),t.schema=38),e<39&&(function(t){t.scene.objects.traverse(((t,e)=>{e.events.forEach((t=>{"GameControl"===t.type&&(t.navmesh=Eh.defaultDataThirdPerson.navmesh)}))}))}(t),t.schema=39),e<40&&(function(t){t.scene.styles||(t.scene.styles=xh.defaultData())}(t),t.schema=40),e<41&&(function(t){void 0===t.scene.environment.ambientLight.occlusion&&(t.scene.environment.ambientLight.occlusion=!1),void 0===t.scene.environment.ambientLight.aoFullRes&&(t.scene.environment.ambientLight.aoFullRes=!1),void 0===t.scene.environment.ambientLight.radius&&(t.scene.environment.ambientLight.radius=256),void 0===t.scene.environment.ambientLight.bias&&(t.scene.environment.ambientLight.bias=.5),void 0===t.scene.environment.ambientLight.aoColor&&(t.scene.environment.ambientLight.aoColor={r:.19607843137254902,g:.19607843137254902,b:.19607843137254902}),Bh(t,Wh),jh(t,Wh)}(t),t.schema=41),e<42&&(function(t){t.scene.objects.traverse(((t,e)=>{e.events.forEach((t=>{"GameControl"===t.type&&Object.assign(t.gameActions,{run:new Ka})}))}))}(t),t.schema=42),e<43&&(function(t){t.scene.objects.traverse(((t,e)=>{e.events.forEach((t=>{"GameControl"===t.type&&(t.keyAssignments=[...t.keyAssignments,["run",""],["none","Ctrl"]])}))}))}(t),t.schema=43),e<99){Bh(t,qh),jh(t,qh),null===t.scene.publish.playCamera&&(t.scene.publish.playCamera=yl);let e=Ds(t.scene.objects),n=t.scene.objects;t.scene.publish.playPage=bl,n.insertBefore(null,null,[{id:bl,data:{...ph.defaultData,backgroundColor:t.scene.backgroundColor,fog:t.scene.fog,postprocessing:t.scene.postprocessing,ao:ka(t.scene.environment.ambientLight,"occlusion","aoFullRes","radius","bias","aoColor"),publish:{playCamera:t.scene.publish.playCamera,gameControlObject:t.scene.publish.gameControlObject},shadow:ka(t.scene.environment.ambientLight,"softShadowQuality"),globalPhysics:{...th.defaultData,...ka(t.scene.environment,"usePhysics","gravity")},camera:Ds(t.scene.ownerCamera)??ph.defaultData.camera,name:"Scene"},children:[]}]);for(let t of e)t.id!==_h.TRASH_CAN_ID&&n.move(bl,t.fi,t.id);let r=0,i=0;t.shared.penumbraSize&&t.scene.objects.traverse(((e,n)=>{"DirectionalLight"===n.type?(n.penumbraSize=t.shared.penumbraSize[Math.min(r,2)],r+=1):"SpotLight"===n.type&&(n.penumbraSize=t.shared.penumbraSize[3+Math.min(i,1)],i+=1),(void 0===n.physics||null===n.physics)&&"Instance"!==n.type&&(n.physics={},Object.assign(n.physics,Al.defaultData)),void 0!==n.physics&&null!==n.physics&&(n.physics.enabled=n.collision??"visibility",delete n.collision)})),t.schema=99}}function Xh(t){t.layers&&t.layers.forEach((t=>{"light"===t.type&&void 0===t.alphaOverride&&(t.alphaOverride=1)}))}(t=>{t.is2DParametricMesh=function(t){return"PolygonGeometry"===t||"RectangleGeometry"===t||"StarGeometry"===t||"TriangleGeometry"===t||"EllipseGeometry"===t},t.isParametricMesh=function(t){return"PolygonGeometry"===t||"PolygonGeometry"===t||"RectangleGeometry"===t||"StarGeometry"===t||"TriangleGeometry"===t||"EllipseGeometry"===t||"PathGeometry"===t||"VectorGeometry"===t||"ConeGeometry"===t||"CubeGeometry"===t||"CylinderGeometry"===t||"DodecahedronGeometry"===t||"HelixGeometry"===t||"IcosahedronGeometry"===t||"LatheGeometry"===t||"PyramidGeometry"===t||"SphereGeometry"===t||"PlaneGeometry"===t||"BackdropGeometry"===t||"TorusGeometry"===t||"TorusKnotGeometry"===t||"BooleanGeometry"===t||"TextGeometry"===t}})(ql||(ql={})),($l||($l={})).merge=function(t,e){let n={...t};return Object.assign(n,e),"PathGeometry"===n.type&&"extrusion"in e&&e.extrusion&&(n.extrusion={...t.extrusion},Object.assign(n.extrusion,Hl.merge(n.extrusion,e.extrusion))),n},(Xl||(Xl={})).defaultData=function(t){if("RectangleGeometry"===t)return{width:320,height:320,type:t,cornerRadius:[0,0,0,0],cornerType:0,depth:0,extrudeBevelSize:0,extrudeBevelSegments:1};if("PathGeometry"===t)return{type:t,width:1,height:1,depth:1,path:Fl.defaultData(),extrusion:Lh};if("VectorGeometry"===t)return{width:1,height:1,type:t,subdivisions:12,shape:Rl.defaultData(),depth:0,extrudeBevelSize:0,extrudeBevelSegments:1};if("BooleanGeometry"===t)return{type:t,operation:2,width:0,height:0,depth:0,phongAngle:35};if("TextGeometry"===t)return{type:t,width:100,height:100,depth:0,horizontalAlign:1,verticalAlign:1,fontSize:16,lineHeight:1.2,letterSpacing:0,text:{textValue:""},textTransform:1,font:"Roboto_regular",extrudeBevelSize:0,extrudeBevelSegments:1};if("SphereGeometry"===t)return{type:"SphereGeometry",width:100,height:100,depth:100,widthSegments:64,heightSegments:64,phiStart:0,phiLength:2*Math.PI,thetaStart:0,thetaLength:180};throw new Error("not implemented")},(Yl||(Yl={})).defaultData={enabled:!1,useBackgroundColor:!1,color:sl.white,near:.1,far:2e3},(t=>{let e={opacity:1,blendFunction:13,enabled:!1};(Kl||(Kl={})).defaultData={enabled:!1,pixelation:{...e,blendFunction:16,granularity:15},bloom:{...e,blendFunction:16,intensity:1,blurScale:1,luminanceThreshold:.25,luminanceSmoothing:.025,kernelSize:3},chromaticAberration:{...e,offset:[2,2]},vignette:{...e,darkness:1,offset:0},hueSaturation:{...e,hue:3,saturation:0},brightnessContrast:{...e,brightness:.25,contrast:0},depthOfField:{...e,focalLength:2,focusDistance:2,bokehScale:2},noise:{...e,blendFunction:16}}})(),(Zl||(Zl={})).defaultData={softShadowQuality:"low"},(Ql||(Ql={})).defaultData={enabled:!0,color:{r:.8274509803921568,g:.8274509803921568,b:.8274509803921568},intensity:.75},(Jl||(Jl={})).defaultData={occlusion:!1,aoFullRes:!1,radius:256,bias:.5,aoColor:{r:.19607843137254902,g:.19607843137254902,b:.19607843137254902}},(th||(th={})).defaultData={usePhysics:!1,gravity:-10},(eh||(eh={})).defaultData={playCamera:yl,gameControlObject:null},(nh||(nh={})).defaultData={backgroundColor:ll.fromHexAndA(2960946,1),postprocessing:Kl.defaultData,fog:Yl.defaultData,globalPhysics:th.defaultData,ambient:Ql.defaultData,ao:Jl.defaultData,shadow:Zl.defaultData,publish:eh.defaultData},(t=>{t.isComponentRelated=function(t){return"Component"===t||"Instance"===t},t.isEmptyOrComponent=function(t){return"Empty"===t||"Instance"===t}})(rh||(rh={})),(t=>{t.identity={...hl.identity,hiddenMatrix:il.identity},t.fromObject=function(t){return{position:t.position,rotation:t.rotation,scale:t.scale,hiddenMatrix:t.hiddenMatrix}},t.merge=function(t,e){return{position:(null==e?void 0:e.position)||t.position,rotation:(null==e?void 0:e.rotation)||t.rotation,scale:(null==e?void 0:e.scale)||t.scale,hiddenMatrix:(null==e?void 0:e.hiddenMatrix)||t.hiddenMatrix}},t.diff=function(t,e){return function(t){for(let e of Object.keys(t))void 0===t[e]&&delete t[e];return t}({position:el.isEqual(t.position,e.position)?void 0:e.position,rotation:el.isEqual(t.rotation,e.rotation)?void 0:e.rotation,scale:el.isEqual(t.scale,e.scale)?null:e.scale,hiddenMatrix:il.isEqual(t.hiddenMatrix,e.hiddenMatrix)?void 0:e.hiddenMatrix})}})(ih||(ih={})),(ah||(ah={})).defaultData={states:new Ka,events:new Ka,visible:!0,raycastLock:!1,physics:Al.defaultData,pathSnapping:{pathId:null,slide:0,offset:0,orientation:"tangential"},...ih.identity,cloner:null},(sh||(sh={})).defaultData={type:"Empty",...ah.defaultData},(oh||(oh={})).defaultData={type:"Component",...ah.defaultData},(lh||(lh={})).defaultData={type:"Mesh",...ah.defaultData,...Cl.defaultData},(hh||(hh={})).defaultData={...ah.defaultData,...ih.identity,position:[0,0,ml.DefaultTargetOffset],...ml.defaultData},(t=>{t.defaultData=function(t){return{...ah.defaultData,...Sl.defaultData(t)}},t.defaultDirectionalLightData={...t.defaultData("DirectionalLight"),position:[200,300,300],name:"Directional Light",intensity:.7}})(dh||(dh={})),(t=>{function e(t,e,n=0){for(;n<e.length;){let r=t?t[e[n]]:void 0;if(e.length===n+1)return r;if(!r)return;t=r.descendants,n+=1}}t.resolveWithDes=e,t.resolve=function(t,n,r=0){let i=e(t,n,r);if(i){let t=Object.keys(i);if(1===t.length&&"descendants"===t[0])return}return i}})(ch||(ch={})),(t=>{function e(t,e){return{...ah.defaultData,...e,component:t,overrides:new rs,physics:void 0,events:void 0,type:"Instance"}}t.rootOverrideProps=["physics","events"],t.compositeNonOptionalOverrideProps=["geometry"],t.compositeEntireOverrideOverrideProps=["material"],t.ofComponent=e,t.fromComponentData=function(t){let n=ih.fromObject(t.data);return e(t.id,n)}})(uh||(uh={})),(ph||(ph={})).defaultData={type:"Page",...ah.defaultData,physics:{...Al.defaultData,fusedBody:!1},...nh.defaultData,camera:hh.defaultData},(t=>{t.defaultCamera={position:[0,0,1e3],scale:[1,1,1],rotation:[0,0,0],hiddenMatrix:il.identity,name:"Play Camera",visible:!0,raycastLock:!1,physics:Al.defaultData,states:new Ka,events:new Ka,cloner:null,pathSnapping:{pathId:null,orientation:"tangential",slide:0,offset:0},...ml.defaultData},t.KeysByResetCategory={States:["states"],Events:["events"],Material:["material","materials"],Geometry:["geometry"],Position:["position"],Rotation:["rotation"],Scale:["scale"],Transform:["position","scale","rotation","hiddenMatrix"],Name:["name"],Visibility:["visible","raycastLock","flatShading","wireframe","side"],Shadows:["castShadow","receiveShadow"],Cloner:["cloner"],Physics:["physics"]},t.defaultMeshObject={name:"Rectangle",...ah.defaultData,...lh.defaultData,geometry:Xl.defaultData("RectangleGeometry"),material:kl.defaultTwoLayerData("phong","layer1","layer2")},t.defaultBooleanObject={name:"Boolean",...ah.defaultData,...lh.defaultData,geometry:Xl.defaultData("BooleanGeometry"),material:kl.defaultTwoLayerData("phong","layer1","layer2")},t.defaultTextObject={name:"Text",...ah.defaultData,...lh.defaultData,geometry:Xl.defaultData("TextGeometry"),material:kl.defaultTwoLayerData("phong","layer1","layer2")}})(fh||(fh={})),(t=>{t.newEmpty=function(t,e){let n={name:e};return"Mesh"===t.type?(n.geometry={},"material"in t&&(n.material={layers:new rs}),"materials"in t&&(n.materials=t.materials.map((t=>({layers:new rs}))))):fl.is(t.type)&&(n.perspective={},n.orthographic={}),n},t.toOps=function(t,e){let n,r=[],i={orthographic:0,perspective:0,geometry:0};function a(t,e){for(let[n,i]of Object.entries(e.layers)){let{texture:e,...a}=i;if(void 0!==e&&Object.keys(e).length>0){let i={path:[...t,"layers",n,"texture"],props:e,type:0};r.push(i)}if(Object.keys(a).length>0){let e={path:[...t,"layers",n],props:a,type:0};r.push(e)}}}for(let[s,o]of Object.entries(e))if("name"!==s)if("cloner"===s)r.push(...vl.toOps(o,["cloner"]));else if("pathSnapping"===s)r.push({path:[s],props:{slide:o.slide,offset:o.offset},type:0});else if("material"===s)a(["material"],o);else if("materials"===s)for(let[t,e]of Object.entries(o))a(["materials",t],e);else if(0===i[s]){if("geometry"===s&&void 0!==o.extrusion){let t={path:[s,"extrusion"],props:o.extrusion,type:0};r.push(t),o={...o},delete o.extrusion}if(Object.keys(o).length>0){let t={path:[s],props:o,type:0};r.push(t)}}else void 0===n&&(n={path:[],props:{},type:0},r.push(n)),n.props[s]=o;return r},t.patch=function(t,e){var n,r,i,a,s,o;if(void 0===e)return t;let l={...t};if(Object.assign(l,ih.merge(l,e)),Object.assign(l,{pathSnapping:Object.assign({},l.pathSnapping,{slide:(null==(n=e.pathSnapping)?void 0:n.slide)??(null==(r=l.pathSnapping)?void 0:r.slide)??0,offset:(null==(i=e.pathSnapping)?void 0:i.offset)??(null==(a=l.pathSnapping)?void 0:a.offset)??0})}),fl.is(t.type)){l.orthographic={...l.orthographic},l.perspective={...l.perspective};let t=e;void 0!==(null==(s=t.orthographic)?void 0:s.zoom)&&(l.orthographic.zoom=t.orthographic.zoom),void 0!==(null==(o=t.perspective)?void 0:o.zoom)&&(l.perspective.zoom=t.perspective.zoom),void 0!==t.isUpVectorFlipped&&(l.isUpVectorFlipped=t.isUpVectorFlipped),void 0!==t.targetOffset&&(l.targetOffset=t.targetOffset)}else if("Mesh"===t.type)"geometry"in e&&Object.assign(l,{geometry:$l.merge(l.geometry,e.geometry)}),(e.material||e.materials)&&(l=function(t,e){if(void 0===e)return t;let n={...t};return"material"in n&&"material"in e&&e.material&&(n.material=Ps(n.material,(t=>{if("string"!=typeof t)for(let[n,r]of Object.entries(e.material.layers)){let e=t.layers.data(n);e&&Ul.patch(e,r)}})).data),n.materials&&e.materials&&(n.materials=Ps(n.materials,(t=>{var r,i;for(let a=0;a<n.materials.length;a++){let n=e.materials[a];if("string"!=typeof n)for(let[e,s]of Object.entries(n.layers)){let n=null==(i=null==(r=t[a])?void 0:r.layers)?void 0:i.data(e);n&&Ul.patch(n,s)}}})).data),n}(l,e)),l.cloner&&"cloner"in e&&Object.assign(l,{cloner:gl.merge(l.cloner,e.cloner)});else if("Empty"===t.type)l.cloner&&"cloner"in e&&Object.assign(l,{cloner:gl.merge(l.cloner,e.cloner)});else if(_l.is(t.type)){let t=e;void 0!==t.intensity&&(l.intensity=t.intensity),void 0!==t.color&&("string"==typeof t.color?l.color=t.color:l.color=sl.clone(t.color))}return l}})(mh||(mh={})),(gh||(gh={})).defaultData={enablePan:!0,enableZoom:!0,enableRotate:!0,enableDamping:!0,rotationLimitsMode:0,rotationVerticalOffset:{min:Math.PI/4,max:Math.PI/4},rotationHorizontalOffset:{min:Math.PI/4,max:Math.PI/4},rotationSoftLimit:2,panLimitsMode:0,panVerticalOffset:{min:250,max:250},panHorizontalOffset:{min:250,max:250},panSoftLimit:2,zoomLimitsEnabled:!1,zoomLimits:{min:.1,max:2},autoRotate:!1,autoRotateSpeed:2,autoRotateClockwise:!0,hoverRotatePanMode:0,hoverRotatePanStrength:20,hoverRotateDamping:.125,isTouchZoom:!0,orbitTouches:2,panTouches:3,resetHoverEffectOnPointerLeave:!0},(vh||(vh={})).defaultData={orbitControls:gh.defaultData,playPage:bl,withBackground:!0,preventScroll:!1,preventTouchScroll:!1,hideCursor:!1,mouseEventTarget:"canvas",joystickSizeAndXYOffset:Array(12).fill(0).map(((t,e)=>{let n=0,r=0;return e<5?r=-30:e<10&&(r=30),0===e||10===e||5===e?n=30:(4===e||11===e||9===e)&&(n=-30),[120,[n,r],"show"]})),settings:{image:{format:"jpg",ratio:1},video:{format:"mp4",imageFormat:"jpg",fps:30,mbps:80,ratio:Math.max(1,typeof window<"u"?Math.floor(window.devicePixelRatio):1),stopMode:"manual",duration:5e3},web:{logo:!0,compress:!0,preset:1,preload:!0,hint:!1}},stopRaycast:!0,hdTransmission:!1},(yh||(yh={})).defaultData={id:"basic",label:"Basic",style:"None",prompt:""},(bh||(bh={})).defaultData={weather:0,shadows:0,lightOrigin:0,temperature:0,sun:0,camera:0,environment:0,particles:0,nature:0,floor:0},(t=>{t.defaultData=()=>({mode:"line-art-both",prompt:"",negativePrompt:"",style:{...yh.defaultData},isRandomSeed:!0,seed:t.generateSeed(),guessMode:!1,advanced:!1,steps:20,guidanceScale:7.5,controlNetScale:1,modifiers:bh.defaultData}),t.generateSeed=()=>Math.round(1e5*Math.random())})(xh||(xh={})),(t=>{t.physicsEnabled=function(t){return void 0!==t.find((t=>"Page"===t.data.type&&t.data.globalPhysics.usePhysics))},t.traverseModuleInstances=function(t,e,n){t.scene.objects.traverseFrom(e,((e,r)=>{var i;if("Instance"===r.type){let a=null==(i=Qh.getComponentData(t,r.component))?void 0:i.data;a&&n(e,r,a.events)}else n(e,r,r.events)}))}})(wh||(wh={})),(t=>{function e(t={withLight:!0,withSquare:!0}){let e=[],n=fh.defaultMeshObject;!0===t.withLight&&e.push({fi:-1,data:dh.defaultDirectionalLightData,id:"830a2708-8ed9-49cf-a68e-085299899103",children:[]}),!0===t.withSquare&&e.push({fi:1,id:"7ba78968-2a55-48f2-b14c-5191da3e075e",data:n,children:[]});let r=new Ya;return r.push({fi:1,id:bl,data:{...ph.defaultData,name:"Scene 1"},children:e}),r}function n(e){return{...t.defaultData,objects:Zt(e,Ya.prototype)}}t.TRASH_CAN_ID="830a2708-8ed9-49cf-a68e-085299892222",t.defaultData={objects:e(),publish:vh.defaultData,styles:xh.defaultData()},t.emptyDataWithoutPage=function(){return{objects:new Ya,publish:vh.defaultData,styles:xh.defaultData()}},t.emptyDataWithPage=function(t){return{objects:e(t),publish:vh.defaultData,styles:xh.defaultData()}},t.withObjs=n,t.withObj=function(t,e){return n([{id:t,data:e,children:[],fi:0}])}})(_h||(_h={})),(Sh||(Sh={})).defaultData={preset:"fullscreen",allowResponsive:!1,size:[512,512],coords:[0,0],sceneScale:1,color:{r:0,g:0,b:0,a:.5}},(Ah||(Ah={})).emptyImage={data:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=",name:"empty"},(t=>{function e(t){return void 0!==t.textValue}function n(t){return"boolean"==typeof t}t.isTextValue=e,t.isNumber=function(t){return"number"==typeof t},t.isBoolean=n,t.typeOfVariable=function(t){return e(t)?"string":n(t)?"boolean":"number"},t.getDisplayedValue=function(e){return t.isTextValue(e)?Array.isArray(e.textValue)?e.textValue.map((t=>t.toString().padStart(e.padding??2,"0"))).join(e.deliminator??":")+(void 0!==e.suffix?" "+e.suffix:""):e.textValue.toString():t.isBoolean(e)?e?"True":"False":t.isNumber(e)?parseFloat(e.toFixed(3)).toString():e.toString()}})(Oh||(Oh={})),(Mh||(Mh={})).all=["images","videos","colors","audios","fonts","materials","variables"],(Ch||(Ch={})).all=[...Mh.all,"components"],(Ph||(Ph={})).defaultData=function(){return{images:new Ra,videos:new Ra,colors:new Ra,audios:new Ra,fonts:new Ra,materials:new Ra,components:new Ra,variables:new Ra}},(Dh||(Dh={})).defaultData=function(){return{images:new Ra,videos:new Ra,colors:new Ra,audios:new Ra,fonts:new Ra,materials:new Ra,components:new Ra,variables:new Ra}},(t=>{t.defaultColors=function(){let t={"89b10010-844c-11ec-a8a3-0242ac120002":{r:.5,g:.5,b:.5,a:1,name:"Default Color"}};return Zt(t,Ra.prototype)},t.defaultImages=function(t){let e={};return(null==t?void 0:t.withAITexture)&&(e["a1b10010-844c-a8a3-11ec-0242ac2011ec"]={...Ah.emptyImage,name:"AI generated image"}),Zt(e,Ra.prototype)},t.emptyData=function(){return{catelogs:new Ra,materials:new Ra,images:new Ra,videos:new Ra,colors:new Ra,audios:new Ra,fonts:new Ra,variables:new Ka,lib:Dh.defaultData()}},t.defaultVariables=function(t){switch(t){case"number":return{value:0,name:"Number"};case"boolean":return{value:!1,name:"Boolean"};case"string":return{value:{textValue:"String value"},name:"String"};case"time":let e=[0,0,0];return{name:"Time",value:{textValue:e,deliminator:":",padding:2,suffix:"AM"},dynamicVariableType:"time",format:"HH:mm:ss",format12h24h:"12ampm",timeZone:null,hasEnd:!1,endValue:{textValue:e,deliminator:":",padding:2,suffix:"AM"},autoStart:!0,repeat:!1};case"counter":return{name:"Counter",value:0,dynamicVariableType:"counter",updateInterval:1e3,increment:1,autoStart:!0,hasEnd:!0,endValue:60,repeat:!0,randomStart:!1,range:[0,100],decimals:0};case"random":return{name:"Random",value:0,dynamicVariableType:"random",updateInterval:1e3,increment:1,autoStart:!0,isStatic:!1,hasEnd:!0,endValue:60,repeat:!0,min:0,max:100,decimals:0};default:console.error("Unknown variable type",t)}},t.getFormattedTimerTime=function(t,e){if("HH:mm:ss"===e.format){let e=Math.floor(t/3600),n=Math.floor((t-3600*e)/60);return{textValue:[e,n,Math.round(t-3600*e-60*n)]}}if("mm:ss"===e.format){let e=Math.floor(t/60);return{textValue:[e,Math.round(t-60*e)]}}return t="number"===e.format?Math.round(t):Math.round(1e3*t)/1e3}})(Th||(Th={})),(zh||(zh={})).list=["idle","move","jump","run"],(t=>{t.defaultColliderData={type:"capsule",height:200,radius:50,position:[0,0,0],rotation:[0,0,0]},t.defaultDataThirdPerson={moveMode:"walk",forwardDirection:"+z",speedTranslate:1e3,speedRotate:100,runMultiplier:2,rotationMode:"normal",rotBy:"keys",rotByTouch:"drag",delayPos:[.3,.3],delayRot:[.3,.3],keyAssignments:[["moveNegZ","W"],["moveNegX","A"],["movePosZ","S"],["movePosX","D"],["rotPosX",""],["rotPosY",""],["rotNegX",""],["rotNegY",""],["jump","Space"],["run",""],["none","Ctrl"]],touchControl:!0,joystickPosLoc:5,joystickRotLoc:11,jumpTouchButtonLoc:9,collider:t.defaultColliderData,colliderHelperVisible:!0,collisionEnabled:!0,jumpPower:100,resetYPosition:3e3,alignToGround:!1,autoOrientMove:!0,orientWith:"camera",orientMode:"radial",delayPosCamera:.3,delayRotCamera:.3,camera:"",cameraXAxis:"Limit",cameraYAxis:"Free",cameraRotXLimits:[0,Math.PI/2],cameraRotYLimits:[-Math.PI/2,Math.PI/2],gameActions:{idle:new Ka,move:new Ka,jump:new Ka,run:new Ka},navmesh:{enabled:!1,ch:6,cs:6,walkableClimb:5,walkableHeight:1,walkableRadius:0,zones:"all",objects:[],helperVisible:!0,destinationHelperRadius:0,destinationHelperColor:ll.fromHexAndA(3728051,1)}}})(Eh||(Eh={}));var Yh=180/Math.PI;function Kh(t){t.rotation=t.rotation.slice(0,3).map((t=>t*Yh))}function Zh(t){var e,n;Kh(t),"Page"===t.type&&Kh(t.camera),null==(e=t.states)||e.forEach((t=>{void 0===t.rotation||null===t.rotation||(t.rotation=t.rotation.slice(0,3).map((t=>t*Yh)))}));let r=t.geometry;r&&"SphereGeometry"===r.type&&(r.thetaLength=r.thetaLength*Yh),r&&"TorusGeometry"===r.type&&(r.arc=r.arc*Yh),r&&"PathGeometry"===r.type&&(r.extrusion.angle*=Yh,r.extrusion.twist*=Yh),"Mesh"===t.type&&"TextGeometry"===t.geometry.type&&(t.geometry.text={textValue:t.geometry.text}),Array.isArray(Ds(t.events))&&(null==(n=t.events)||n.forEach((t=>{("MouseDown"===t.type||"MouseUp"===t.type||"MousePress"===t.type||"KeyDown"===t.type||"KeyUp"===t.type||"KeyPress"===t.type||"Collision"===t.type||"Trigger"===t.type)&&(t.runMode=t.toggle?"Toggle":"Once")})))}var Qh,Jh=107;function td(t,e){e(t.data);for(let n of t.children)td(n,e)}function ed(t){let e=t.schema??104;e!==Jh&&e<105&&(td(t.asset,Zh),t.schema=105)}function nd(t){let e=t.schema??0;if(e!==Jh){console.warn("updating from ",e,"to ",Jh),$h(t,e),e<100&&(void 0===t.scene.publish.joystickSizeAndXYOffset&&(t.scene.publish.joystickSizeAndXYOffset=vh.defaultData.joystickSizeAndXYOffset),t.schema=100),e<101&&(Bh(t,Xh),jh(t,Xh),t.schema=101),e<102&&(function(t){t.scene.objects.traverse(((t,e)=>{let n=e.geometry;n&&"PathGeometry"===n.type&&(n.extrusion.capType="flat",n.extrusion.bevel=50,n.extrusion.bevelSides=6,"Custom"===n.extrusion.shape.type&&(n.extrusion.shape.shapeQuality="low"))}))}(t),t.schema=102),e<104&&(t.shared.catelogs=new Ra,t.shared.lib=Dh.defaultData(),t.schema=104),e<105&&(function(t){t.shared.variables=Zt({},Ra.prototype)}(t),t.scene.objects.traverse(((t,e)=>{Zh(e)})),t.schema=105);for(let e of Object.values(t.shared.lib.components))ed(e);e<106&&(function(t){let e=Ds(t.shared.variables);t.shared.variables=Zt(Object.entries(e??{}).map((([t,e],n)=>({fi:n,id:t,data:e}))),Ka.prototype)}(t),t.schema=106),e<107&&(t.shared.lib.variables=Dh.defaultData().variables,t.schema=107)}}(t=>{t.defaultData={schema:Jh,scene:_h.defaultData,frames:(new Ra).add("72fc2993-2da3-4b6b-96ac-2879db3a28bd",Sh.defaultData),shared:{...Th.emptyData(),colors:Th.defaultColors()}},t.emptyDataForImports=function(t){let e=_h.emptyDataWithPage(t);return{schema:Jh,scene:e,frames:(new Ra).add("72fc2993-2da3-4b6b-96ac-2879db3a28bd",Sh.defaultData),shared:{...Th.emptyData(),colors:Th.defaultColors(),images:Th.defaultImages(t)}}},t.emptyData=function(){return{schema:Jh,scene:_h.emptyDataWithPage(),frames:(new Ra).add("72fc2993-2da3-4b6b-96ac-2879db3a28bd",Sh.defaultData),shared:Th.emptyData()}},t.collabHelper={...ns,updateSchema:t=>(t.schema??0)<Jh?Ps(t,nd):(t.schema??0)-Jh},t.updateSchemaDirectly=function(e){let n=t.collabHelper.updateSchema(e);return"number"==typeof n?0===n?e:null:n.data},t.withoutLib=function(t){return{...t,shared:{...t.shared,lib:Dh.defaultData()}}},t.getComponentData=function(t,e){let n=t.scene.objects.get(e);if(n&&"Component"===n.data.type)return n;{let n=t.shared.lib.components[e];if(n)return n.asset}}})(Qh||(Qh={}));var rd=Ht(Wt()),id=.5*(Math.sqrt(3)-1),ad=(3-Math.sqrt(3))/6,sd=1/6,od=t=>0|Math.floor(t),ld=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]),hd=new Float64Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]);function dd(t=Math.random){let e=cd(t),n=new Float64Array(e).map((t=>ld[t%12*2])),r=new Float64Array(e).map((t=>ld[t%12*2+1]));return function(t,i){let a,s,o=0,l=0,h=0,d=(t+i)*id,c=od(t+d),u=od(i+d),p=(c+u)*ad,f=t-(c-p),m=i-(u-p);f>m?(a=1,s=0):(a=0,s=1);let g=f-a+ad,v=m-s+ad,y=f-1+2*ad,b=m-1+2*ad,x=255&c,w=255&u,_=.5-f*f-m*m;if(_>=0){let t=x+e[w];_*=_,o=_*_*(n[t]*f+r[t]*m)}let S=.5-g*g-v*v;if(S>=0){let t=x+a+e[w+s];S*=S,l=S*S*(n[t]*g+r[t]*v)}let A=.5-y*y-b*b;if(A>=0){let t=x+1+e[w+1];A*=A,h=A*A*(n[t]*y+r[t]*b)}return 70*(o+l+h)}}function cd(t){let e=new Uint8Array(512);for(let n=0;n<256;n++)e[n]=n;for(let n=0;n<255;n++){let r=n+~~(t()*(256-n)),i=e[n];e[n]=e[r],e[r]=i}for(let n=256;n<512;n++)e[n]=e[n-256];return e}var ud,pd=new a,fd=Ht(qt()),md=new s,gd=new s,vd=new s;(ud||(ud={})).is=function(t){return t&&t.__isSPEObject};var yd,bd=t=>class extends t{constructor(){super(...arguments),this.previousModelViewMatrix=new s,this.copyPreviousMatrix=!0,this.hiddenMatrix=new s,this.matrixWorldRigid=new s,this.shearScale=new s,this.shearScaleInv=new s}get __isSPEObject(){return!0}isDescendantOf(t){t instanceof d&&(t=t.uuid);let e=this;for(;e.parent;){if(e.parent.uuid===t)return!0;e=e.parent}return!1}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.multiplyMatrices(this.hiddenMatrix,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.hiddenMatrix),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);for(let e of this.children)e.updateMatrixWorld(t)}updateWorldMatrix(t,e){let n=this.parent;if(t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.multiplyMatrices(this.hiddenMatrix,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.hiddenMatrix),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),e)for(let r of this.children)r.updateWorldMatrix(!1,!0)}traverseChildren(t,e=0){for(let n of this.children)ud.is(n)&&n.traverseObject(t,e+1)}traverseObject(t,e=0){if(!0!==t(this,e))for(let n of this.children)ud.is(n)&&n.traverseObject(t,e+1)}updateMatrixWorldSVD(){let t=this.matrixWorld.elements,e=[[t[0],t[4],t[8]],[t[1],t[5],t[9]],[t[2],t[6],t[10]]],{u:n,v:r,q:i}=(0,fd.SVD)(e),a=md.set(n[0][0],n[0][1],n[0][2],0,n[1][0],n[1][1],n[1][2],0,n[2][0],n[2][1],n[2][2],0,0,0,0,1),s=gd.set(r[0][0],r[0][1],r[0][2],0,r[1][0],r[1][1],r[1][2],0,r[2][0],r[2][1],r[2][2],0,0,0,0,1),o=vd.copy(s).transpose();this.shearScale.makeScale(i[0],i[1],i[2]).multiply(o).premultiply(s),this.shearScaleInv.copy(this.shearScale).invert(),this.matrixWorldRigid.multiplyMatrices(a,o).copyPosition(this.matrixWorld),i.every((t=>Math.abs(i[0]-t)<.01))?this.hasNonUniformScale=!1:this.hasNonUniformScale=!0}attach(t,e){this.updateWorldMatrix(!0,!1);let n=(new s).copy(this.matrixWorld).invert();return null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),n.multiply(t.parent.matrixWorld)),"hiddenMatrix"in t&&t.hiddenMatrix instanceof s?t.hiddenMatrix.premultiply(n):t.applyMatrix4(n),t.updateWorldMatrix(!1,!1),this.add(t),void 0!==e&&(this.children.pop(),this.children.splice(e,0,t)),this}copy(t,e=!1){return super.copy(t,e),this.hasNonUniformScale=t.hasNonUniformScale,this}onAfterRender(t,e,n,r,i,a){this.copyPreviousMatrix&&this.previousModelViewMatrix.copy(this.modelViewMatrix)}},xd=class extends(bd(d)){},wd=class extends xd{constructor(t){super(),this.object=t,this.matrixAutoUpdate=!1,this.hasNonUniformScale=t.hasNonUniformScale}raycast(t,e){}expand(){let t=0,e=this.object.entityChildren(t);for(;e;){let n=this.children[t];(null==n?void 0:n.object)!==e&&(n&&this.remove(n),n=new wd(e),this.add(n),this.children.splice(t,0,this.children.pop()),n.matrixWorldNeedsUpdate=!0,n.matrixAutoUpdate=!1,n.matrix=e.matrix,n.hiddenMatrix=e.hiddenMatrix),n.expand(),t+=1,e=this.object.entityChildren(t)}for(;this.children.length>t;)this.remove(this.children[t])}get visible(){var t;return void 0!==this.playModeVisible?this.playModeVisible:this.object.visible||this.object.dataPatched.visible&&!0===(null==(t=this.object.dataPatched.cloner)?void 0:t.hideBase)}set visible(t){}get castShadow(){return this.object.castShadow}set castShadow(t){}get receiveShadow(){return this.object.receiveShadow}set receiveShadow(t){}get isMesh(){return(t=>"Mesh"===t.type)(this.object)}get isLight(){return this.object.isLight}get layers(){return this.object.layers}set layers(t){}get isCamera(){return!1}get geometry(){if(this.object.geometry)return this.object.geometry}get material(){if(this.object.material)return this.object.material}},_d=new o,Sd=new o,Ad=new s,Od=[new o(-1,1,1),new o(-1,-1,1),new o(1,-1,1),new o(1,1,1),new o(-1,1,-1),new o(-1,-1,-1),new o(1,-1,-1),new o(1,1,-1)],Md=[[0,3],[1,2],[5,6],[4,7],[0,1],[3,2],[7,6],[4,5],[0,4],[1,5],[2,6],[3,7]],Cd=[[0,2],[7,5],[4,1],[3,6],[4,3],[1,6]],Pd=(t,e,n)=>{t.updateEntityBoxSize(_d,Sd),Ad.copy(e).multiply(t.matrixWorld),0===Sd.x&&0===Sd.y&&0===Sd.z?n.push(new o(_d.x,_d.y,_d.z).applyMatrix4(Ad)):Od.forEach((t=>{n.push(t.clone().multiply(Sd).add(_d).applyMatrix4(Ad))}))},Dd=class extends c{constructor(){super(...arguments),this.matrix=new s,this.vertices=[],this.faces=[],this.edges=[],this.centerEdges=[]}copy(t){return super.copy(t),this.matrix.copy(t.matrix),this.vertices=t.vertices.map((t=>t.clone())),this.faces=t.faces.map((t=>t.clone())),this.edges=t.edges.map((t=>t.clone())),this.centerEdges=t.centerEdges.map((t=>t.clone())),this}setFromObjectSize(t,e=!1){t.updateWorldMatrix(!1,e),this.makeEmpty(),this.matrix.copy(t.matrixWorld);let n=(new s).copy(t.matrixWorld).invert();return this.expandByObjectSize(t,n,e)}expandByObjectSize(t,e,n=!1){let r=[];return!0===n?t.traverseEntity((t=>{if(t.visible||t.cloner&&t.data.visible){if(!("geometry"in t))return void r.push(new o);Pd(t,e,r)}})):Pd(t,e,r),this.setFromPoints(r)}getCenter(t){return(t=super.getCenter(t)).applyMatrix4(this.matrix),t}getPositionToCenter(t){return(t=super.getCenter(t)).applyMatrix4(Ad.copy(this.matrix).setPosition(0,0,0)),t}computeVertices(){this.getSize(Sd).multiplyScalar(.5),this.getCenter(_d),Ad.copy(this.matrix).setPosition(_d),this.vertices=Od.map((t=>t.clone().multiply(Sd).applyMatrix4(Ad)))}computeEdges(){this.vertices.length>0&&this.computeVertices(),this.edges=Md.map((([t,e])=>new St(this.vertices[t],this.vertices[e]))),this.centerEdges=this.edges.map((t=>t.getCenter(new o)))}computeFaces(){this.vertices.length>0&&this.computeVertices(),this.faces=Cd.map((([t,e])=>this.vertices[t].clone().add(this.vertices[e]).multiplyScalar(.5)))}},Td={Cloner:()=>{},changeEntityProptotype:()=>{},createEntity:()=>{}},zd=class extends At{constructor(){super()}getPoints(t=12){let e,n=[],r=this.getCurveLengths(),i=r[r.length-1]/r.length;for(let a=0,s=this.curves;a<s.length;a++){let o=s[a],l=0===a?r[a]:r[a]-r[a-1],h=Math.ceil(t*l/i),d=o.getPoints(h);for(let t=0;t<d.length;t++){let r=d[t];e&&e.equals(r)||(n.push(r),e=r)}}return this.autoClose&&n.length>1&&!n[n.length-1].equals(n[0])&&n.push(n[0]),n}},Ed=.001;function Ld(t,e,n){return e.clone().sub(t).cross(e.clone().sub(n)).length()<=Ed}function Id(t,e){let n=new o(...t.position),r=new o(...t.controlNext.position),i=new o(...e.controlPrevious.position),a=new o(...e.position);return Ld(n,r,a)&&Ld(n,i,a)}function Nd(t){let e=t.points.map((t=>new o(...t.data.position))),n=[t.points[0]],r=new o(...n[0].data.position);for(let o=0;o<t.points.length-1;o++)Ld(r,e[o],e[o+1])||(n.push(t.points[o]),r=e[o]);n.push(t.points[t.points.length-1]);let i=t.isClosed,a=n.length-(i?0:1),s=n.length,l=[];for(let c=0;c<s;c++){let e=n[c].data,r=new o(...e.position),a=new o(...e.controlPrevious.position),h=new o(...e.controlNext.position),d={position:r,baseRoundness:e.roundness,controlPrevious:a,controlNext:h};if(0===e.roundness||!t.isClosed&&(0===c||c===s-1)){l[c]={...d,removedLength:0};continue}let u=i&&c==s-1?0:c+1,p=n[i&&0==c?s-1:c-1].data,f=n[u].data,m=new o(...p.position),g=new o(...f.position),v=m.clone().sub(r).normalize(),y=g.clone().sub(r).normalize();Object.assign(d,{prevDir:v,nextDir:y});let b=Id(p,e),x=Id(e,f);if(b&&x){let t=v.clone().add(y).normalize(),n=t.clone().cross(v).length()/v.dot(t);l[c]={...d,tan:n,removedLength:e.roundness/n}}else l[c]={...d,removedLength:0}}for(let o=0;o<a;o++){let t=i&&o===s-1?0:o+1,e=l[o],n=l[t];if(0!==e.removedLength||0!==n.removedLength){let t=e.position.distanceTo(n.position);e.removedLength=Math.min(e.removedLength,t/2),n.removedLength=Math.min(n.removedLength,t/2)}}let h=[];for(let o=0;o<a;o++){let t=o,e=i&&o===s-1?0:o+1,r=l[t],a=l[e],d=null;if(Id(n[t].data,n[e].data)){let t=r.position.clone(),e=a.position.clone();(0!==r.removedLength||0!==a.removedLength)&&(r.nextDir&&t.add(r.nextDir.clone().setLength(r.removedLength)),a.prevDir&&e.add(a.prevDir.clone().setLength(a.removedLength))),t.distanceTo(e)>Ed&&(d=new gt(t,t.clone().lerp(e,.3),e.clone().lerp(t,.3),e))}else r.position.distanceTo(a.position)>Ed&&(d=new gt(r.position,r.controlNext,a.controlPrevious,a.position));h[2*o+1]=d}for(let o=0;o<s;o++){let t=l[o];if(0===t.removedLength){h[2*o]=null;continue}let e=t.position,n=t.prevDir.clone().multiplyScalar(t.removedLength).add(e),r=t.nextDir.clone().multiplyScalar(t.removedLength).add(e),i=t.tan*t.removedLength,a=t.prevDir.clone().add(t.nextDir).normalize(),s=n.clone().lerp(r,.5),d=n.distanceTo(r)/2,c=a.clone().multiplyScalar(Math.sqrt(Math.pow(i,2)-Math.pow(d,2))).add(s),u=a.clone().multiplyScalar(-i).add(c),p=e.distanceTo(u)/e.distanceTo(s),f=t.prevDir.clone().multiplyScalar(p*e.distanceTo(n)).add(e),m=f.clone().lerp(u,2),g=n.clone().lerp(f,4/3),v=r.clone().lerp(m,4/3);h[2*o]=new gt(n,g,v,r)}let d=new zd;return h.forEach((t=>{t&&d.add(t)})),d}(yd||(yd={})).is=function(t){return t&&t.__isEntity};var jd=t=>yd.is(t),Bd={type:"completeState",isfromEntity:!0},Ud=["x","y","z"],kd=new o,Rd=(new o).set(0,1,0),Fd=t=>class extends(bd(t)){constructor(){super(...arguments),this.raycastLock=!1,this.scaleLock=!1,this.disposed=!1,this.stateSelection=null,this.destroyedInAction=!1,this.instances=[],this.prevState=null,this.currentState=null,this.reversibleToState=null,this.currentTransitionEvent=null,this.previousAction=null,this._singleBBox=new Dd,this._recursiveBBox=new Dd,this.singleBBoxNeedsUpdate=!0,this.recursiveBBoxNeedsUpdate=!0,this._needApplyPathSnapping=!0,this.attachedPaths=new Set}get __isEntity(){return!0}entityChildren(t){let e=this.children[t];if(yd.is(e))return e}entityChildrenCount(){let t=this.children.length;for(;t--;)if(yd.is(this.children[t]))return t+1;return 0}get isConcreteEntity(){return"string"==typeof this.identity}get isVirtualEntity(){return"string"!=typeof this.identity}get isInstanceRoot(){return this.isConcreteEntity&&"Instance"===this.data.type}nearestInstanceSelfOrParent(){let t=this;for(;"Instance"!==t.data.type;){let e=t.parent;if(!yd.is(e))return;t=e}return t}forInstancesRec(t){this.instances.forEach((e=>{e.disposed||t(e),e.forInstancesRec(t)}))}super_Entity(t,e){"string"==typeof t&&(this.uuid=t),this.identity=t,this.data=e,this.matrixAutoUpdate=!1,this.dataPatched=this.data}changeSelectedState(t,e,n=!1){if(0!==this.data.states.length||n){for(let t of this.data.states)mh.toOps(this.data,t.data).forEach((t=>{let n=ts.replaceProps(t,this.data);this.dataPatched=this.data,this.updateByPatchedOp(n,this.data,e)}));if(null!==t){let n=this.data.states.data(t);n&&(this.dataPatched=mh.patch(this.data,n),mh.toOps(this.data,n).forEach((t=>{this.updateByPatchedOp(t,this.dataPatched,e)})))}n&&this.updateTransformState(this.dataPatched,e),this.stateSelection=t,this.updatePathSnapping(this.dataPatched.pathSnapping)}}get singleBBox(){return this.singleBBoxNeedsUpdate&&(this.singleBBoxNeedsUpdate=!1,this._singleBBox.setFromObjectSize(this,!1),this._singleBBox.computeVertices(),this._singleBBox.computeEdges(),this._singleBBox.computeFaces()),this._singleBBox}get recursiveBBox(){return this.recursiveBBoxNeedsUpdate&&(this.recursiveBBoxNeedsUpdate=!1,this._recursiveBBox.setFromObjectSize(this,!0),this._recursiveBBox.computeVertices(),this._recursiveBBox.computeEdges(),this._recursiveBBox.computeFaces()),this._recursiveBBox}updateEntityBoxSize(t,e){t.setScalar(0),e.setScalar(0)}resetBBoxNeedsUpdateSelf(){this.singleBBoxNeedsUpdate=!0,this.recursiveBBoxNeedsUpdate=!0}resetBBoxNeedsUpdate(){this.resetBBoxNeedsUpdateSelf(),this.traverseAncestors((t=>{jd(t)&&t.resetBBoxNeedsUpdateSelf()})),this.traverseEntity((t=>{t.resetBBoxNeedsUpdateSelf()}))}find(t){let e;return this.traverseEntity((n=>{n.uuid===t&&(e=n)})),e}traverseSortNextHelper(){let t=this.parent;if(t){let e=t.children,n=e.indexOf(this)+1;if(yd.is(e[n]))return e[n];if(yd.is(t))return t.traverseSortNextHelper()}}sortNext(){let t=this.children;return this.children.length>0&&yd.is(this.children[0])?t[0]:this.traverseSortNextHelper()}goUp(t){let e=this;for(;t>0&&null!==e;)e=e.parent,t-=1;return e}hasAnccestorOrSelf(t){return this===t||this.hasAnccestor(t)}hasAnccestor(t){let e=this.parent;for(;e;){if(t===e)return!0;e=e.parent}return!1}countToAccestor(t){let e=0,n=this;for(;n!==t;){if(null===n)return-1;n=n.parent,e+=1}return e}forEachEntity(t){for(let e of this.children)jd(e)&&t(e)}traverseEntityAncestors(t){this.traverseAncestors((e=>{yd.is(e)&&t(e)}))}traverseConcreteEntity(t,e=0){if(!0!==t(this,e))for(let n of this.children)jd(n)&&n.isConcreteEntity&&n.traverseEntity(t,e+1)}traverseEntity(t,e=0){if(!0!==t(this,e))for(let n of this.children)jd(n)&&n.traverseEntity(t,e+1)}traverseVisibleEntity(t){t(this);for(let e of this.children)jd(e)&&e.visible&&e.traverseVisibleEntity(t)}updateMatrix(){super.updateMatrix(),this.cloner&&this.cloner.onObjUpdateMatrix(),this.dispatchEvent({type:"updateMatrix"})}updateMatrixWorld(t){super.updateMatrixWorld(t),this.dispatchEvent({type:"updateMatrixWorld"})}copy(t,e=!1){return super.copy(t,e),this.dataPatched=t.dataPatched,this.raycastLock=t.raycastLock,this.scaleLock=t.scaleLock,this.hiddenMatrix.copy(t.hiddenMatrix),this}hasEntityChild(){return this.children.some((t=>jd(t)))}isAncestorOf(t){if(this.uuid===t)return!1;let e=!1;return this.traverseEntity((n=>{n.uuid===t&&(e=!0)})),e}toObjectTransformState(t=[]){this.updateWorldMatrix(!0,!1);let e={position:this.position.toArray(),rotation:[this.rotation.x*x.RAD2DEG,this.rotation.y*x.RAD2DEG,this.rotation.z*x.RAD2DEG],scale:this.scale.toArray(),hiddenMatrix:this.hiddenMatrix.toArray()};return Ia(e,t)}getTransformValues(t,e,n){return e[t].map(((e,r)=>(null==n?void 0:n.shared.getVariable(e,[this.uuid,t,Ud[r]]))??e))}updateTransformState(t,e){let n=!1;return t.position&&(this.position.fromArray(this.getTransformValues("position",t,e)),n=!0),t.rotation&&(kd.fromArray(this.getTransformValues("rotation",t,e)).multiplyScalar(x.DEG2RAD),this.rotation.setFromVector3(kd),n=!0),t.scale&&(this.scale.fromArray(this.getTransformValues("scale",t,e)),n=!0),void 0!==t.hiddenMatrix&&(n=!0,this.hiddenMatrix.fromArray(t.hiddenMatrix??il.identity)),n&&(this.updateMatrix(),this.resetBBoxNeedsUpdate(),this.invalidateClonerTransform(this),this.traverseEntityAncestors((t=>{t.invalidateClonerTransform(this)}))),t.position&&t.rotation&&t.scale&&void 0!==t.hiddenMatrix&&this.updateWorldMatrix(!1,!0),n}onVariableUpdate(t=!1){t?this.resetBBoxNeedsUpdate():(this.updateMatrix(),this.resetBBoxNeedsUpdate(),this.invalidateClonerTransform(this),this.traverseEntityAncestors((t=>{t.invalidateClonerTransform(this)})))}dispose(){this.disposed=!0,this.cloner&&(this.cloner.removeFromParent(),this.cloner=void 0)}disposeChildrenRecursively(){for(let t of this.children)yd.is(t)&&t.disposeRecursively()}disposeRecursively(){this.dispose(),this.children.forEach((t=>{yd.is(t)&&t.disposeRecursively()}))}toState(t=[]){let e={name:this.name,visible:this.visible,raycastLock:this.raycastLock,...this.toObjectTransformState(t)};return Ia(e,t)}updateByObjUpdateOp(t,e){void 0!==t&&this.updateByOp({type:0,props:t,path:[]},{...this.data,...t},e,!1)}updateByOp(t,e,n,r){let i=this.data;this.data=e;let a=t,s=Ts(t.path,["states","*"]);if(null!==s){if(0===t.type){let[e]=s;if((null==this?void 0:this.stateSelection)===e){let e={...t.props};if(delete e.name,Object.values(t.props).some((t=>void 0===t))){let n=this.data;if(void 0!==n){let r=As.zoom(n,t.path.slice(2));if(r)for(let n in t.props)void 0===t.props[n]&&n in r&&(e[n]=r[n])}}a={...t,props:e,path:t.path.slice(2)}}}}else if(0===t.type){let e=this.stateSelection?this.data.states.data(this.stateSelection):void 0;if(void 0!==e){if(void 0!==t.props.name&&e.name){let{name:t,...n}=e;e=n}if(void 0!==t.props.material&&"material"in e){let{material:t,...n}=e;e=n}let n=As.removeOverridden(t.path,t.props,e);a={...t,props:n}}}if(this.updateByPatchedOpBase(a,mh.patch(this.data,this.stateSelection?this.data.states.data(this.stateSelection):void 0),n),Ts(t.path,["overrides"])){let r=[],i=[...t.path];for(r.push(i[1]),i.splice(0,2);i.length>0&&"descendants"===i[0];)r.push(i[1]),i.splice(0,2);if(void 0===r[r.length-1]){if(0===t.type)for(let e of Object.keys(t.props)){r[r.length-1]=e;let i=n.scene.findInstance([this.uuid,...r]);i&&(i.overrideData=t.props[e],i.updateState(Qa.apply(i.component.data,i.overrideData),n))}}else{let a=n.scene.findInstance([this.uuid,...r]);if(a){let s=As.zoom(a.component.data,i);if(0===(t={...t,path:i}).type){let e=t.props;if(s)for(let[n,r]of Object.entries(t.props))void 0===r&&(e===t.props&&(e={...t.props}),e[n]=s[n]);t={...t,props:e}}a.overrideData=ch.resolve(e.overrides,r),a.updateByOp(t,es.applySimple(a.data,t),n,!1)}}}else if(this.instances.length>0){let r;if(0===t.path.length&&0===t.type){let e;for(let n of uh.rootOverrideProps)n in t.props&&(void 0===e&&(e={}),e[n]=t.props[n]);e&&(r={...t,props:e})}else for(let e of uh.rootOverrideProps)if(Ts(t.path,[e])){r=t;break}void 0!==r&&this.instances.forEach((t=>{if(t.isInstanceRoot){let e=Qa.filterOp(t.overrideData,r);e&&t.updateByOp(e,es.applySimple(t.data,e),n,!0)}})),this.instances.forEach((r=>{if(!r.isInstanceRoot){let a=Qa.filterOp(r.overrideData,t);if(a){let s;s=i===r.data&&t===a?e:es.applySimple(r.data,a),r.updateByOp(a,s,n,!0)}}}))}}updateByPatchedOpBase(t,e,n){if(this.dataPatched=e,0===t.path.length&&0===t.type)void 0!==t.props.type&&!fl.is(t.props.type)&&Td.changeEntityProptotype(this,e,n);else if(1===t.path.length&&"geometry"===t.path[0]&&0===t.type&&"type"in t.props){Td.changeEntityProptotype(this,e,n);for(let t of this.children)yd.is(t)&&t.updateVisible()}this.updateByPatchedOp(t,e,n)}updateByPatchedOp(t,e,n){if(0===t.path.length&&0===t.type&&this.updateState(t.props,n),null!==Ts(t.path,["pathSnapping"])&&this.updatePathSnapping(e.pathSnapping),null!==Ts(t.path,["cloner"])){let r=es.drop(t,1);0===r.path.length&&0===r.type&&!0===r.props.disabled?this.setFromClonerState(null,n):this.cloner?this.cloner.updateState(e.cloner,n.scene):(this.setFromClonerState(e.cloner,n),this.expandCloner(n.scene)),this.updateVisible()}}updatePathSnapping(t){this._updatedPathSnapping=t,this._needApplyPathSnapping=!0}get updatedPathSnapping(){return this._updatedPathSnapping}applyPathSnapping(t){var e,n,r,i,a;let o=(null==(e=this._updatedPathSnapping)?void 0:e.pathId)??this.dataPatched.pathSnapping.pathId,l=(null==(n=this._updatedPathSnapping)?void 0:n.slide)??this.dataPatched.pathSnapping.slide??0,h=(null==(r=this._updatedPathSnapping)?void 0:r.offset)??this.dataPatched.pathSnapping.offset,d=(null==(i=this._updatedPathSnapping)?void 0:i.orientation)??this.dataPatched.pathSnapping.orientation;if(null===o)return;let c=t.find(o);if(!c||!1===this._needApplyPathSnapping)return;this._needApplyPathSnapping=!1;let u=c.data;if(u.geometry.path.points.length<=1)return;let p=Nd(u.geometry.path),f=(l+h)%1;l+h===1&&0===f&&(f=1);let m=p.getPointAt(f),g=this.parent?null==(a=this.parent)?void 0:a.matrixWorld:new s;c.updateMatrixWorld();let v=(new s).multiplyMatrices(g.clone().invert(),c.matrixWorld);m.applyMatrix4(v);let y={position:m.toArray(),rotation:u.rotation};if("tangential"===d){let t=(new s).extractRotation(c.matrixWorld),e=p.getTangentAt(f).applyMatrix4(t).add(m),n=(new s).lookAt(m,e,Rd),r=kd.setFromEuler((new vt).setFromRotationMatrix(n)).multiplyScalar(x.RAD2DEG);y={...y,rotation:r.toArray()}}this.updateTransformState(y),this.traverseEntity((t=>{t._cameraType&&t.dispatchEvent(Bd)}))}updateVisible(){var t;this.visible=this.dataPatched.visible&&(!this.dataPatched.cloner||(this.dataPatched.cloner.disabled??!1)||!0!==(null==(t=this.dataPatched.cloner)?void 0:t.hideBase))}updateState_Entity(t,e){void 0!==t.name&&(this.name=t.name),void 0!==t.raycastLock&&(this.raycastLock=t.raycastLock),void 0!==t.visible&&(this.updateVisible(),this.resetBBoxNeedsUpdate()),e&&"cloner"in t&&void 0!==t.cloner&&(this.setFromClonerState(t.cloner,e),this.updateVisible()),this.updateTransformState(t,e)}get attachedSurfaceCloners(){return this.children.filter((t=>t instanceof Td.Cloner&&"toObject"===t.parameters.type))}setFromClonerState(t,e){this.disposed||(null===t||t.disabled?(this.cloner&&this.cloner.removeFromParent(),this.cloner=void 0):void 0===this.cloner?(this.cloner=new Td.Cloner(this,t),e.scene.addPendingExpandCloner(this)):this.cloner.updateState(t,e.scene))}expandCloner(t){!this.disposed&&this.cloner&&this.cloner.expandClones(t)}invalidateClonerTransform(t){this.cloner&&this.cloner.invalidateTransform(t)}};function Vd(t,e,n){n.x=t.x*e.x,n.y=t.y,n.z=t.x*e.y}function Gd(t){return new l(t.y,-t.x)}var Hd=class extends e{constructor(t,e,n,r,i,a,s,h,d,c,u,p,f=!1){super(),this.type="RoundedCylinderBufferGeometry",t=void 0!==t?t:1,e=void 0!==e?e:1,n=n||1,r=Math.floor(r)||8,i=Math.floor(i)||1,a=void 0!==a&&a,s=void 0!==s?s:0,h=void 0!==h?h:2*Math.PI,a&&(d=0,c=0);let m=[],g=[],v=[],y=[],b=0,x=n/2,w=new o,_=new o;f&&0==t&&(t=d),f&&0==e&&(e=c);let A=new l(t,x),O=new l(e,-x),M=null,C=null,P=null,D=null,T=A.clone().sub(O),z=0,E=0,L=0;p>0&&(z=Math.min(t,e)*(1-p),E=t-z,L=e-z);let I=A.clone();I.x-=z;let N=Math.PI-T.angle(),j=T.angle(),B=Math.tan(j/2),U=Math.tan(N/2),k=B+U,R=p?k:U,F=p?k:B;if(d=Math.min(d,(t-E)/R,T.length()/k),c=Math.min(c,(e-L)/F,T.length()/k),d>0){let t=d/B;M=A.clone().sub(new l(t,d)),p&&(P=M.clone(),P.x-=z-k*d),A.sub(T.clone().setLength(t))}if(c>0){let t=c/U;C=O.clone().sub(new l(t,-c)),O.add(T.clone().setLength(t)),p&&(D=C.clone(),D.x-=z-k*c,I.sub(T.clone().setLength(t)))}T=A.clone().sub(O);let V=T.length()<.5,G=[];for(let o=0;o<=r;o++){let u=[],f=o/r,m=f*h+s,x=new l(Math.sin(m),Math.cos(m));if(D&&C?(H(u,f,x,N,c,D,-1,!0),H(u,f,x,j,c,C,-1,!1)):C?(W(u,x,C.x,0,-1),H(u,f,x,j,c,C,-1,!1)):a||W(u,x,e,L,-1),Vd(Gd(T).normalize(),x,w),!V)for(let t=0;t<=i;t++){let e=t/i;Vd(T.clone().multiplyScalar(e).add(O),x,_),g.push(_.x,_.y,_.z),v.push(w.x,w.y,w.z),y.push(f,.5+_.y/n),u.push(b++)}if(P&&M?(H(u,f,x,N,d,M,1,!1),H(u,f,x,j,d,P,1,!0)):M?(H(u,f,x,N,d,M,1,!1),W(u,x,M.x,0,1)):a||W(u,x,t,E,1),p&&!V){Vd(Gd(T).multiplyScalar(-1).normalize(),x,w);for(let t=0;t<=i;t++){let e=t/i;Vd(T.clone().multiplyScalar(-e).add(I),x,_),g.push(_.x,_.y,_.z),v.push(w.x,w.y,w.z),y.push(f,.5+_.y/n),u.push(b++)}}p&&!a&&u.push(u[0]),G.push(u)}for(let o=0;o<G.length-1;o++)for(let t=0;t<G[0].length-1;t++){if(a&&p&&t==i)continue;let e=G[o][t],n=G[o+1][t],r=G[o+1][t+1],s=G[o][t+1],l=g[3*r+0],h=g[3*r+2];m.push(e,n,s),(0!=l||0!=h)&&m.push(n,r,s)}function H(t,e,r,i,a,s,o,h){for(let d=0;d<u+1;d++){let c=d/u,p=o<0?c:1-c;h&&(p-=1),p*=i;let f=new l(Math.sin(p),Math.cos(p)*o);Vd(f.clone().multiplyScalar(a).add(s),r,_),g.push(_.x,_.y,_.z),Vd(f,r,w),v.push(w.x,w.y,w.z),y.push(e,.5+_.y/n),t.push(b++)}}function W(t,e,n,r,i){let a=new o,s=new l,h=[n,r];i<0&&h.reverse();for(let o of h)s.set(o,x*i),Vd(s,e,a),g.push(a.x,a.y,a.z),v.push(0,i,0),y.push(.5,.5),t.push(b++)}function q(n,r,i){let a=new l(Math.sin(i),Math.cos(i)),s=new l(-Math.cos(i),Math.sin(i)),h=new o,d=n<0?(t,e,n)=>m.push(t,e,n):(t,e,n)=>m.push(t,n,e);Vd(new l((t+e+E+L)/4,0),a,h),g.push(h.x,h.y,h.z),v.push(s.x,0,s.y),y.push(.5,.5);let c=b++;for(let t of r){let e=g.slice(3*t,3*t+3);g.push(...e),v.push(s.x,0,s.y);let n=y.slice(2*t,2*t+2);y.push(...n),b++}for(let t=c+1;t<b-1;t++)d(c,t,t+1);d(c,b-1,c+1)}h<2*Math.PI&&(q(-1,G[0],s),q(1,G[G.length-1],s+h)),this.setIndex(m),this.setAttribute("position",new S(g,3)),this.setAttribute("normal",new S(v,3)),this.setAttribute("uv",new S(y,2))}},Wd=Math.PI/2,qd=class extends e{constructor(t=1,e=1,n=1,r=1,i=1,a=1,s=0,l=4){super(),this.type="BoxGeometry";let h=this;r=Math.floor(r),i=Math.floor(i),a=Math.floor(a),l=Math.floor(l),s=Math.min(s,t/2,e/2,n/2);let d=[],c=[],u=[],p=[],f=0,m=0;function g(t,e,n,r,i,a,l,g,v,y,b){let x=(a-2*s)/v,w=(l-2*s)/y,_=a/2-s,S=l/2-s,A=g/2,O=v+1,M=y+1,C=0,P=0,D=new o;for(let s=0;s<M;s++){let a=s*w-S;for(let o=0;o<O;o++){let l=o*x-_;D[t]=l*r,D[e]=a*i,D[n]=A,c.push(D.x,D.y,D.z),D[t]=0,D[e]=0,D[n]=g>0?1:-1,u.push(D.x,D.y,D.z),p.push(o/v),p.push(1-s/y),C+=1}}for(let s=0;s<y;s++)for(let t=0;t<v;t++){let e=f+t+O*s,n=f+t+O*(s+1),r=f+(t+1)+O*(s+1),i=f+(t+1)+O*s;d.push(e,n,i),d.push(n,r,i),P+=6}h.addGroup(m,P,b),m+=P,f+=C}function v(t,e,n,r,i,a,g,v,y,b,x){let w=(g-2*s)/b,_=g/2-s,S=v/2-s,A=y/2,O=b+1,M=0,C=0,P=new o,D=new o;for(let o=0;o<l+1;o++){let h=o/l*Wd,d=Math.sin(h)*s,f=(1-Math.cos(h))*s,m=Math.sin(h),g=Math.cos(h);P[e]=(S+d)*i,P[n]=(A-f)*a,D[t]=0,D[e]=m*Math.sign(P[e]),D[n]=g*Math.sign(P[n]);for(let e=0;e<O;e++){let n=e*w-_;P[t]=n*r,c.push(P.x,P.y,P.z),u.push(D.x,D.y,D.z),p.push(e/b),p.push(0),M+=1}}for(let s=0;s<l;s++)for(let t=0;t<b;t++){let e=f+t+O*s,n=f+t+O*(s+1),r=f+(t+1)+O*(s+1),i=f+(t+1)+O*s;d.push(e,n,i),d.push(n,r,i),C+=6}h.addGroup(m,C,x),m+=C,f+=M}function y(r,i,a){let h=new o,m=new o(t/2,e/2,n/2);m.subScalar(s);let g=[],v=r*i*a>0?(t,e,n)=>d.push(t,e,n):(t,e,n)=>d.push(t,n,e);for(let t=0;t<=l;t++){let e=[],n=Wd*(1-t/l),o=Math.cos(n),d=Math.sin(n),v=0;for(let l=0;l<=t;l++){let n=Math.cos(v),l=Math.sin(v);h.x=o*n,h.y=d,h.z=o*l;let g=m.clone().addScaledVector(h,s);c.push(r*g.x,i*g.y,a*g.z),u.push(r*h.x,i*h.y,a*h.z),p.push(0,0),e.push(f++),v+=Wd/t}g.push(e)}let y=g.length-1;for(let t=0;t<y;t++){let e=g[t],n=g[t+1],r=e.length-1;v(e[0],n[1],n[0]);for(let t=1;t<=r;t++)v(e[t-1],e[t],n[t]),v(e[t],n[t+1],n[t])}}g("z","y","x",-1,-1,n,e,t,a,i,0),g("z","y","x",1,-1,n,e,-t,a,i,1),g("x","z","y",1,1,t,n,e,r,a,2),g("x","z","y",1,-1,t,n,-e,r,a,3),g("x","y","z",1,-1,t,e,n,r,i,4),g("x","y","z",-1,-1,t,e,-n,r,i,5),s>0&&(v("z","y","x",-1,-1,1,n,e,t,a,0),v("z","y","x",1,-1,-1,n,e,t,a,1),v("z","y","x",-1,1,-1,n,e,t,a,1),v("z","y","x",1,1,1,n,e,t,a,0),v("x","y","z",-1,-1,-1,t,e,n,r,0),v("x","y","z",1,-1,1,t,e,n,r,1),v("x","y","z",-1,1,1,t,e,n,r,0),v("x","y","z",1,1,-1,t,e,n,r,1),v("y","x","z",-1,-1,1,e,t,n,i,0),v("y","x","z",1,-1,-1,e,t,n,i,1),v("y","x","z",1,1,1,e,t,n,i,1),v("y","x","z",-1,1,-1,e,t,n,i,0),y(1,1,1),y(-1,1,1),y(1,-1,1),y(-1,-1,1),y(1,1,-1),y(-1,1,-1),y(1,-1,-1),y(-1,-1,-1)),this.setIndex(d),this.setAttribute("position",new S(c,3)),this.setAttribute("normal",new S(u,3)),this.setAttribute("uv",new S(p,2))}},$d=class extends e{constructor(t=[],e=[],n="",r=1,i=.2,s=4){super(),this.type="PolyhedronGeometryRound";let h=[],d=[],c=[];return function(){var l;0==(i=Math.min(.99999,i))&&(s=0);let d={IcosahedronGeometry:5,DodecahedronGeometry:3,HexahedronGeometry:3,OctahedronGeometry:4,TetrahedronGeometry:3}[n],u=new o,p=u.clone(),f=new a,m=i*r,g=r-m,v=s+1,y=new o,b=(t,e)=>y.subVectors(t,e).normalize(),x=(t,e)=>Array(t).fill(void 0).map(e),w=x(t.length/3,((e,n)=>(new o).fromArray(t,3*n).setLength(r))),_=[],S=1e6;for(let t=0;t<w.length;t++){let n,r,i,a=w[t],s=[],o=1e10,h=-1;for(;-1!=(h=e.indexOf(t,h+1));){let t=h-h%3;n=e[t+(h+1)%3],r=e[t+(h+2)%3],i=a.distanceToSquared(w[n]),o=Math.min(o,i),s.push([n,r,i])}o+=1e-6;let d=[],c=0,u=s.length;for(let e=0;e<u;e++){[n,r,i]=s[c];let e=1==(null==(l=_[n])?void 0:l.includes(t));i<=o&&d.push(n+ +e*S),c=s.findIndex((t=>t[0]==r))}_.push(d)}let A=[];{let t,e,n=0,r=0,i=3==d;for(let a=0;a<=s;a++){t=a*(a+1)/2,e=(a+1)*(a+2)/2;for(let o=0;o<s-a;o++)[n,r]=[t+o+a+2,e+o+a+3],A.push(t,e,...i?[r,t]:[n,e],r,n),[t,e]=[n,r];A.push(t,e,t+s+2)}}let O=u.clone(),M=u.clone(),C=u.clone(),P=u.clone(),D=u.clone(),T=[],z=x(w.length,(()=>x(d,(()=>u.clone()))));for(let t=0;t<w.length;t++){u.copy(w[t]).normalize(),O.copy(u).multiplyScalar(g);let e=_[t];for(let s=0;s<e.length;s++){let n=e[s],r=e[(s+1)%d];f.setFromPointsAndIndices(w,t,n%S,r%S),f.b.sub(f.a).setLength(1e10).add(f.a),f.c.sub(f.a).setLength(1e10).add(f.a),f.closestPointToPoint(O,z[t][s])}let n=[],r=[],i=[],a=new o;0==s&&[...z[t]].reduce(((t,e)=>t.add(e)),a).multiplyScalar(1/d);for(let o=0;o<d;o++){let e=[],l=(o-1+d)%d,h=z[t][l],c=z[t][o];u.copy(h).sub(O),p.copy(c).sub(O);let f=O.angleTo(u),x=u.angleTo(p),w=Math.cos(f)*m;0==s?M.copy(a):M.copy(O).setLength(g+w),r.push(w);let _=[M,h,c];for(let t=0;t<2;t++){let r=_[t],i=_[t+1];P.subVectors(r,O),D.subVectors(i,O),C.crossVectors(P,D).normalize();for(let a=0;a<v;a++){let i=[f,x][t]*a/v;u.copy(P).applyAxisAngle(C,i).add(O),n.push(u.clone()),t&&(b(u,O),e.push([0==a?r:u.clone(),y.clone()]))}t&&(b(i,O),e.push([i,y.clone()]))}i.push(e)}T.push(i);let l=2*v,x=2;for(let t=0;t<d;t++){let e=l*t,i=l*((t+1)%d),a=[n[e]];for(let o=1;o<v;o++){P=n[e+o],D=n[i+o],a.push(P);for(let e=1,n=o-x+1;e<=n;e++)u.lerpVectors(P,D,e/(n+1)),u.sub(O).setLength(r[t]).add(O),a.push(u.clone());a.push(D)}for(let t=0;t<v;t++)a.push(n[t+v+e]);a.push(n[i+v]);let s=A.map((t=>a[t]));h.push(...s.map((t=>[t.x,t.y,t.z])).flat()),c.push(...s.map((t=>(b(t,O),[y.x,y.y,y.z]))).flat())}}let E=[];for(let t=0;t<_.length;t++)for(let e=0;e<d;e++){let n=_[t][e];if(n<S){let r=_[n].findIndex((e=>e%S==t)),i=T[t][e],a=T[n][r];for(let t=0;t<v;t++){let e=i[t],n=a[v-t],r=i[t+1];[e,n,r,r,n,a[v-(t+1)]].forEach((t=>{h.push(t[0].x,t[0].y,t[0].z),c.push(t[1].x,t[1].y,t[1].z)}))}E.push(i[0][0],a[v][0],i[v][0],a[0][0])}}for(;E.length;){let t,e,n,r;[t,e]=E.splice(0,2);let i=[t];for(;t!=e;)i.push(e),n=E.indexOf(e),r=n%2,e=E.splice(n-r,2)[1-r];y.subVectors(i[0],i[1]).cross(u.subVectors(i[0],i[2])).normalize();let a=y.dot(i[0])<0;a&&y.negate();for(let s=1;s<=i.length-2;s++)[i[s+ +a],i[s+1-+a],i[0]].forEach((t=>{h.push(t.x,t.y,t.z),c.push(y.x,y.y,y.z)}))}}(),function(){let t=new o;for(let o=0;o<h.length;o+=3){t.x=h[o+0],t.y=h[o+1],t.z=h[o+2];let e=p(t)/2/Math.PI+.5,n=f(t)/Math.PI+.5;d.push(e,1-n)}let e=new o,n=new o,r=new o,i=new o,a=new l,s=new l,c=new l,u=(t,e,n,r)=>{r<0&&1===t.x&&(d[e]=t.x-1),0===n.x&&0===n.z&&(d[e]=r/2/Math.PI+.5)};for(let o=0,l=0;o<h.length;o+=9,l+=6){e.set(h[o+0],h[o+1],h[o+2]),n.set(h[o+3],h[o+4],h[o+5]),r.set(h[o+6],h[o+7],h[o+8]),a.set(d[l+0],d[l+1]),s.set(d[l+2],d[l+3]),c.set(d[l+4],d[l+5]),i.copy(e).add(n).add(r).divideScalar(3);let t=p(i);u(a,l+0,e,t),u(s,l+2,n,t),u(c,l+4,r,t)}for(let o=0;o<d.length;o+=6){let t=d[o+0],e=d[o+2],n=d[o+4],r=Math.max(t,e,n),i=Math.min(t,e,n);r>.9&&i<.1&&(t<.2&&(d[o+0]+=1),e<.2&&(d[o+2]+=1),n<.2&&(d[o+4]+=1))}function p(t){return Math.atan2(t.z,-t.x)}function f(t){return Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))}}(),this.setAttribute("position",new S(h,3)),this.setAttribute("normal",new S(c,3)),void this.setAttribute("uv",new S(d,2))}static fromJSON(t){return new $d(t.vertices,t.indices,t.radius,t.corner,t.cornerSides)}},Xd=class extends $d{constructor(t=1,e=.2,n=4){let r=(1+Math.sqrt(5))/2,i=1/r,a="DodecahedronGeometry";super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-r,0,-i,r,0,i,-r,0,i,r,-i,-r,0,-i,r,0,i,-r,0,i,r,0,-r,0,-i,r,0,-i,-r,0,i,r,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],a,t,e,n),this.type=a}static fromJSON(t){return new Xd(t.radius,t.corner,t.cornerSides)}},Yd=1e-12,Kd=class{constructor(t){this.position=new l,this.startPosition=new l,this.uuid=x.generateUUID(),this.position=t.clone()}start(){this.reset()}reset(){this.startPosition.copy(this.position)}applyOffset(t){this.position.copy(this.startPosition).add(t)}copy(t){return this.position.copy(t.position),this.startPosition.copy(t.startPosition),this}clone(){return new Kd(this.position).copy(this)}toJSON(){return[this.position.x,this.position.y]}},Zd=class extends Kd{constructor(t){super(t.position),this.parent=t}copy(t){return super.copy(t),this}clone(){return new Zd(this.parent).copy(this)}},Qd=class extends Kd{constructor(t,e){super(e),this.controls=[],this.roundness=0,this.areControlsDirectionsMirrored=!0,this.uuid=t,this.controls.push(new Zd(this),new Zd(this))}static create(t,e){let n=new Qd(t,new l(...e.position));return n.controls[0].position.set(...e.controlPrevious.position),n.controls[1].position.set(...e.controlNext.position),n.roundness=e.roundness,n.areControlsDirectionsMirrored=e.areControlsDirectionsMirrored,n}getOppositeControl(t){let e=this.controls.indexOf(t);return 0===e?this.controls[1]:1===e?this.controls[0]:null}applyOffsetToControls(t,e=1){for(let n=0,r=this.controls.length;n<r;n++){let r=this.controls[n];this.position.distanceTo(r.position)<=e?r.position.copy(this.position):r.applyOffset(t)}}controlsMoved(){return!(this.position.equals(this.controls[0].position)&&this.position.equals(this.controls[1].position))}copy(t){return super.copy(t),this.controls[0].copy(t.controls[0]),this.controls[1].copy(t.controls[1]),this.roundness=t.roundness,this.uuid=t.uuid,this}clone(){return new Qd(this.uuid,this.position).copy(this)}toJSON(){return super.toJSON().concat(this.controls[0].toJSON(),this.controls[1].toJSON(),[this.roundness])}computeTangents(){var t,e;return[null==(t=this.curveBefore)?void 0:t.getTangentAt(1),null==(e=this.curveAfter)?void 0:e.getTangentAt(0)]}computeNormals(t=new l,e=new l){let[n,r]=this.computeTangents();return n&&r&&(Jd(n,t),Jd(r,e)),[t,e]}computeTangent(t=new l){let[e,n]=this.computeTangents();return e&&n&&t.copy(e).add(n).normalize(),t}computeNormal(t=new l){let[e,n]=this.computeNormals();return t.copy(e).add(n).normalize(),t}};function Jd(t,e=new l){let n=t.length();return e.set(-t.y/n,t.x/n)}var tc=new l,ec=new l,nc=new l,rc=new l,ic=new l,ac=new l,sc=new o,oc=new o;function lc(t){let e=new l;e.addVectors(t.v0,tc.subVectors(t.v1,t.v0).multiplyScalar(2/3));let n=new l;return n.addVectors(t.v2,ec.subVectors(t.v1,t.v2).multiplyScalar(2/3)),new P(t.v0,e,n,t.v2)}function hc(t,e,n=Number.EPSILON){return Math.abs(t-e)<n}function dc(t,e,n=Number.EPSILON){return t.distanceTo(e)<n}function cc(t,e,n=Number.EPSILON){return t.distanceTo(e)<n}function uc(t,e,n){let r=Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2)),i=Math.sqrt(Math.pow(e.x-n.x,2)+Math.pow(e.y-n.y,2)),a=Math.sqrt(Math.pow(n.x-t.x,2)+Math.pow(n.y-t.y,2));return Math.acos((i*i+r*r-a*a)/(2*i*r))}function pc(t,e,n){return bc(t,e)&&bc(e,n)&&fc(t.position,e.position,n.position)}function fc(t,e,n){return 0===tc.copy(e).sub(t).cross(ec.copy(n).sub(t))}function mc(t,e,n,r,i){let a=Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2)),s=(t.y+e.y)/2,o=(t.x+e.x)/2,l=Math.sqrt(Math.pow(n,2)-Math.pow(a/2,2))*(t.y-e.y)/a,h=Math.sqrt(Math.pow(n,2)-Math.pow(a/2,2))*(e.x-t.x)/a;return r.set(o+l,s+h),i.set(o-l,s-h),[r,i]}function gc(t,e,n){return t.distanceTo(n)<e.distanceTo(n)?e:t}function vc(t,e,n,r,i,a){let s,o=e.x-t.x,l=e.y-t.y,h=n.x-t.x,d=n.y-t.y,c=Math.sqrt((o+h)*(o+h)+(l+d)*(l+d));return uc(e,t,n)>Math.PI&&(c*=-1),s=hc(d,l)?(l+d)*(r/c-.5)*8/3/(o-h):(o+h)*(r/c-.5)*8/3/(d-l),i.set(e.x-s*l,e.y+s*o),a.set(n.x+s*d,n.y-s*h),[i,a]}function yc(t,e){return t.position.equals(t.controls[1].position)&&e.position.equals(e.controls[0].position)}function bc(t,e){return fc(t.position,t.controls[1].position,e.position)&&fc(t.position,e.controls[0].position,e.position)}function xc(t,e=12,n=!1){let r=[];for(let i=0,a=t.length;i<a;i++){let a=t[i],s=0;if(n&&void 0!==a.roundedCurveCorner){let t=.5*wc(a.roundedCurveCorner,e);i>0&&(r[i-1]+=t),s+=t}void 0!==a.curveAfter&&(s+=wc(a.curveAfter,e)),r.push(s)}return t.length>0&&n&&void 0!==t[0].roundedCurveCorner&&(r[t.length-1]+=.5*wc(t[0].roundedCurveCorner,e)),r}function wc(t,e=12){return t&&t instanceof it?2*e:t&&(t instanceof C||t instanceof at)?1:t&&t instanceof st?e*t.points.length:e}var _c,Sc,Ac=new l,Oc=new l,Mc=new l,Cc=new l,Pc=new l,Dc=new l,Tc=class extends ${constructor(t=100,e=100){super(),this.points=[],this.shapeHoles=[],this.plane=new K(new o(0,0,-1)),this.subdivision=0,this.controlSnapDistance=4,this.pointIDs=0,this.isMesh2D=!1,this.isText=!1,this._roundness=0,this.isClosed=!1,this.useCubicForRoundedCorners=!0,this.uuid=x.generateUUID(),this.needsUpdate=!1,this.roundedCurves=[],this._width=t,this._height=e}static createFromState(t,e,n){let r=new Tc;return r.isClosed=t.isClosed,r.points=t.points.map((t=>Qd.create(t.id,t.data))),"number"==typeof t.roundness&&(r.roundness=t.roundness),r.shapeHoles=t.shapeHoles.map((t=>Tc.createFromState(t))),void 0!==e&&void 0!==n&&r.applySize(e,n),r.update(),r}get width(){return this._width}get height(){return this._height}get roundness(){return this._roundness}set roundness(t){if(this._roundness!==t){this._roundness=t;for(let e=0,n=this.points.length;e<n;e++)this.points[e].roundness=t;this.needsUpdate=!0}}getPointsIndexesByIds(t){return t.map((t=>this.getPointIndexById(t))).filter((t=>t>=0))}getPointIndexById(t){let e=this.points.length,n=this.points.findIndex((e=>e.uuid===t));if(n<0){let n=e;for(let e=0,r=this.shapeHoles.length;e<r;e++){let r=this.shapeHoles[e],i=r.points.length,a=r.getPointIndexById(t);if(!(a<0))return a+n;n+=i}}return n}getLineIndexById(t){return this.getPointIndexById(t)}getBezierPoint(t){if(t<=this.points.length-1)return this.points[t];if(this.shapeHoles.length>0){let e=this.points.length;for(let n=0,r=this.shapeHoles.length;n<r;n++){let r=this.shapeHoles[n],i=t-e;if(i<=r.points.length-1)return r.points[i];e+=r.points.length}}throw new Error("This shape does not have a point for this index: "+t)}getBezierPointIndex(t){let e=this.points.indexOf(t);if(e>=0)return e;if(e=this.points.length,this.shapeHoles.length>0)for(let n=0,r=this.shapeHoles.length;n<r;n++){let r=this.shapeHoles[n],i=r.points.indexOf(t);if(i>=0)return e+i;e+=r.points.length}return-1}getAllPoints(){let t=[].concat(...this.shapeHoles.map((t=>t.points)));return[...this.points,...t]}applySize(t,e){0===t&&(t=.001),0===e&&(e=.001),this._width=t,this._height=e}applyScale(t,e){let n=Ac.set(t,e);for(let r=0,i=this.points.length;r<i;r++){let t=this.points[r];t.position.multiply(n),t.controls[0].position.multiply(n),t.controls[1].position.multiply(n)}for(let r=0,i=this.shapeHoles.length;r<i;r++)this.shapeHoles[r].applyScale(t,e);this._update()}createPoint(t,e=0,n=x.generateUUID()){let r;r=t instanceof l?t:new l(t,e);let i=new Qd(n,r);return i.roundness=this.roundness,i}addPoint(t){this.points.push(t),this.needsUpdate=!0}addPointAt(t,e){this.points.splice(e,0,t),this.needsUpdate=!0}getPointByUuid(t){for(let e=0,n=this.points.length;e<n;e++){let n=this.points[e];if(n.uuid===t)return n}for(let e=0,n=this.shapeHoles.length;e<n;e++){let n=this.shapeHoles[e].getPointByUuid(t);if(n)return n}}getFirstPoint(){return this.points[0]}getLastPoint(){return this.points[this.points.length-1]}removePoint(t){let e=this.points.indexOf(t);e>=0&&this.points.splice(e,1),this.needsUpdate=!0}removePointById(t){let e=this.points.find((e=>e.uuid===t));e&&this.removePoint(e)}update(){for(let t=0,e=this.shapeHoles.length;t<e;t++)this.shapeHoles[t].update();this._update()}extractShapePointsToBuffer(t,e=12,n=!1){this.subdivision=e,void 0===this.curveDivisions&&this.computeCurveDivisions(e);let r=n?this.roundedCurveDivisions:this.curveDivisions;return function(t,e,n=12,r=!0){let i,a=oc.set(0,0,0),s=0;for(let o=0;o<e.length;o++){let r=e[o],l=tc,h=wc(r,n);for(let e=0;e<=h;e++)if(r instanceof P||r instanceof D||r instanceof C){if(r.getPoint(e/h,l),a.set(l.x,l.y,0),void 0!==i&&cc(i,a))continue;void 0===i&&(i=sc),i.copy(a),t.setXYZ(s,a.x,a.y,a.z),s++}}r&&s>1&&!(t.getX(s-1)===t.getX(0)&&t.getY(s-1)===t.getY(0)&&t.getZ(s-1)===t.getZ(0))&&(t.setXYZ(s,t.getX(0),t.getY(0),t.getZ(0)),s++)}(t,n?this.roundedCurves:this.curves,e,this.autoClose),r.reduce(((t,e)=>t+e),0)+1}computeCurveDivisions(t=12){return this.curveDivisions=xc(this.points,t,!1),this.roundedCurveDivisions=xc(this.points,t,!0),this.curveDivisions}extractFilteredShapePointsToBuffer(t,e,n=12){return 2*function(t,e,n,r=12,i=!0){let a=oc.set(0,0,0),s=0,o=[];for(let l=0;l<e.length;l++){if(!1===n[l])continue;let i,h=e[l],d=tc,c=wc(h,r);o.push(c);for(let e=0;e<=c;e++)if(h instanceof P||h instanceof D||h instanceof C){if(h.getPoint(e/c,d),a.set(d.x,d.y,0),null==i?void 0:i.equals(a))continue;void 0===i?i=sc:(t.setXYZ(s,i.x,i.y,i.z),s++,t.setXYZ(s,a.x,a.y,a.z),s++),i.copy(a)}}return i&&s>1&&!(t.getX(s-1)===t.getX(0)&&t.getY(s-1)===t.getY(0)&&t.getZ(s-1)===t.getZ(0))&&(t.setXYZ(s,t.getX(0),t.getY(0),t.getZ(0)),s++),o}(t,this.curves,e,n,this.autoClose).reduce(((t,e)=>t+e),0)}extractShapePointsToFlatArray(t,e=12){return this.subdivision=e,void 0===this.curveDivisions&&this.computeCurveDivisions(e),function(t,e,n=12,r=!0){let i,a=0;for(let s=0;s<e.length;s++){let r=e[s],o=wc(r,n),l=tc;for(let e=0;e<=o;e++)if(r instanceof P||r instanceof D||r instanceof C){if(r.getPoint(e/o,l),void 0!==i&&dc(i,l,Yd))continue;void 0===i&&(i=ec),i.copy(l),t.push(l.x,l.y),a++}}return hc(t[0],t[t.length-2],Yd)&&hc(t[1],t[t.length-1],Yd)&&(t.pop(),t.pop()),r&&a>1&&!(hc(t[a-1],t[1],Yd)&&hc(t[a-2],t[0],Yd))&&(t.push(t[0],t[1]),a++),t}(t,this.roundedCurves,e,this.autoClose)}getCurveIndexFromVertexId(t,e=!1){let n=0;void 0===this.curveDivisions&&this.computeCurveDivisions(this.subdivision);let r=e?this.roundedCurveDivisions:this.curveDivisions,i=0;e&&void 0!==this.points[0].roundedCurveCorner&&(i=.5*wc(this.points[0].roundedCurveCorner,this.subdivision));let a=t-i;a<0&&(a+=r.reduce(((t,e)=>t+e),0));for(let s=0,o=r.length;s<o;s++){let t=r[s];if(a<n+t)return[s,(a-n+1)/t];n+=t}return[0,1]}getCurveT(t,e,n){let r=this.points[t],i=this.points[t>=this.points.length-1?0:t+1],a=this.curveDivisions,s=a[t];if(yc(r,i)){let t=r.position.distanceTo(i.position);return r.position.distanceTo(Ac.set(n.x,n.y))/t}let o=0;for(let l=0;l<t;l++)o+=a[l];return(e-o)/s}dispose(){}_applyCurveForPoint(t,e){yc(e,t)?this.lineTo(t.position.x,t.position.y):this.bezierCurveTo(e.controls[1].position.x,e.controls[1].position.y,t.controls[0].position.x,t.controls[0].position.y,t.position.x,t.position.y);let n=this.curves[this.curves.length-1];t.curveBefore=n,e.curveAfter=n;let r=n.clone();t.roundedCurveBefore=r,e.roundedCurveAfter=r,t.roundedCurveCorner=void 0,this.roundedCurves.push(r)}_update(){if(this.curves=[],this.roundedCurves=[],!this.points.length)return;for(let e=0,n=this.points.length;e<n;e++){let t=this.points[e];if(0===e)this.moveTo(t.position.x,t.position.y);else{let n=this.points[e-1];this._applyCurveForPoint(t,n)}}let t=this.getLastPoint();if((null==t?void 0:t.curveAfter)&&(t.curveAfter=void 0),this.isClosed){let t=this.points[0],e=this.points[this.points.length-1];this._applyCurveForPoint(t,e)}if(this.points.length>2){let t=0;for(let e=0,n=this.points.length;e<n;e++){let n=this.points[e],r=this.points[e-1]??this.points[this.points.length-1],i=this.points[e+1]??this.points[0],a=n.roundness,s=r&&i&&pc(r,n,i);if(!n.controlsMoved()&&a>0&&!s){let r=n.curveBefore,i=n.curveAfter;if(void 0===r||void 0===i)continue;let s,o=n.roundedCurveBefore,l=n.roundedCurveAfter,h=r.getLength(),d=i.getLength(),c=Math.min(a,.499*h),u=Math.min(a,.499*d),p=Math.min(c,u),f=1-p/h,m=p/d,g=r.getPointAt(f,Ac),v=i.getPointAt(m,Oc);if(this._subSplitCurve(r,o,f,g,void 0),this._subSplitCurve(i,l,m,void 0,v),this.useCubicForRoundedCorners){let t=uc(g,n.position,v)/2,e=Math.tan(t)*g.distanceTo(n.position),[r,i]=mc(g,v,e,Mc,Cc),a=gc(r,i,n.position),[o,l]=vc(a,g,v,e,Pc,Dc);s=new P(g.clone(),o.clone(),l.clone(),v.clone())}else s=new D(g.clone(),n.position.clone(),v.clone());n.roundedCurveCorner=s,this.roundedCurves.splice(e+t,0,s),t++}}}}_subSplitCurve(t,e,n,r,i){if(!(t instanceof C)){let a=t,s=e,o=a.getUtoTmapping(n,0),l=function(t,e,n,r,i=.5){let a=tc.subVectors(e,t).multiplyScalar(i).add(t),s=ec.subVectors(n,e).multiplyScalar(i).add(e),o=nc.subVectors(r,n).multiplyScalar(i).add(n),l=a,h=rc.subVectors(s,a).multiplyScalar(i).add(a),d=ic.subVectors(o,s).multiplyScalar(i).add(s),c=o,u=ac.subVectors(d,h).multiplyScalar(i).add(h);return[t.x,t.y,l.x,l.y,h.x,h.y,u.x,u.y,d.x,d.y,c.x,c.y,r.x,r.y]}(a.v0,a.v1,a.v2,a.v3,o);return void 0!==r&&(s.v0.set(l[0],l[1]),s.v1.set(l[2],l[3]),s.v2.set(l[4],l[5]),s.v3.set(l[6],l[7])),void 0!==i&&(s.v0.set(l[6],l[7]),s.v1.set(l[8],l[9]),s.v2.set(l[10],l[11]),s.v3.set(l[12],l[13])),s}return void 0!==r&&e.v2.copy(r),void 0!==i&&e.v1.copy(i),e}clone(){let t=new Tc(this._width,this._height);return t.points=this.points.map((t=>t.clone())),t.isClosed=this.isClosed,t.roundness=this.roundness,t.isMesh2D=this.isMesh2D,t.shapeHoles=this.shapeHoles.map((t=>t.clone())),t}toJSON(){return{points:this.points.reduce(((t,e)=>t.concat(e.toJSON())),[]),shapeHoles:this.shapeHoles.map((t=>t.toJSON())),isClosed:this.isClosed,roundness:this.roundness}}fromJSON(t){var e;this.points=[],this.pointIDs=0;let n=t.points.length/7;for(let r=0;r<n;r++){let e=7*r,n=t.points[e+0],i=t.points[e+1],a=t.points[e+2],s=t.points[e+3],o=t.points[e+4],h=t.points[e+5],d=t.points[e+6],c=new Qd(x.generateUUID(),new l(n,i));c.controls[0].position.set(a,s),c.controls[1].position.set(o,h),c.roundness=d,this.points.push(c)}return this.shapeHoles=(null==(e=t.shapeHoles)?void 0:e.length)?t.shapeHoles.map((t=>{let e=new Tc;return e.fromJSON(t),e})):[],this.isClosed=t.isClosed,this._roundness=t.roundness,this._update(),this}fromShape(t,e=!1){this.isText=e;let n=(t,e)=>{e instanceof P&&e.v3.equals(t.position)&&t.controls[0].position.copy(e.v2)};return this.points=(t=>{let e,r,i=[];for(e=0,r=t.length;e<r;e++)t[e]instanceof D&&(t[e]=lc(t[e]));for(e=0,r=t.length;e<r;e++){let r,a=t[e],s=e>0?t[e-1]:null;a instanceof P?(r=this.createPoint(a.v0),r.controls[1].position.copy(a.v1)):a instanceof C&&(r=this.createPoint(a.v1)),void 0!==r&&(null!==s&&n(r,s),i.push(r))}let a=t[t.length-1],s=!1;return a instanceof P?a.v3.equals(i[0].position)&&(i[0].controls[0].position.copy(a.v2),s=!0):a instanceof C&&a.v2.equals(i[0].position)&&(s=!0),this.isClosed=s,i})(t.curves),t instanceof $&&(this.shapeHoles=t.holes.map((t=>{let e=new Tc;return e.fromShape(t),e}))),this.update(),this}updatePoint(t,e){let n=this.getPointByUuid(t);n&&(void 0!==e.position&&n.position.fromArray(e.position),void 0!==e.roundness&&(n.roundness=e.roundness),void 0!==e.areControlsDirectionsMirrored&&(n.areControlsDirectionsMirrored=e.areControlsDirectionsMirrored),this.needsUpdate=!0)}updatePreviousControl(t,e){var n;let r=null==(n=this.getPointByUuid(t))?void 0:n.controls[0];r&&(e.position&&r.position.fromArray(e.position),this.needsUpdate=!0)}updateNextControl(t,e){var n;let r=null==(n=this.getPointByUuid(t))?void 0:n.controls[1];r&&(e.position&&r.position.fromArray(e.position),this.needsUpdate=!0)}},zc=2*Math.PI;function Ec({x:t,y:e},n,r,i,a){return{x:t*n+i,y:e*r+a}}function Lc(t,e){let n=1.5707963267948966===e?.551915024494:-1.5707963267948966===e?-.551915024494:1.3333333333333333*Math.tan(e/4),r=Math.cos(t),i=Math.sin(t),a=Math.cos(t+e),s=Math.sin(t+e);return[{x:r-i*n,y:i+r*n},{x:a+s*n,y:s-a*n},{x:a,y:s}]}function Ic(t,e,n,r){let i=t*r-e*n<0?-1:1,a=Math.min(1,Math.max(-1,t*n+e*r));return i*Math.acos(a)}function Nc({px:t,py:e,cx:n,cy:r,rx:i,ry:a,largeArcFlag:s,sweepFlag:o}){let l=[];if(0===i||0===a)return[];let h=(t-n)/2,d=(e-r)/2;if(0===h&&0===d)return[];i=Math.abs(i),a=Math.abs(a);let c=Math.pow(h,2)/Math.pow(i,2)+Math.pow(d,2)/Math.pow(a,2);c>1&&(i*=Math.sqrt(c),a*=Math.sqrt(c));let u=function(t,e,n,r,i,a,s,o,l,h){let d=Math.pow(i,2),c=Math.pow(a,2),u=Math.pow(s,2),p=Math.pow(o,2),f=d*c-d*p-c*u;f<0&&(f=0),f/=d*p+c*u,f=Math.sqrt(f)*(l===h?-1:1);let m=f*i/a*o,g=f*-a/i*s,v=m+(t+n)/2,y=g+(e+r)/2,b=(s-m)/i,x=(o-g)/a,w=(-s-m)/i,_=(-o-g)/a,S=Ic(1,0,b,x),A=Ic(b,x,w,_);return!h&&A>0&&(A-=zc),h&&A<0&&(A+=zc),{centerx:v,centery:y,ang1:S,ang2:A}}(t,e,n,r,i,a,h,d,s,o),{ang1:p,ang2:f}=u,{centerx:m,centery:g}=u,v=Math.abs(f)/(zc/4);Math.abs(1-v)<1e-7&&(v=1);let y=Math.max(Math.ceil(v),1);f/=y;for(let b=0;b<y;b++)l.push(Lc(p,f)),p+=f;return l.map((t=>{let{x:e,y:n}=Ec(t[0],i,a,m,g),{x:r,y:s}=Ec(t[1],i,a,m,g),{x:o,y:l}=Ec(t[2],i,a,m,g);return{x1:e,y1:n,x2:r,y2:s,x:o,y:l}}))}function jc(t,e){if(!t)throw e||"Assertion Failed!"}!function(t){t[t.ODD=0]="ODD",t[t.NONZERO=1]="NONZERO",t[t.POSITIVE=2]="POSITIVE",t[t.NEGATIVE=3]="NEGATIVE",t[t.ABS_GEQ_TWO=4]="ABS_GEQ_TWO"}(_c||(_c={})),function(t){t[t.POLYGONS=0]="POLYGONS",t[t.CONNECTED_POLYGONS=1]="CONNECTED_POLYGONS",t[t.BOUNDARY_CONTOURS=2]="BOUNDARY_CONTOURS"}(Sc||(Sc={}));var Bc=function(){function t(){}return t.vertEq=function(t,e){return t.s===e.s&&t.t===e.t},t.vertLeq=function(t,e){return t.s<e.s||t.s===e.s&&t.t<=e.t},t.transLeq=function(t,e){return t.t<e.t||t.t===e.t&&t.s<=e.s},t.edgeGoesLeft=function(e){return t.vertLeq(e.Dst,e.Org)},t.edgeGoesRight=function(e){return t.vertLeq(e.Org,e.Dst)},t.vertL1dist=function(t,e){return Math.abs(t.s-e.s)+Math.abs(t.t-e.t)},t.edgeEval=function(e,n,r){jc(t.vertLeq(e,n)&&t.vertLeq(n,r));var i=n.s-e.s,a=r.s-n.s;return i+a>0?i<a?n.t-e.t+(e.t-r.t)*(i/(i+a)):n.t-r.t+(r.t-e.t)*(a/(i+a)):0},t.edgeSign=function(e,n,r){jc(t.vertLeq(e,n)&&t.vertLeq(n,r));var i=n.s-e.s,a=r.s-n.s;return i+a>0?(n.t-r.t)*i+(n.t-e.t)*a:0},t.transEval=function(e,n,r){jc(t.transLeq(e,n)&&t.transLeq(n,r));var i=n.t-e.t,a=r.t-n.t;return i+a>0?i<a?n.s-e.s+(e.s-r.s)*(i/(i+a)):n.s-r.s+(r.s-e.s)*(a/(i+a)):0},t.transSign=function(e,n,r){jc(t.transLeq(e,n)&&t.transLeq(n,r));var i=n.t-e.t,a=r.t-n.t;return i+a>0?(n.s-r.s)*i+(n.s-e.s)*a:0},t.vertCCW=function(t,e,n){return t.s*(e.t-n.t)+e.s*(n.t-t.t)+n.s*(t.t-e.t)>=0},t.interpolate=function(t,e,n,r){return(t=t<0?0:t)<=(n=n<0?0:n)?0===n?(e+r)/2:e+t/(t+n)*(r-e):r+n/(t+n)*(e-r)},t.intersect=function(e,n,r,i,a){var s,o,l;t.vertLeq(e,n)||(l=e,e=n,n=l),t.vertLeq(r,i)||(l=r,r=i,i=l),t.vertLeq(e,r)||(l=e,e=r,r=l,l=n,n=i,i=l),t.vertLeq(r,n)?t.vertLeq(n,i)?((s=t.edgeEval(e,r,n))+(o=t.edgeEval(r,n,i))<0&&(s=-s,o=-o),a.s=t.interpolate(s,r.s,o,n.s)):((s=t.edgeSign(e,r,n))+(o=-t.edgeSign(e,i,n))<0&&(s=-s,o=-o),a.s=t.interpolate(s,r.s,o,i.s)):a.s=(r.s+n.s)/2,t.transLeq(e,n)||(l=e,e=n,n=l),t.transLeq(r,i)||(l=r,r=i,i=l),t.transLeq(e,r)||(l=e,e=r,r=l,l=n,n=i,i=l),t.transLeq(r,n)?t.transLeq(n,i)?((s=t.transEval(e,r,n))+(o=t.transEval(r,n,i))<0&&(s=-s,o=-o),a.t=t.interpolate(s,r.t,o,n.t)):((s=t.transSign(e,r,n))+(o=-t.transSign(e,i,n))<0&&(s=-s,o=-o),a.t=t.interpolate(s,r.t,o,i.t)):a.t=(r.t+n.t)/2},t}(),Uc=function(){this.next=null,this.prev=null,this.anEdge=null,this.trail=null,this.n=0,this.marked=!1,this.inside=!1},kc=function(){function t(t){this.side=t,this.next=null,this.Org=null,this.Sym=null,this.Onext=null,this.Lnext=null,this.Lface=null,this.activeRegion=null,this.winding=0}return Object.defineProperty(t.prototype,"Rface",{get:function(){return this.Sym.Lface},set:function(t){this.Sym.Lface=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"Dst",{get:function(){return this.Sym.Org},set:function(t){this.Sym.Org=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"Oprev",{get:function(){return this.Sym.Lnext},set:function(t){this.Sym.Lnext=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"Lprev",{get:function(){return this.Onext.Sym},set:function(t){this.Onext.Sym=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"Dprev",{get:function(){return this.Lnext.Sym},set:function(t){this.Lnext.Sym=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"Rprev",{get:function(){return this.Sym.Onext},set:function(t){this.Sym.Onext=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"Dnext",{get:function(){return this.Sym.Onext.Sym},set:function(t){this.Sym.Onext.Sym=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"Rnext",{get:function(){return this.Sym.Lnext.Sym},set:function(t){this.Sym.Lnext.Sym=t},enumerable:!0,configurable:!0}),t}(),Rc=function(){this.next=null,this.prev=null,this.anEdge=null,this.coords=[0,0,0],this.s=0,this.t=0,this.pqHandle=0,this.n=0,this.idx=0},Fc=function(){function t(){var t=new Rc,e=new Uc,n=new kc(0),r=new kc(1);t.next=t.prev=t,t.anEdge=null,e.next=e.prev=e,n.next=n,n.Sym=r,r.next=r,r.Sym=n,this.vHead=t,this.fHead=e,this.eHead=n,this.eHeadSym=r}return t.prototype.makeEdge_=function(t){var e=new kc(0),n=new kc(1);t.Sym.side<t.side&&(t=t.Sym);var r=t.Sym.next;return n.next=r,r.Sym.next=e,e.next=t,t.Sym.next=n,e.Sym=n,e.Onext=e,e.Lnext=n,e.Org=null,e.Lface=null,e.winding=0,e.activeRegion=null,n.Sym=e,n.Onext=n,n.Lnext=e,n.Org=null,n.Lface=null,n.winding=0,n.activeRegion=null,e},t.prototype.splice_=function(t,e){var n=t.Onext,r=e.Onext;n.Sym.Lnext=e,r.Sym.Lnext=t,t.Onext=r,e.Onext=n},t.prototype.makeVertex_=function(t,e,n){var r=t;jc(r,"Vertex can't be null!");var i=n.prev;r.prev=i,i.next=r,r.next=n,n.prev=r,r.anEdge=e;var a=e;do{a.Org=r,a=a.Onext}while(a!==e)},t.prototype.makeFace_=function(t,e,n){var r=t;jc(r,"Face can't be null");var i=n.prev;r.prev=i,i.next=r,r.next=n,n.prev=r,r.anEdge=e,r.trail=null,r.marked=!1,r.inside=n.inside;var a=e;do{a.Lface=r,a=a.Lnext}while(a!==e)},t.prototype.killEdge_=function(t){t.Sym.side<t.side&&(t=t.Sym);var e=t.next,n=t.Sym.next;e.Sym.next=n,n.Sym.next=e},t.prototype.killVertex_=function(t,e){var n=t.anEdge,r=n;do{r.Org=e,r=r.Onext}while(r!==n);var i=t.prev,a=t.next;a.prev=i,i.next=a},t.prototype.killFace_=function(t,e){var n=t.anEdge,r=n;do{r.Lface=e,r=r.Lnext}while(r!==n);var i=t.prev,a=t.next;a.prev=i,i.next=a},t.prototype.makeEdge=function(){var t=new Rc,e=new Rc,n=new Uc,r=this.makeEdge_(this.eHead);return this.makeVertex_(t,r,this.vHead),this.makeVertex_(e,r.Sym,this.vHead),this.makeFace_(n,r,this.fHead),r},t.prototype.splice=function(t,e){var n=!1,r=!1;if(t!==e){if(e.Org!==t.Org&&(r=!0,this.killVertex_(e.Org,t.Org)),e.Lface!==t.Lface&&(n=!0,this.killFace_(e.Lface,t.Lface)),this.splice_(e,t),!r){var i=new Rc;this.makeVertex_(i,e,t.Org),t.Org.anEdge=t}if(!n){var a=new Uc;this.makeFace_(a,e,t.Lface),t.Lface.anEdge=t}}},t.prototype.delete=function(t){var e=t.Sym,n=!1;if(t.Lface!==t.Rface&&(n=!0,this.killFace_(t.Lface,t.Rface)),t.Onext===t)this.killVertex_(t.Org,null);else if(t.Rface.anEdge=t.Oprev,t.Org.anEdge=t.Onext,this.splice_(t,t.Oprev),!n){var r=new Uc;this.makeFace_(r,t,t.Lface)}e.Onext===e?(this.killVertex_(e.Org,null),this.killFace_(e.Lface,null)):(t.Lface.anEdge=e.Oprev,e.Org.anEdge=e.Onext,this.splice_(e,e.Oprev)),this.killEdge_(t)},t.prototype.addEdgeVertex=function(t){var e=this.makeEdge_(t),n=e.Sym;this.splice_(e,t.Lnext),e.Org=t.Dst;var r=new Rc;return this.makeVertex_(r,n,e.Org),e.Lface=n.Lface=t.Lface,e},t.prototype.splitEdge=function(t){var e=this.addEdgeVertex(t).Sym;return this.splice_(t.Sym,t.Sym.Oprev),this.splice_(t.Sym,e),t.Dst=e.Org,e.Dst.anEdge=e.Sym,e.Rface=t.Rface,e.winding=t.winding,e.Sym.winding=t.Sym.winding,e.idx=t.idx,e.Sym.idx=t.Sym.idx,e},t.prototype.connect=function(t,e){var n=!1,r=this.makeEdge_(t),i=r.Sym;if(e.Lface!==t.Lface&&(n=!0,this.killFace_(e.Lface,t.Lface)),this.splice_(r,t.Lnext),this.splice_(i,e),r.Org=t.Dst,i.Org=e.Org,r.Lface=i.Lface=t.Lface,t.Lface.anEdge=i,!n){var a=new Uc;this.makeFace_(a,r,t.Lface)}return r},t.prototype.zapFace=function(t){var e,n,r,i,a,s=t.anEdge;n=s.Lnext;do{n=(e=n).Lnext,e.Lface=null,null===e.Rface&&(e.Onext===e?this.killVertex_(e.Org,null):(e.Org.anEdge=e.Onext,this.splice_(e,e.Oprev)),(r=e.Sym).Onext===r?this.killVertex_(r.Org,null):(r.Org.anEdge=r.Onext,this.splice_(r,r.Oprev)),this.killEdge_(e))}while(e!=s);i=t.prev,(a=t.next).prev=i,i.next=a},t.prototype.countFaceVerts_=function(t){var e=t.anEdge,n=0;do{n++,e=e.Lnext}while(e!==t.anEdge);return n},t.prototype.mergeConvexFaces=function(t){var e,n,r,i,a;for(e=this.fHead.next;e!==this.fHead;e=e.next)if(e.inside)for(a=(n=e.anEdge).Org;r=n.Lnext,(i=n.Sym)&&i.Lface&&i.Lface.inside&&(this.countFaceVerts_(e)+this.countFaceVerts_(i.Lface)-2<=t&&Bc.vertCCW(n.Lprev.Org,n.Org,i.Lnext.Lnext.Org)&&Bc.vertCCW(i.Lprev.Org,i.Org,n.Lnext.Lnext.Org)&&(r=i.Lnext,this.delete(i),n=null,i=null)),!n||n.Lnext.Org!==a;)n=r;return!0},t.prototype.check=function(){var t,e,n,r,i,a,s=this.fHead,o=this.vHead,l=this.eHead;for(e=s,e=s;(t=e.next)!==s;e=t){jc(t.prev===e),i=t.anEdge;do{jc(i.Sym!==i),jc(i.Sym.Sym===i),jc(i.Lnext.Onext.Sym===i),jc(i.Onext.Sym.Lnext===i),jc(i.Lface===t),i=i.Lnext}while(i!==t.anEdge)}for(jc(t.prev===e&&null===t.anEdge),r=o,r=o;(n=r.next)!==o;r=n){jc(n.prev===r),i=n.anEdge;do{jc(i.Sym!==i),jc(i.Sym.Sym===i),jc(i.Lnext.Onext.Sym===i),jc(i.Onext.Sym.Lnext===i),jc(i.Org===n),i=i.Onext}while(i!==n.anEdge)}for(jc(n.prev===r&&null===n.anEdge),a=l,a=l;(i=a.next)!==l;a=i)jc(i.Sym.next===a.Sym),jc(i.Sym!==i),jc(i.Sym.Sym===i),jc(null!==i.Org),jc(null!==i.Dst),jc(i.Lnext.Onext.Sym===i),jc(i.Onext.Sym.Lnext===i);jc(i.Sym.next===a.Sym&&i.Sym===this.eHeadSym&&i.Sym.Sym===i&&null===i.Org&&null===i.Dst&&null===i.Lface&&null===i.Rface)},t}(),Vc=function(){this.handle=null},Gc=function(){this.key=null,this.node=0},Hc=function(){function t(t,e){this.leq=e,this.max=0,this.nodes=[],this.handles=[],this.initialized=!1,this.freeList=0,this.size=0,this.max=t,this.nodes=[],this.handles=[];for(var n=0;n<t+1;n++)this.nodes[n]=new Vc,this.handles[n]=new Gc;this.initialized=!1,this.nodes[1].handle=1,this.handles[1].key=null}return t.prototype.floatDown_=function(t){var e,n,r,i=this.nodes,a=this.handles;for(e=i[t].handle;;){if((r=t<<1)<this.size&&this.leq(a[i[r+1].handle].key,a[i[r].handle].key)&&++r,jc(r<=this.max),n=i[r].handle,r>this.size||this.leq(a[e].key,a[n].key)){i[t].handle=e,a[e].node=t;break}i[t].handle=n,a[n].node=t,t=r}},t.prototype.floatUp_=function(t){var e,n,r,i=this.nodes,a=this.handles;for(e=i[t].handle;;){if(n=i[r=t>>1].handle,0===r||this.leq(a[n].key,a[e].key)){i[t].handle=e,a[e].node=t;break}i[t].handle=n,a[n].node=t,t=r}},t.prototype.init=function(){for(var t=this.size;t>=1;--t)this.floatDown_(t);this.initialized=!0},t.prototype.min=function(){return this.handles[this.nodes[1].handle].key},t.prototype.insert=function(t){var e,n;if(2*(e=++this.size)>this.max){var r,i;for(this.max*=2,i=this.nodes.length,this.nodes.length=this.max+1,r=i;r<this.nodes.length;r++)this.nodes[r]=new Vc;for(i=this.handles.length,this.handles.length=this.max+1,r=i;r<this.handles.length;r++)this.handles[r]=new Gc}return 0===this.freeList?n=e:(n=this.freeList,this.freeList=this.handles[n].node),this.nodes[e].handle=n,this.handles[n].node=e,this.handles[n].key=t,this.initialized&&this.floatUp_(e),n},t.prototype.extractMin=function(){var t=this.nodes,e=this.handles,n=t[1].handle,r=e[n].key;return this.size>0&&(t[1].handle=t[this.size].handle,e[t[1].handle].node=1,e[n].key=null,e[n].node=this.freeList,this.freeList=n,--this.size,this.size>0&&this.floatDown_(1)),r},t.prototype.delete=function(t){var e,n=this.nodes,r=this.handles;jc(t>=1&&t<=this.max&&null!==r[t].key),n[e=r[t].node].handle=n[this.size].handle,r[n[e].handle].node=e,--this.size,e<=this.size&&(e<=1||this.leq(r[n[e>>1].handle].key,r[n[e].handle].key)?this.floatDown_(e):this.floatUp_(e)),r[t].key=null,r[t].node=this.freeList,this.freeList=t},t}(),Wc=function(){this.eUp=null,this.nodeUp=null,this.windingNumber=0,this.inside=!1,this.sentinel=!1,this.dirty=!1,this.fixUpperEdge=!1},qc=function(){this.key=null,this.next=null,this.prev=null},$c=function(){function t(t,e){this.frame=t,this.leq=e,this.head=new qc,this.head.next=this.head,this.head.prev=this.head}return t.prototype.min=function(){return this.head.next},t.prototype.max=function(){return this.head.prev},t.prototype.insert=function(t){return this.insertBefore(this.head,t)},t.prototype.search=function(t){var e=this.head;do{e=e.next}while(null!==e.key&&!this.leq(this.frame,t,e.key));return e},t.prototype.insertBefore=function(t,e){do{t=t.prev}while(null!==t.key&&!this.leq(this.frame,t.key,e));var n=new qc;return n.key=e,n.next=t.next,t.next.prev=n,n.prev=t,t.next=n,n},t.prototype.delete=function(t){t.next.prev=t.prev,t.prev.next=t.next},t}(),Xc=function(){function t(){}return t.regionBelow=function(t){return t.nodeUp.prev.key},t.regionAbove=function(t){return t.nodeUp.next.key},t.debugEvent=function(t){},t.addWinding=function(t,e){t.winding+=e.winding,t.Sym.winding+=e.Sym.winding},t.edgeLeq=function(t,e,n){var r=t.event,i=e.eUp,a=n.eUp;return i.Dst===r?a.Dst===r?Bc.vertLeq(i.Org,a.Org)?Bc.edgeSign(a.Dst,i.Org,a.Org)<=0:Bc.edgeSign(i.Dst,a.Org,i.Org)>=0:Bc.edgeSign(a.Dst,r,a.Org)<=0:a.Dst===r?Bc.edgeSign(i.Dst,r,i.Org)>=0:Bc.edgeEval(i.Dst,r,i.Org)>=Bc.edgeEval(a.Dst,r,a.Org)},t.deleteRegion=function(t,e){e.fixUpperEdge&&jc(0===e.eUp.winding),e.eUp.activeRegion=null,t.dict.delete(e.nodeUp)},t.fixUpperEdge=function(t,e,n){jc(e.fixUpperEdge),t.mesh.delete(e.eUp),e.fixUpperEdge=!1,e.eUp=n,n.activeRegion=e},t.topLeftRegion=function(e,n){var r,i=n.eUp.Org;do{n=t.regionAbove(n)}while(n.eUp.Org===i);if(n.fixUpperEdge){if(null===(r=e.mesh.connect(t.regionBelow(n).eUp.Sym,n.eUp.Lnext)))return null;t.fixUpperEdge(e,n,r),n=t.regionAbove(n)}return n},t.topRightRegion=function(e){var n=e.eUp.Dst;do{e=t.regionAbove(e)}while(e.eUp.Dst===n);return e},t.addRegionBelow=function(t,e,n){var r=new Wc;return r.eUp=n,r.nodeUp=t.dict.insertBefore(e.nodeUp,r),r.fixUpperEdge=!1,r.sentinel=!1,r.dirty=!1,n.activeRegion=r,r},t.isWindingInside=function(t,e){switch(t.windingRule){case _c.ODD:return 0!=(1&e);case _c.NONZERO:return 0!==e;case _c.POSITIVE:return e>0;case _c.NEGATIVE:return e<0;case _c.ABS_GEQ_TWO:return e>=2||e<=-2}throw new Error("Invalid winding rulle")},t.computeWinding=function(e,n){n.windingNumber=t.regionAbove(n).windingNumber+n.eUp.winding,n.inside=t.isWindingInside(e,n.windingNumber)},t.finishRegion=function(e,n){var r=n.eUp,i=r.Lface;i.inside=n.inside,i.anEdge=r,t.deleteRegion(e,n)},t.finishLeftRegions=function(e,n,r){for(var i,a=null,s=n,o=n.eUp;s!==r;){if(s.fixUpperEdge=!1,(i=(a=t.regionBelow(s)).eUp).Org!=o.Org){if(!a.fixUpperEdge){t.finishRegion(e,s);break}i=e.mesh.connect(o.Lprev,i.Sym),t.fixUpperEdge(e,a,i)}o.Onext!==i&&(e.mesh.splice(i.Oprev,i),e.mesh.splice(o,i)),t.finishRegion(e,s),o=a.eUp,s=a}return o},t.addRightEdges=function(e,n,r,i,a,s){var o,l,h,d,c=!0;h=r;do{jc(Bc.vertLeq(h.Org,h.Dst)),t.addRegionBelow(e,n,h.Sym),h=h.Onext}while(h!==i);for(null===a&&(a=t.regionBelow(n).eUp.Rprev),l=n,d=a;(h=(o=t.regionBelow(l)).eUp.Sym).Org===d.Org;)h.Onext!==d&&(e.mesh.splice(h.Oprev,h),e.mesh.splice(d.Oprev,h)),o.windingNumber=l.windingNumber-h.winding,o.inside=t.isWindingInside(e,o.windingNumber),l.dirty=!0,!c&&t.checkForRightSplice(e,l)&&(t.addWinding(h,d),t.deleteRegion(e,l),e.mesh.delete(d)),c=!1,l=o,d=h;l.dirty=!0,jc(l.windingNumber-h.winding===o.windingNumber),s&&t.walkDirtyRegions(e,l)},t.spliceMergeVertices=function(t,e,n){t.mesh.splice(e,n)},t.vertexWeights=function(t,e,n){var r=Bc.vertL1dist(e,t),i=Bc.vertL1dist(n,t),a=.5*i/(r+i),s=.5*r/(r+i);t.coords[0]+=a*e.coords[0]+s*n.coords[0],t.coords[1]+=a*e.coords[1]+s*n.coords[1],t.coords[2]+=a*e.coords[2]+s*n.coords[2]},t.getIntersectData=function(e,n,r,i,a,s){n.coords[0]=n.coords[1]=n.coords[2]=0,n.idx=-1,t.vertexWeights(n,r,i),t.vertexWeights(n,a,s)},t.checkForRightSplice=function(e,n){var r=t.regionBelow(n),i=n.eUp,a=r.eUp;if(Bc.vertLeq(i.Org,a.Org)){if(Bc.edgeSign(a.Dst,i.Org,a.Org)>0)return!1;Bc.vertEq(i.Org,a.Org)?i.Org!==a.Org&&(e.pq.delete(i.Org.pqHandle),t.spliceMergeVertices(e,a.Oprev,i)):(e.mesh.splitEdge(a.Sym),e.mesh.splice(i,a.Oprev),n.dirty=r.dirty=!0)}else{if(Bc.edgeSign(i.Dst,a.Org,i.Org)<0)return!1;t.regionAbove(n).dirty=n.dirty=!0,e.mesh.splitEdge(i.Sym),e.mesh.splice(a.Oprev,i)}return!0},t.checkForLeftSplice=function(e,n){var r,i=t.regionBelow(n),a=n.eUp,s=i.eUp;if(jc(!Bc.vertEq(a.Dst,s.Dst)),Bc.vertLeq(a.Dst,s.Dst)){if(Bc.edgeSign(a.Dst,s.Dst,a.Org)<0)return!1;t.regionAbove(n).dirty=n.dirty=!0,r=e.mesh.splitEdge(a),e.mesh.splice(s.Sym,r),r.Lface.inside=n.inside}else{if(Bc.edgeSign(s.Dst,a.Dst,s.Org)>0)return!1;n.dirty=i.dirty=!0,r=e.mesh.splitEdge(s),e.mesh.splice(a.Lnext,s.Sym),r.Rface.inside=n.inside}return!0},t.checkForIntersect=function(e,n){var r,i,a=t.regionBelow(n),s=n.eUp,o=a.eUp,l=s.Org,h=o.Org,d=s.Dst,c=o.Dst,u=new Rc;if(jc(!Bc.vertEq(c,d)),jc(Bc.edgeSign(d,e.event,l)<=0),jc(Bc.edgeSign(c,e.event,h)>=0),jc(l!==e.event&&h!==e.event),jc(!n.fixUpperEdge&&!a.fixUpperEdge),l===h||Math.min(l.t,d.t)>Math.max(h.t,c.t))return!1;if(Bc.vertLeq(l,h)){if(Bc.edgeSign(c,l,h)>0)return!1}else if(Bc.edgeSign(d,h,l)<0)return!1;return t.debugEvent(e),Bc.intersect(d,l,c,h,u),jc(Math.min(l.t,d.t)<=u.t),jc(u.t<=Math.max(h.t,c.t)),jc(Math.min(c.s,d.s)<=u.s),jc(u.s<=Math.max(h.s,l.s)),Bc.vertLeq(u,e.event)&&(u.s=e.event.s,u.t=e.event.t),r=Bc.vertLeq(l,h)?l:h,Bc.vertLeq(r,u)&&(u.s=r.s,u.t=r.t),Bc.vertEq(u,l)||Bc.vertEq(u,h)?(t.checkForRightSplice(e,n),!1):!Bc.vertEq(d,e.event)&&Bc.edgeSign(d,e.event,u)>=0||!Bc.vertEq(c,e.event)&&Bc.edgeSign(c,e.event,u)<=0?c===e.event?(e.mesh.splitEdge(s.Sym),e.mesh.splice(o.Sym,s),n=t.topLeftRegion(e,n),s=t.regionBelow(n).eUp,t.finishLeftRegions(e,t.regionBelow(n),a),t.addRightEdges(e,n,s.Oprev,s,s,!0),!0):d===e.event?(e.mesh.splitEdge(o.Sym),e.mesh.splice(s.Lnext,o.Oprev),a=n,n=t.topRightRegion(n),i=t.regionBelow(n).eUp.Rprev,a.eUp=o.Oprev,o=t.finishLeftRegions(e,a,null),t.addRightEdges(e,n,o.Onext,s.Rprev,i,!0),!0):(Bc.edgeSign(d,e.event,u)>=0&&(t.regionAbove(n).dirty=n.dirty=!0,e.mesh.splitEdge(s.Sym),s.Org.s=e.event.s,s.Org.t=e.event.t),Bc.edgeSign(c,e.event,u)<=0&&(n.dirty=a.dirty=!0,e.mesh.splitEdge(o.Sym),o.Org.s=e.event.s,o.Org.t=e.event.t),!1):(e.mesh.splitEdge(s.Sym),e.mesh.splitEdge(o.Sym),e.mesh.splice(o.Oprev,s),s.Org.s=u.s,s.Org.t=u.t,s.Org.pqHandle=e.pq.insert(s.Org),t.getIntersectData(e,s.Org,l,d,h,c),t.regionAbove(n).dirty=n.dirty=a.dirty=!0,!1)},t.walkDirtyRegions=function(e,n){for(var r,i,a=t.regionBelow(n);;){for(;a.dirty;)n=a,a=t.regionBelow(a);if(!n.dirty&&(a=n,null===(n=t.regionAbove(n))||!n.dirty))return;if(n.dirty=!1,r=n.eUp,i=a.eUp,r.Dst!==i.Dst&&t.checkForLeftSplice(e,n)&&(a.fixUpperEdge?(t.deleteRegion(e,a),e.mesh.delete(i),i=(a=t.regionBelow(n)).eUp):n.fixUpperEdge&&(t.deleteRegion(e,n),e.mesh.delete(r),r=(n=t.regionAbove(a)).eUp)),r.Org!==i.Org)if(r.Dst===i.Dst||n.fixUpperEdge||a.fixUpperEdge||r.Dst!==e.event&&i.Dst!==e.event)t.checkForRightSplice(e,n);else if(t.checkForIntersect(e,n))return;r.Org===i.Org&&r.Dst===i.Dst&&(t.addWinding(i,r),t.deleteRegion(e,n),e.mesh.delete(r),n=t.regionAbove(a))}},t.connectRightVertex=function(e,n,r){var i,a=r.Onext,s=t.regionBelow(n),o=n.eUp,l=s.eUp,h=!1;o.Dst!==l.Dst&&t.checkForIntersect(e,n),Bc.vertEq(o.Org,e.event)&&(e.mesh.splice(a.Oprev,o),n=t.topLeftRegion(e,n),a=t.regionBelow(n).eUp,t.finishLeftRegions(e,t.regionBelow(n),s),h=!0),Bc.vertEq(l.Org,e.event)&&(e.mesh.splice(r,l.Oprev),r=t.finishLeftRegions(e,s,null),h=!0),h?t.addRightEdges(e,n,r.Onext,a,a,!0):(i=Bc.vertLeq(l.Org,o.Org)?l.Oprev:o,i=e.mesh.connect(r.Lprev,i),t.addRightEdges(e,n,i,i.Onext,i.Onext,!1),i.Sym.activeRegion.fixUpperEdge=!0,t.walkDirtyRegions(e,n))},t.connectLeftDegenerate=function(e,n,r){var i,a,s,o,l;return i=n.eUp,Bc.vertEq(i.Org,r)?(jc(!1),void t.spliceMergeVertices(e,i,r.anEdge)):Bc.vertEq(i.Dst,r)?(jc(!1),n=t.topRightRegion(n),a=o=(s=(l=t.regionBelow(n)).eUp.Sym).Onext,l.fixUpperEdge&&(jc(a!==s),t.deleteRegion(e,l),e.mesh.delete(s),s=a.Oprev),e.mesh.splice(r.anEdge,s),Bc.edgeGoesLeft(a)||(a=null),void t.addRightEdges(e,n,s.Onext,o,a,!0)):(e.mesh.splitEdge(i.Sym),n.fixUpperEdge&&(e.mesh.delete(i.Onext),n.fixUpperEdge=!1),e.mesh.splice(r.anEdge,i),void t.sweepEvent(e,r))},t.connectLeftVertex=function(e,n){var r,i,a,s,o,l,h=new Wc;if(h.eUp=n.anEdge.Sym,r=e.dict.search(h).key,i=t.regionBelow(r)){if(s=r.eUp,o=i.eUp,0===Bc.edgeSign(s.Dst,n,s.Org))return void t.connectLeftDegenerate(e,r,n);if(a=Bc.vertLeq(o.Dst,s.Dst)?r:i,r.inside||a.fixUpperEdge){if(a===r)l=e.mesh.connect(n.anEdge.Sym,s.Lnext);else l=e.mesh.connect(o.Dnext,n.anEdge).Sym;a.fixUpperEdge?t.fixUpperEdge(e,a,l):t.computeWinding(e,t.addRegionBelow(e,r,l)),t.sweepEvent(e,n)}else t.addRightEdges(e,r,n.anEdge,n.anEdge,null,!0)}},t.sweepEvent=function(e,n){e.event=n,t.debugEvent(e);for(var r=n.anEdge;null===r.activeRegion;)if((r=r.Onext)===n.anEdge)return void t.connectLeftVertex(e,n);var i=t.topLeftRegion(e,r.activeRegion);jc(null!==i);var a=t.regionBelow(i),s=a.eUp,o=t.finishLeftRegions(e,a,null);o.Onext===s?t.connectRightVertex(e,i,o):t.addRightEdges(e,i,o.Onext,s,s,!0)},t.addSentinel=function(t,e,n,r){var i=new Wc,a=t.mesh.makeEdge();a.Org.s=n,a.Org.t=r,a.Dst.s=e,a.Dst.t=r,t.event=a.Dst,i.eUp=a,i.windingNumber=0,i.inside=!1,i.fixUpperEdge=!1,i.sentinel=!0,i.dirty=!1,i.nodeUp=t.dict.insert(i)},t.initEdgeDict=function(e){e.dict=new $c(e,t.edgeLeq);var n=e.bmax[0]-e.bmin[0],r=e.bmax[1]-e.bmin[1],i=e.bmin[0]-n,a=e.bmax[0]+n,s=e.bmin[1]-r,o=e.bmax[1]+r;t.addSentinel(e,i,a,s),t.addSentinel(e,i,a,o)},t.doneEdgeDict=function(e){for(var n,r=0;null!==(n=e.dict.min().key);)n.sentinel||(jc(n.fixUpperEdge),jc(1==++r)),jc(0===n.windingNumber),t.deleteRegion(e,n)},t.removeDegenerateEdges=function(e){var n,r,i,a=e.mesh.eHead;for(n=a.next;n!==a;n=r)r=n.next,i=n.Lnext,Bc.vertEq(n.Org,n.Dst)&&n.Lnext.Lnext!==n&&(t.spliceMergeVertices(e,i,n),e.mesh.delete(n),i=(n=i).Lnext),i.Lnext===n&&(i!==n&&((i===r||i===r.Sym)&&(r=r.next),e.mesh.delete(i)),(n===r||n===r.Sym)&&(r=r.next),e.mesh.delete(n))},t.initPriorityQ=function(t){var e,n,r,i=0;for(n=(r=t.mesh.vHead).next;n!==r;n=n.next)i++;for(i+=8,e=t.pq=new Hc(i,Bc.vertLeq),n=(r=t.mesh.vHead).next;n!==r;n=n.next)n.pqHandle=e.insert(n);return n===r&&(e.init(),!0)},t.donePriorityQ=function(t){t.pq=null},t.removeDegenerateFaces=function(e,n){var r,i,a;for(r=n.fHead.next;r!==n.fHead;r=i)i=r.next,jc((a=r.anEdge).Lnext!==a),a.Lnext.Lnext===a&&(t.addWinding(a.Onext,a),e.mesh.delete(a));return!0},t.computeInterior=function(e,n){var r,i;if(void 0===n&&(n=!0),t.removeDegenerateEdges(e),!t.initPriorityQ(e))return!1;for(t.initEdgeDict(e);null!==(r=e.pq.extractMin());){for(;null!==(i=e.pq.min())&&Bc.vertEq(i,r);)i=e.pq.extractMin(),t.spliceMergeVertices(e,r.anEdge,i.anEdge);t.sweepEvent(e,r)}return e.event=e.dict.min().key.eUp.Org,t.debugEvent(e),t.doneEdgeDict(e),t.donePriorityQ(e),!!t.removeDegenerateFaces(e,e.mesh)&&(n&&e.mesh.check(),!0)},t}(),Yc=function(){function t(){this.mesh=new Fc,this.normal=[0,0,0],this.sUnit=[0,0,0],this.tUnit=[0,0,0],this.bmin=[0,0],this.bmax=[0,0],this.windingRule=_c.ODD,this.dict=null,this.pq=null,this.event=null,this.vertexIndexCounter=0,this.vertices=[],this.vertexIndices=[],this.vertexCount=0,this.elements=[],this.elementCount=0}return t.prototype.dot_=function(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]},t.prototype.normalize_=function(t){var e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2];if(!e)throw"Zero-size vector!";e=Math.sqrt(e),t[0]/=e,t[1]/=e,t[2]/=e},t.prototype.longAxis_=function(t){var e=0;return Math.abs(t[1])>Math.abs(t[0])&&(e=1),Math.abs(t[2])>Math.abs(t[e])&&(e=2),e},t.prototype.computeNormal_=function(t){var e,n,r,i,a,s,o=[0,0,0],l=[0,0,0],h=[0,0,0],d=[0,0,0],c=[0,0,0],u=[null,null,null],p=[null,null,null],f=this.mesh.vHead;e=f.next;for(var m=0;m<3;++m)i=e.coords[m],l[m]=i,p[m]=e,o[m]=i,u[m]=e;for(e=f.next;e!==f;e=e.next)for(var g=0;g<3;++g)(i=e.coords[g])<l[g]&&(l[g]=i,p[g]=e),i>o[g]&&(o[g]=i,u[g]=e);var v=0;if(o[1]-l[1]>o[0]-l[0]&&(v=1),o[2]-l[2]>o[v]-l[v]&&(v=2),l[v]>=o[v])return t[0]=0,t[1]=0,void(t[2]=1);for(s=0,n=p[v],r=u[v],h[0]=n.coords[0]-r.coords[0],h[1]=n.coords[1]-r.coords[1],h[2]=n.coords[2]-r.coords[2],e=f.next;e!==f;e=e.next)d[0]=e.coords[0]-r.coords[0],d[1]=e.coords[1]-r.coords[1],d[2]=e.coords[2]-r.coords[2],c[0]=h[1]*d[2]-h[2]*d[1],c[1]=h[2]*d[0]-h[0]*d[2],c[2]=h[0]*d[1]-h[1]*d[0],(a=c[0]*c[0]+c[1]*c[1]+c[2]*c[2])>s&&(s=a,t[0]=c[0],t[1]=c[1],t[2]=c[2]);s<=0&&(t[0]=t[1]=t[2]=0,t[this.longAxis_(h)]=1)},t.prototype.checkOrientation_=function(){for(var t,e,n=this.mesh.fHead,r=this.mesh.vHead,i=0,a=n.next;a!==n;a=a.next)if(!((e=a.anEdge).winding<=0))do{i+=(e.Org.s-e.Dst.s)*(e.Org.t+e.Dst.t),e=e.Lnext}while(e!==a.anEdge);if(i<0){for(t=r.next;t!==r;t=t.next)t.t=-t.t;this.tUnit[0]=-this.tUnit[0],this.tUnit[1]=-this.tUnit[1],this.tUnit[2]=-this.tUnit[2]}},t.prototype.projectPolygon_=function(){var t,e,n=this.mesh.vHead,r=[0,0,0],i=!1;r[0]=this.normal[0],r[1]=this.normal[1],r[2]=this.normal[2],!r[0]&&!r[1]&&!r[2]&&(this.computeNormal_(r),i=!0),t=this.sUnit,e=this.tUnit;var a=this.longAxis_(r);t[a]=0,t[(a+1)%3]=1,t[(a+2)%3]=0,e[a]=0,e[(a+1)%3]=0,e[(a+2)%3]=r[a]>0?1:-1;for(var s=n.next;s!==n;s=s.next)s.s=this.dot_(s.coords,t),s.t=this.dot_(s.coords,e);i&&this.checkOrientation_();for(var o=!0,l=n.next;l!==n;l=l.next)o?(this.bmin[0]=this.bmax[0]=l.s,this.bmin[1]=this.bmax[1]=l.t,o=!1):(l.s<this.bmin[0]&&(this.bmin[0]=l.s),l.s>this.bmax[0]&&(this.bmax[0]=l.s),l.t<this.bmin[1]&&(this.bmin[1]=l.t),l.t>this.bmax[1]&&(this.bmax[1]=l.t))},t.prototype.addWinding_=function(t,e){t.winding+=e.winding,t.Sym.winding+=e.Sym.winding},t.prototype.tessellateMonoRegion_=function(t,e){var n,r;if((n=e.anEdge).Lnext===n||n.Lnext.Lnext===n)throw"Mono region invalid";for(;Bc.vertLeq(n.Dst,n.Org);n=n.Lprev);for(;Bc.vertLeq(n.Org,n.Dst);n=n.Lnext);r=n.Lprev;for(;n.Lnext!==r;)if(Bc.vertLeq(n.Dst,r.Org)){for(;r.Lnext!==n&&(Bc.edgeGoesLeft(r.Lnext)||Bc.edgeSign(r.Org,r.Dst,r.Lnext.Dst)<=0);)r=t.connect(r.Lnext,r).Sym;r=r.Lprev}else{for(;r.Lnext!==n&&(Bc.edgeGoesRight(n.Lprev)||Bc.edgeSign(n.Dst,n.Org,n.Lprev.Org)>=0);)n=t.connect(n,n.Lprev).Sym;n=n.Lnext}if(r.Lnext===n)throw"Mono region invalid";for(;r.Lnext.Lnext!==n;)r=t.connect(r.Lnext,r).Sym;return!0},t.prototype.tessellateInterior_=function(t){for(var e,n=t.fHead.next;n!==t.fHead;n=e)if(e=n.next,n.inside&&!this.tessellateMonoRegion_(t,n))return!1;return!0},t.prototype.discardExterior_=function(t){for(var e,n=t.fHead.next;n!==t.fHead;n=e)e=n.next,n.inside||t.zapFace(n)},t.prototype.setWindingNumber_=function(t,e,n){for(var r,i=t.eHead.next;i!==t.eHead;i=r)r=i.next,i.Rface.inside!==i.Lface.inside?i.winding=i.Lface.inside?e:-e:n?t.delete(i):i.winding=0},t.prototype.getNeighbourFace_=function(t){return t.Rface&&t.Rface.inside?t.Rface.n:-1},t.prototype.outputPolymesh_=function(t,e,n,r){var i,a,s=0,o=0;n>3&&t.mergeConvexFaces(n);for(var l=t.vHead.next;l!==t.vHead;l=l.next)l.n=-1;for(var h=t.fHead.next;h!==t.fHead;h=h.next)if(h.n=-1,h.inside){i=h.anEdge,a=0;do{-1===(l=i.Org).n&&(l.n=o,o++),a++,i=i.Lnext}while(i!==h.anEdge);if(a>n)throw"Face vertex greater that support polygon";h.n=s,++s}this.elementCount=s,e===Sc.CONNECTED_POLYGONS&&(s*=2),this.elements=[],this.elements.length=s*n,this.vertexCount=o,this.vertices=[],this.vertices.length=o*r,this.vertexIndices=[],this.vertexIndices.length=o;for(l=t.vHead.next;l!==t.vHead;l=l.next)if(-1!==l.n){var d=l.n*r;this.vertices[d+0]=l.coords[0],this.vertices[d+1]=l.coords[1],r>2&&(this.vertices[d+2]=l.coords[2]),this.vertexIndices[l.n]=l.idx}var c=0;for(h=t.fHead.next;h!==t.fHead;h=h.next)if(h.inside){i=h.anEdge,a=0;do{l=i.Org;this.elements[c++]=l.n,a++,i=i.Lnext}while(i!==h.anEdge);for(var u=a;u<n;++u)this.elements[c++]=-1;if(e===Sc.CONNECTED_POLYGONS){i=h.anEdge;do{this.elements[c++]=this.getNeighbourFace_(i),i=i.Lnext}while(i!==h.anEdge);for(var p=a;p<n;++p)this.elements[c++]=-1}}},t.prototype.outputContours_=function(t,e){var n,r,i=0,a=0;this.vertexCount=0,this.elementCount=0;for(var s=t.fHead.next;s!==t.fHead;s=s.next)if(s.inside){r=n=s.anEdge;do{this.vertexCount++,n=n.Lnext}while(n!==r);this.elementCount++}this.elements=[],this.elements.length=2*this.elementCount,this.vertices=[],this.vertices.length=this.vertexCount*e,this.vertexIndices=[],this.vertexIndices.length=this.vertexCount;var o=0,l=0,h=0;i=0;for(s=t.fHead.next;s!==t.fHead;s=s.next)if(s.inside){a=0,r=n=s.anEdge;do{this.vertices[o++]=n.Org.coords[0],this.vertices[o++]=n.Org.coords[1],e>2&&(this.vertices[o++]=n.Org.coords[2]),this.vertexIndices[l++]=this.vertexIdCallback?this.vertexIdCallback(n):n.Org.idx,a++,n=n.Lnext}while(n!==r);this.elements[h++]=i,this.elements[h++]=a,i+=a}},t.prototype.addContour=function(t,e){null===this.mesh&&(this.mesh=new Fc),t<2&&(t=2),t>3&&(t=3);for(var n=null,r=0;r<e.length;r+=t)null===n?(n=this.mesh.makeEdge(),this.mesh.splice(n,n.Sym)):(this.mesh.splitEdge(n),n=n.Lnext),n.Org.coords[0]=e[r+0],n.Org.coords[1]=e[r+1],n.Org.coords[2]=t>2?e[r+2]:0,n.Org.idx=this.vertexIndexCounter++,this.edgeCreateCallback&&this.edgeCreateCallback(n),n.winding=1,n.Sym.winding=-1},t.prototype.tesselate=function(t,e,n,r,i,a){if(void 0===t&&(t=_c.ODD),void 0===e&&(e=Sc.POLYGONS),void 0===a&&(a=!0),this.vertices=[],this.elements=[],this.vertexIndices=[],this.vertexIndexCounter=0,i&&(this.normal[0]=i[0],this.normal[1]=i[1],this.normal[2]=i[2]),this.windingRule=t,r<2&&(r=2),r>3&&(r=3),!this.mesh)return!1;this.projectPolygon_(),Xc.computeInterior(this,a);var s=this.mesh;return e===Sc.BOUNDARY_CONTOURS?this.setWindingNumber_(s,1,!0):this.tessellateInterior_(s),a&&s.check(),e===Sc.BOUNDARY_CONTOURS?this.outputContours_(s,r):this.outputPolymesh_(s,e,n,r),!0},t}();function Kc(t){var e=t.windingRule,n=void 0===e?_c.ODD:e,r=t.elementType,i=void 0===r?Sc.POLYGONS:r,a=t.polySize,s=void 0===a?3:a,o=t.vertexSize,l=void 0===o?2:o,h=t.normal,d=void 0===h?[0,0,1]:h,c=t.contours,u=void 0===c?[]:c,p=t.strict,f=void 0===p||p,m=t.debug,g=void 0!==m&&m;if(!u&&f)throw new Error("Contours can't be empty");if(u){var v=new Yc;t.edgeCreateCallback&&(v.edgeCreateCallback=t.edgeCreateCallback),t.vertexIdCallback&&(v.vertexIdCallback=t.vertexIdCallback);for(var y=0;y<u.length;y++)v.addContour(l||2,u[y]);return v.tesselate(n,i,s,l,d,f),{vertices:v.vertices,vertexIndices:v.vertexIndices,vertexCount:v.vertexCount,elements:v.elements,elementCount:v.elementCount,mesh:g?v.mesh:void 0}}}_c.ODD,_c.NONZERO,_c.POSITIVE,_c.NEGATIVE,_c.ABS_GEQ_TWO,Sc.POLYGONS,Sc.CONNECTED_POLYGONS,Sc.BOUNDARY_CONTOURS;var Zc=class{constructor(t=256,e=!1){this.capacity=t,this.size=0,this.debug=e,this.debug&&console.log(`allocating with cap ${t}`);let n=t*Zc.eSize;this.buffer=new ArrayBuffer(n);let r=Float32Array.BYTES_PER_ELEMENT,i=0;this.positions=new Float32Array(this.buffer,i*r,3*t),i+=3*t,this.normals=new Float32Array(this.buffer,i*r,3*t),i+=3*t,this.uvs=new Float32Array(this.buffer,i*r,2*t)}realloc(t,e=!1){if(t<this.size)throw Error("cannot shrink buffer");if(t<=this.capacity&&!e)return;this.debug&&console.log(`resizing from ${this.capacity}  ${t}`);let n=t*Zc.eSize,r=new ArrayBuffer(n),i=Float32Array.BYTES_PER_ELEMENT,a=0,s=new Float32Array(r,a*i,3*t);a+=3*t;let o=new Float32Array(r,a*i,3*t);a+=3*t;let l=new Float32Array(r,a*i,2*t);e?(s.set(this.positions.subarray(0,3*this.size)),o.set(this.normals.subarray(0,3*this.size)),l.set(this.uvs.subarray(0,2*this.size))):(s.set(this.positions),o.set(this.normals),l.set(this.uvs)),this.buffer=r,this.positions=s,this.normals=o,this.uvs=l,this.capacity=t}get(t=1){let e=this.size+t;if(e>this.capacity){let t=this.capacity;for(;e>t;)t*=2;this.realloc(t)}let n=this.size;return this.size=e,n}reserve(t){let e=this.size+t;e>this.capacity&&this.realloc(e)}shrink(){this.debug&&console.log(`shrinking ${this.capacity}  ${this.size}`),this.realloc(this.size,!0)}},Qc=Zc;Qc.eSize=8*Float32Array.BYTES_PER_ELEMENT;var Jc=Ht(Xt()),tu={vertices:[160,160,-160,160,-160,-160,160,-160],vertexIndices:[1,0,3,2],vertexCount:4,elements:[0,4],elementCount:1,mesh:void 0},eu={vertices:[],vertexIndices:[],vertexCount:0,elements:[],elementCount:0,mesh:void 0},nu={vertices:[-160,160,160,-160,160,160,-160,-160],vertexIndices:[1,3,0,2],vertexCount:4,elements:[0,1,2,1,0,3],elementCount:2,mesh:void 0},ru=(t,e)=>([n,r])=>(r<n&&(r+=e),(t>=n?t:t+e)<=r),iu=class extends e{constructor(t,e,r=0,i=12,a=3,s=_c.ODD,o=!1){super(),this.forPathBevel=o,this.type="ShapeGeometry",this.vertexCache={},this._shape=t,this._depth=e,this._curveSegments=i,this._bevelSegmentsInput=a;let h,d,c,u=this._shape.extractShapePointsToFlatArray([],i),p=this._shape.shapeHoles.map((t=>{let e=t.extractShapePointsToFlatArray([],i),n=[];for(let r=e.length-1;r>=1;r-=2){let t=e[r-1],i=e[r-0];n.push(t,i)}return n})),f=[],m=[];for(let n=0;n<u.length;n+=2)m.push([u[n],u[n+1]]);f.push(m);for(let n=0;n<p.length;n++){let t=p[n],e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);f.push(e)}h=t.isText?.1*(new q).setFromPoints(t.points.map((t=>t.position))).getSize(new l).length():0===f[0].length?r:(0,Jc.default)(f).distance,r<=0?(this._bevel=0,this._bevelSegments=0):(this._bevel=Math.min(r,h,e/2),this._bevelSegments=Math.floor(a));try{d=Kc({windingRule:s,elementType:Sc.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[u]})}catch{d=tu}try{c=Kc({windingRule:_c.ODD,elementType:Sc.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[...p]})}catch{c=eu}if(!d)throw new Error("error generating geometry");let g=d.elementCount;if(c){d.elementCount+=c.elementCount;for(let t=0;t<c.elements.length;t++){let e=c.elements[t],n=t%2==0?d.vertexCount:0;d.elements.push(e+n)}for(let t=0;t<c.vertexIndices.length;t++){let e=c.vertexIndices[t],n=d.vertexCount;d.vertexIndices.push(e+n)}for(let t=0;t<c.vertices.length;t++){let e=c.vertices[t];d.vertices.push(e)}}let v=1/0,y=-1/0,b=1/0,x=-1/0;for(let n=0,l=d.vertexCount;n<l;n++){let t=2*n,e=d.vertices[t+0],r=d.vertices[t+1];e<v&&(v=e),e>y&&(y=e),r<b&&(b=r),r>x&&(x=r)}this._minX=v,this._minY=b,this._width=y-v,this._height=x-b,this._buffer=new Qc(this._computeBufferEstimatedSize(d));let w=[],_=[];for(let n=d.elementCount-1;n>=0;n--){let t=n>=g,e=2*n,r=d.elements[e+0],a=d.elements[e+1],s=r+a,l={start:r,count:a,normals:[],continuous:[],concave:[]},c=r,u=s-1,f=r+1,m=this._shape.roundedCurves.length;do{let e=c-r,n=d.vertices[2*u+0],i=d.vertices[2*u+1],o=d.vertices[2*c+0],h=d.vertices[2*c+1],p=d.vertices[2*f+0],g=d.vertices[2*f+1],v=o-n,y=h-i,b=Math.sqrt(v*v+y*y);v/=b,y/=b;let x=o-p,w=h-g,_=Math.sqrt(x*x+w*w);x/=_,w/=_,l.normals[2*e+0]=-w,l.normals[2*e+1]=x,l.concave[e]=v*w-y*x>0;let S=d.vertexIndices[c];if(Array.isArray(S))l.continuous[e]=!1;else{let[t,n]=this._shape.getCurveIndexFromVertexId(S-1,!0);if(n>0&&n<1)l.continuous[e]=!0;else{let r=1===n?t+1:t-1;r=(r+m)%m;let i=1===n?0:1,a=this._shape.roundedCurves[t].getTangent(n),s=this._shape.roundedCurves[r].getTangent(i);l.continuous[e]=a.dot(s)>.95}}t&&(l.normals[2*e+0]*=-1,l.normals[2*e+1]*=-1),[u,c,f]=[c,f,f+1],f>=s&&(f-=a)}while(f!==r+1);let v=[];v.push({bevelI:0,angle:0,size:0,boundary:{vertices:d.vertices.slice(2*r,2*s),vertexCount:a,vertexIndices:new Array(a).fill(!0).map(((t,e)=>[e,e])),elements:[0,a],elementCount:1,mesh:null},reverseMap:[],insetPoints:d.vertices.slice(2*r,2*s)});let y=0;for(let n=1;n<=this._bevelSegments;n++){let e=n/this._bevelSegments*Math.PI/2,r=(1-Math.cos(e))*this._bevel,s=[],o=[],h=0;for(let n=0;n<a;n++){let e=2*n,c=(n-1+a)%a*2,u=d.vertices[2*l.start+e+0],p=d.vertices[2*l.start+e+1],f=-l.normals[c+0]*r,m=-l.normals[c+1]*r,g=-l.normals[e+0]*r,v=-l.normals[e+1]*r;if(l.concave[n]||!l.concave[n]&&t){let e=Math.atan2(m,f),a=Math.atan2(v,g);a>e&&(a-=2*Math.PI);let d=a-e;if(l.continuous[n]||t){let i=e+d/2,a=Math.cos(i)*r,l=Math.sin(i)*r;s[2*h+0]=u+a*(t?-1:1),s[2*h+1]=p+l*(t?-1:1),o[h]=n,h++}else{let t=Math.max(1,Math.floor(i/4*Math.abs(d)/Math.PI));for(let i=0;i<=t;i++){let a=e+d*(i/t),l=Math.cos(a)*r,c=Math.sin(a)*r;s[2*h+0]=u+l,s[2*h+1]=p+c,o[h]=n,h++}}}else s[2*h+0]=u+f,s[2*h+1]=p+m,o[h]=n,h++,s[2*h+0]=u,s[2*h+1]=p,o[h]=n,h++,s[2*h+0]=u+g,s[2*h+1]=p+v,o[h]=n,h++}let c=Kc({windingRule:_c.POSITIVE,elementType:Sc.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[s],edgeCreateCallback:t=>{let e=t.Org.idx,n=o[e],r=o[(e+1)%o.length];t.idx=[n,r],t.Sym.idx=[r,n]},vertexIdCallback:t=>{let e=t.Lprev.idx;return[e?e[1]:0,t.idx?t.idx[0]:0]}});if(!c)throw console.log("Error"),new Error(`error generating bevel geometry for ${n}'th loop`);if(!c.vertexCount){let t=(n-1)/this._bevelSegments*Math.PI/2;y=(1-Math.sin(t))*this._bevel;break}for(let t=0;t<c.vertexIndices.length;t++){let[e,n]=c.vertexIndices[t];if(e===n)continue;let r=n;n<e&&(r+=a);for(let i=e;i<r;i++){let r=i%a,s=(i+1)%a;if(!l.continuous[r]||!l.continuous[s]){c.vertexIndices[t]=[e,r],c.vertexIndices.splice(t+1,0,[s,n]),c.vertices.splice(2*(t+1),0,c.vertices[2*t],c.vertices[2*t+1]);break}}}v.push({bevelI:n,angle:e,size:r,boundary:c,reverseMap:o,insetPoints:s})}let b=(t,e,n)=>{let r=0,i=t.boundary.vertexIndices.length;for(;r<i&&n(t.boundary.vertexIndices[e]);)e=(e+1)%i,r++;return r},x=w.length;for(let n=1;n<v.length;n++){let t=v[n-1],e=v[n],r=t.boundary.vertexIndices.length,i=e.boundary.vertexIndices.length;if(!r||!i)break;let s=l.concave.length,h=0,d=ru(h,a);for(;!t.boundary.vertexIndices.filter(d).length||!e.boundary.vertexIndices.filter(d).length;)h++,d=ru(h,a);let c=t.boundary.vertexIndices.findIndex(d),u=e.boundary.vertexIndices.findIndex(d);do{c=(c+1)%r}while(d(t.boundary.vertexIndices[c]));do{u=(u+1)%i}while(d(e.boundary.vertexIndices[u]));h=(h+1)%a;let p,f,m=h,g=0,y=this._buildBevelVert(l,t,(c-1+r)%r,void 0,g),x=this._buildBevelVert(l,e,(u-1+i)%i,void 0,g),_=!1;do{g=(h||s)/s,d=ru(h,a);let n=b(t,c,d),m=b(e,u,d),v=_;if(_=!1,n&&!m){for(let e=0;e<n;e++)p=this._buildBevelVert(l,t,(c+e)%r,e/(n-1),g),w.push(y.topN,p.topP,x.topN),!1===o&&w.push(p.bottomP,y.bottomN,x.bottomN),y=p;_=!0}else if(!n&&m)for(let t=0;t<m;t++)f=this._buildBevelVert(l,e,(u+t)%i,t/(m-1),g),w.push(x.topN,y.topP,f.topP),!1===o&&w.push(y.bottomP,x.bottomN,f.bottomP),x=f;else if(n&&m)if(p=this._buildBevelVert(l,t,c,0,g),f=this._buildBevelVert(l,e,u,0,g),v?(w.push(y.topN,f.topP,x.topN),w.push(y.topN,p.topP,f.topP),!1===o&&(w.push(f.bottomP,y.bottomN,x.bottomN),w.push(f.bottomP,p.bottomP,y.bottomN))):(w.push(x.topN,y.topN,p.topP),w.push(x.topN,p.topP,f.topP),!1===o&&(w.push(p.bottomP,y.bottomN,x.bottomN),w.push(p.bottomP,x.bottomN,f.bottomP))),y=p,x=f,n===m)for(let a=1;a<n;a++)p=this._buildBevelVert(l,t,(c+a)%r,a/(n-1),g),f=this._buildBevelVert(l,e,(u+a)%i,a/(m-1),g),w.push(y.topN,p.topP,x.topN),w.push(x.topN,p.topP,f.topP),!1===o&&(w.push(p.bottomP,y.bottomN,x.bottomN),w.push(p.bottomP,x.bottomN,f.bottomP)),y=p,x=f;else if(n>m){let a=n/m,s=0;for(let h=1;h<n;h++)p=this._buildBevelVert(l,t,(c+h)%r,h/(n-1),g),w.push(y.topN,p.topP,x.topN),!1===o&&w.push(p.bottomP,y.bottomN,x.bottomN),y=p,h>(s+1)*a&&(s++,f=this._buildBevelVert(l,e,(u+s)%i,s/(m-1),g),w.push(x.topN,p.topP,f.topP),!1===o&&w.push(p.bottomP,x.bottomN,f.bottomP),x=f)}else{let a=m/n,s=0;for(let h=1;h<m;h++)f=this._buildBevelVert(l,e,(u+h)%i,h/(m-1),g),w.push(x.topN,p.topP,f.topP),!1===o&&w.push(p.bottomP,x.bottomN,f.bottomP),x=f,h>(s+1)*a&&(s++,p=this._buildBevelVert(l,t,(c+s)%r,s/(n-1),g),w.push(y.topN,p.topP,x.topN),!1===o&&w.push(p.bottomP,y.bottomN,x.bottomN),y=p)}c=(c+n)%r,u=(u+m)%i,h=(h+1)%s}while(h!==m)}if(!1===o&&this._depth>2*this._bevel&&this._buildWall(v,l,w),t){let t=[];for(let e=w.length-1;e>=x+2;e-=3){let n=w[e-2],r=w[e-1],i=w[e-0];t.push(i,r,n)}w.splice(x,w.length-x,...t)}if(t){let t=[];for(let e=v[v.length-1].boundary.vertices.length-1;e>=1;e-=2){let n=v[v.length-1].boundary.vertices[e-1],r=v[v.length-1].boundary.vertices[e-0];t.push(n,r)}_.push(t)}if(!t){let t,e=v[v.length-1];try{t=Kc({windingRule:v.length>1?_c.POSITIVE:_c.ODD,elementType:Sc.POLYGONS,vertexSize:2,strict:!0,contours:[e.insetPoints,..._]})}catch{t=nu}if(!t)throw new Error("Error generating geometry for surface");0===p.length&&this._bevel<h&&Object.assign(this,{useNgonForTopBottomFaceDuringBake:!0});for(let n=0;n<3*t.elementCount;n+=3){let e=this._buildSurfaceVert(t,t.elements[n+0],y),r=this._buildSurfaceVert(t,t.elements[n+1],y),i=this._buildSurfaceVert(t,t.elements[n+2],y);w.push(e.top,r.top,i.top),!1===o&&w.push(i.bottom,r.bottom,e.bottom)}}this.vertexCache={}}this._buffer.shrink();let S=new n(Uint32Array.from(w),1),A=new n(this._buffer.positions,3),O=new n(this._buffer.normals,3),M=new n(this._buffer.uvs,2);A.needsUpdate=!0,O.needsUpdate=!0,M.needsUpdate=!0,S.needsUpdate=!0,this.setAttribute("position",A),this.setAttribute("normal",O),this.setAttribute("uv",M),this.setIndex(S)}_computeBufferEstimatedSize(t){return 2*t.vertexCount*(2+this._bevelSegments)}_buildWall(t,e,n){let r=t[0];for(let i=0,a=r.boundary.vertexCount;i<a;i++){let t=this._buildBevelVert(e,r,i),s=this._buildBevelVert(e,r,(i+1)%a);n.push(s.topP,t.topN,t.bottomN),n.push(s.topP,t.bottomN,s.bottomP)}}_buildSurfaceVert(t,e,n){let r=e.toString();if(r in this.vertexCache)return this.vertexCache[r];let i=t.vertices[2*e+0],a=t.vertices[2*e+1],s=(i-this._minX)/this._width,o=(a-this._minY)/this._height;this.forPathBevel&&(o=1);let l=this._buffer.get(this.forPathBevel?1:2),h=3*l,d=2*l,c={top:l+0,bottom:l+1};return this._buffer.positions[h+0]=i,this._buffer.positions[h+1]=a,this._buffer.positions[h+2]=this.forPathBevel?this._bevel:this._depth-n,this._buffer.normals[h+0]=0,this._buffer.normals[h+1]=0,this._buffer.normals[h+2]=1,this._buffer.uvs[d+0]=s,this._buffer.uvs[d+1]=o,!1===this.forPathBevel&&(this._buffer.positions[h+3]=i,this._buffer.positions[h+4]=a,this._buffer.positions[h+5]=n,this._buffer.normals[h+3]=0,this._buffer.normals[h+4]=0,this._buffer.normals[h+5]=-1,this._buffer.uvs[d+2]=s,this._buffer.uvs[d+3]=o),this.vertexCache[r]=c,c}_buildBevelVert(t,e,n,r=1,i){let a=`${e.bevelI}:${n}`;if(a in this.vertexCache&&0!==i&&1!==i&&(!i||i===this.vertexCache[a].pathBevelUCoord))return this.vertexCache[a];let s,o,l,h,[d,c]=e.boundary.vertexIndices[n];d!==c?(o=d,s=c,h=!1,l=t.continuous[o]&&t.continuous[s]):(s=d,o=(s-1+t.count)%t.count,h=t.concave[s]&&e.bevelI>0,l=t.continuous[s]||h);let u=Math.cos(e.angle),p=Math.sin(e.angle),f=2*n,m=2*s,g=2*o,v=e.boundary.vertices[f+0],y=e.boundary.vertices[f+1],b=(1-p)*this._bevel,x=(v-this._minX)/this._width,w=(y-this._minY)/this._height;this.forPathBevel&&(void 0!==i&&(x=i),w=1);let _=t.normals[m+0],S=t.normals[m+1],A=t.normals[g+0],O=t.normals[g+1];if(h){_+=(A-_)*(1-r),S+=(O-S)*(1-r);let t=Math.sqrt(_*_+S*S);_/=t,S/=t}let M=this.forPathBevel?this._buffer.get(l?1:2):this._buffer.get(l?2:4),C=3*M,P=2*M,D={i:n,fi:s,topP:M+0,topN:M+0,bottomP:M+1,bottomN:M+1,pathBevelUCoord:i};return this._buffer.positions[C+0]=v,this._buffer.positions[C+1]=y,this._buffer.positions[C+2]=(this.forPathBevel?this._bevel:this._depth)-b,this._buffer.normals[C+0]=_*u,this._buffer.normals[C+1]=S*u,this._buffer.normals[C+2]=p,this._buffer.uvs[P+0]=x,this._buffer.uvs[P+1]=w,!1===this.forPathBevel&&(this._buffer.positions[C+3]=v,this._buffer.positions[C+4]=y,this._buffer.positions[C+5]=b,this._buffer.normals[C+3]=_*u,this._buffer.normals[C+4]=S*u,this._buffer.normals[C+5]=-p,this._buffer.uvs[P+2]=w,this._buffer.uvs[P+3]=x),l||(this.forPathBevel?(M+=1,C+=3,P+=2):(M+=2,C+=6,P+=4),D.topP=M+0,D.bottomP=M+1,this._buffer.positions[C+0]=v,this._buffer.positions[C+1]=y,this._buffer.positions[C+2]=(this.forPathBevel?this._bevel:this._depth)-b,this._buffer.normals[C+0]=A*u,this._buffer.normals[C+1]=O*u,this._buffer.normals[C+2]=p,this._buffer.uvs[P+0]=x,this._buffer.uvs[P+1]=w,!1===this.forPathBevel&&(this._buffer.positions[C+3]=v,this._buffer.positions[C+4]=y,this._buffer.positions[C+5]=b,this._buffer.normals[C+3]=A*u,this._buffer.normals[C+4]=O*u,this._buffer.normals[C+5]=-p,this._buffer.uvs[P+2]=w,this._buffer.uvs[P+3]=x)),this.vertexCache[a]=D,D}clone(){let t=new iu(this._shape,this._depth,this._bevel,this._curveSegments,this._bevelSegmentsInput);return t.userData=ia(this.userData),t}},au=class extends e{constructor(t,e=12,r={}){super(),this.type="ShapeGeometry",this.windingRule=_c.ODD,this.elementType=Sc.POLYGONS,this.polySize=3,this.vertexSize=2,this.strict=!0,this._shape=t,this._curveSegments=e,this._triangulationOptions=Object.assign({windingRule:_c.ODD,elementType:Sc.POLYGONS,polySize:3,vertexSize:2,strict:!0},r);let i,a,s,o=this._shape.extractShapePointsToFlatArray([],this._curveSegments),l=this._shape.shapeHoles.map((t=>t.extractShapePointsToFlatArray([],this._curveSegments))),h=!0,d=!0;for(let n=0,p=o.length/2;n<p;n++){let t=2*n,e=o[t+0],r=o[t+1];if(void 0!==a&&e!==a&&(h=!1),void 0!==s&&r!==s&&(d=!1),a=e,s=r,!h&&!d)break}if(!h&&!d)try{i=Kc({contours:[o,...l],windingRule:this._triangulationOptions.windingRule,elementType:this._triangulationOptions.elementType,polySize:this._triangulationOptions.polySize,vertexSize:this._triangulationOptions.vertexSize,strict:this._triangulationOptions.strict})}catch{i=tu}let c=(null==i?void 0:i.vertexCount)??1,u=(null==i?void 0:i.elementCount)??1;if(this._positionAttribute=new n(new Float32Array(3*c),3),this._normalAttribute=new n(new Float32Array(3*c),3),this._uvAttribute=new n(new Float32Array(2*c),2),this._indexAttribute=new n(new Uint32Array(3*u),1),i){let t=1/0,e=-1/0,n=1/0,r=-1/0;for(let o=0,l=c;o<l;o++){let a=2*o,s=i.vertices[a+0],l=i.vertices[a+1];s<t&&(t=s),s>e&&(e=s),l<n&&(n=l),l>r&&(r=l)}let a=e-t,s=r-n;for(let o=0,l=c;o<l;o++){let e=2*o,r=i.vertices[e+0],l=i.vertices[e+1],h=(r-t)/a,d=(l-n)/s;this._positionAttribute.setXYZ(o,r,l,0),this._normalAttribute.setXYZ(o,0,0,1),this._uvAttribute.setXY(o,h,d)}for(let o=0,l=u;o<l;o++){let t=3*o,e=i.elements[t+0],n=i.elements[t+1],r=i.elements[t+2];this._indexAttribute.setX(t+0,e),this._indexAttribute.setX(t+1,n),this._indexAttribute.setX(t+2,r)}}this.setAttribute("position",this._positionAttribute),this.setAttribute("normal",this._normalAttribute),this.setAttribute("uv",this._uvAttribute),this.setIndex(this._indexAttribute),this.setDrawRange(0,3*((null==i?void 0:i.elementCount)??1))}clone(){let t=new au(this._shape,this._curveSegments);return t.userData=ia(this.userData),t}},su=class extends iu{constructor(t,e,n=0,r=12,i=3,a=_c.ODD){super(t,e,n,r,i,a),this.type="ShapeGeometry"}_computeBufferEstimatedSize(t){return 2*t.vertexCount*(2+this._bevelSegments)}_buildWall(t,e,n){let r=t[0];for(let i=0,a=r.boundary.vertexCount;i<a;i++){let t=this._buildBevelVert(e,r,i),s=this._buildBevelVert(e,r,(i+1)%a);n.push(s.topP,t.topN,t.bottomN),n.push(s.topP,t.bottomN,s.bottomP)}}clone(){let t=new su(this._shape,this._depth,this._bevel,this._curveSegments,this._bevelSegmentsInput);return t.userData=ia(this.userData),t}},ou=class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){var n,r;let i=Object.assign({},(null==e?void 0:e.parameters)??{width:100,subdivisions:40,roundness:0,extrudeBevelSize:0,extrudeBevelSegments:3,windingRule:_c.ODD},t.parameters),a=Math.abs(i.width),s=Math.abs(i.height??i.width),o=Math.abs(i.depth??0),l=t.shape??(null==e?void 0:e.shape),h=(null==l?void 0:l.roundness)??i.roundness;void 0!==l&&(l instanceof Tc?(l.width!==a||l.height!==s)&&l.applySize(a,s):l=new Tc(a,s).fromJSON(l),void 0!==(null==(n=t.parameters)?void 0:n.roundness)&&(null==(r=t.parameters)?void 0:r.roundness)>0&&l.update());let d=l??new Tc(a,s);return{parameters:Object.assign(i,{width:a,height:s,depth:o,roundness:h}),shape:d}}static build(t){let e,{depth:n,extrudeBevelSize:r,extrudeBevelSegments:i,subdivisions:a,roundness:s,windingRule:o}=t.parameters;return t.shape.roundness=s,e=n<=0?new au(t.shape,a,{windingRule:o}):new su(t.shape,n,r,a,i,o),Object.assign(e,{userData:{...t,type:"VectorGeometry"}})}},lu=2*Math.PI,hu=class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,depth:0,spikes:64,angle:360,innerRadius:0,extrudeBevelSize:0,extrudeBevelSegments:1},t.parameters);return n.angle=x.clamp(n.angle,0,360),{shape:t.shape&&t.shape instanceof Tc?t.shape:new Tc,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??0)})}}static build(t){let n,{width:r,height:i,spikes:a,angle:s,innerRadius:o,depth:l,extrudeBevelSize:h,extrudeBevelSegments:d}=t.parameters,c=t.shape,u=function(t,e,n,r,i,a){if(r>=lu)return i>30||i%4==0?(function(t,e,n,r=0,i=0,a=0){let s=.5522847498,o=e*s,l=n*s;t.addPoint(uu(i-e,a,i-e,a-l,i-e,a+l)),t.addPoint(uu(i,a+n,i-o,a+n,i+o,a+n)),t.addPoint(uu(i+e,a,i+e,a+l,i+e,a-l)),t.addPoint(uu(i,a-n,i+o,a-n,i-o,a-n)),r>0&&fu(t,e,n,r)}(t,e,n,a),Math.round(i/4)):du(t,r,i,e,n,a);r=Math.max(r,.001);let s={x:0,y:n},o=r+.5*Math.PI,l={x:Math.cos(o)*e,y:Math.sin(o)*n},h=Nc({px:s.x,py:s.y,cx:l.x,cy:l.y,rx:e,ry:n,largeArcFlag:r>Math.PI,sweepFlag:!0});return i>30||i%h.length==0?function(t,e,n,r,i,a,s,o){let l=Math.round(i/r.length);t.addPoint(cu(e,n));for(let h=0,d=r.length;h<d;h++){let e=r[h],n=t.points[h],i=cu(e.x,e.y);n.controls[1].position.set(e.x1,e.y1),i.controls[0].position.set(e.x2,e.y2),t.addPoint(i)}return o>0?pu(t,a,s,o):t.addPoint(cu(0,0)),l}(t,s.x,s.y,h,i,e,n,a):du(t,r,i,e,n,a)}(c,.5*r,.5*i,s*Math.PI/180,a,o);return c.isClosed=!0,c.update(),0===s?(n=new e,n.setAttribute("position",new S([],3))):n=ou.create({shape:c,parameters:{subdivisions:u,depth:l,extrudeBevelSize:h,extrudeBevelSegments:d}}),Object.assign(n,{userData:{...t,type:"EllipseGeometry"}})}};function du(t,e,n,r,i,a){let s=-e/n;for(let o=0;o<=n;o++){let e=s*o,n=Math.sin(e)*r,a=Math.cos(e)*i;t.addPoint(cu(n,a))}return e<lu?a>0?pu(t,r,i,a):t.addPoint(cu(0,0)):(t.removePoint(t.points[t.points.length-1]),a>0&&fu(t,r,i,a)),1}function cu(t,e){return new Qd(x.generateUUID(),new l(t,e))}function uu(t,e,n,r,i,a){let s=cu(t,e);return s.controls[0].position.set(n,r),s.controls[1].position.set(i,a),s}function pu(t,e,n,r){mu(t,e,n,r).forEach((e=>t.addPoint(e)))}function fu(t,e,n,r){let i=mu(t,e,n,r),a=new Tc;i.forEach((t=>a.addPoint(t))),a.isClosed=!0,t.shapeHoles.push(a)}function mu(t,e,n,r){let i=r*e/100,a=i*(Math.abs(n)/Math.abs(e)),s=new l(i/e,a/n),o=t.points.map((t=>{let e=t.clone();return e.uuid=x.generateUUID(),e})).reverse();return o.forEach((t=>{t.position.multiply(s);let e=t.controls[0].position.clone().multiply(s),n=t.controls[1].position.clone().multiply(s);t.controls[0].position.copy(n),t.controls[1].position.copy(e)})),o}var gu=new h([0,0,0],1),vu=class extends e{constructor(t=!0,e=1,n=1,r=1,i=1,a=1,s=1,l=1,h=1,d=1,c=1,u=1){if(super(),0===a)return;let p=t&&1===a;p&&(u=0),c>100&&(c=100),0===c&&(u=0);let f,m,g,v,y,b,x,w,_=()=>new o,A=new o,O=_(),M=_(),C=_(),P=_(),D=_(),T=_(),z=_(),E=_(),L=_(),I=_(),N=_(),j=n-2*l+.001,B=j/a,U=Math.ceil(s*a),k=U+1,R=j/U,F=-j/2,V=d+1,G=2*Math.PI/d,H=Math.PI/2/u,W=Math.min((1-c/100)*l,l-.01),q=l-W,$=0,X=2*u+2,Y=V*X/2,K=Y+V*k,Z=Math.max(0,V*(k+X)),[Q,J,tt]=[3,3,2].map((t=>Array(Z*t).fill(0))),et=[],nt=i-l;function rt(e,n){let r=Math.PI/2;b=n*R,w=2*Math.PI*(b%B)/B+r,b+=F,x=Math.sin(w)*nt,y=Math.cos(w)*nt,t?e.set(y,x,b):e.set(y,b,x)}rt(A,-1e-10),rt(O,0),P.copy(A),rt(A,1);let it=A.distanceTo(O),at=p?0:q+W,st=it*U+2*at,ot=W,lt=st-at;for(let o=0;o<=U;o++){rt(M,o),N.subVectors(M,P).normalize(),P.copy(M),L.copy(M).setComponent(+t+1,0).normalize(),I.crossVectors(N,L).normalize();let e=0===o,n=o===U,r=e?3*Math.PI/2:H,i=e?ot:lt,a=e?V:K,s=e?0:Z-V,h=N.clone().multiplyScalar(e?-q:q).add(M),c=N.clone().multiplyScalar(e?-1:1).normalize();for(let t=0;t<V;t++){let f=t*G;if(D.addVectors(A.copy(L).multiplyScalar(l*Math.cos(f)),O.copy(I).multiplyScalar(l*Math.sin(f))),T.copy(D).normalize(),e||n){p||($=s+t,[0,1,2].forEach((t=>{Q[3*$+t]=h.getComponent(t),J[3*$+t]=c.getComponent(t)})),tt[2*$]=+n,tt[2*$+1]=t/d),O.copy(T).multiplyScalar(W),C.addVectors(M,O);for(let n=0;n<u;n++){let s=n*H+r;z.addVectors(A.copy(N).multiplyScalar(q*Math.sin(s)),O.copy(T).multiplyScalar(q*Math.cos(s))),E.copy(z).normalize(),O.addVectors(C,z),z.normalize(),$=a+n*V+t,[0,1,2].forEach((t=>{Q[3*$+t]=O.getComponent(t),J[3*$+t]=E.getComponent(t)}));let o=+e+Math.sin(s);tt[2*$]=(i+q*o)/st,tt[2*$+1]=t/d}}O.addVectors(M,D),$=Y+o*V+t,[0,1,2].forEach((t=>{Q[3*$+t]=O.getComponent(t),J[3*$+t]=T.getComponent(t)})),tt[2*$]=(at+o*it)/st,tt[2*$+1]=t/d}}let ht=k+2*u+2,[dt,ct]=[+p,ht-1];for(let o=dt;o<=ct-1;o++){let t=p&&o===ct-1;for(let e=0;e<V-1;e++)f=o*V+e,m=f+1,g=(t?e:f)+V,v=(t?e+1:m)+V,0===o?et.push(m,v,g):o===ht-2?et.push(f,m,g):et.push(f,m,g,m,v,g)}this.setIndex(et),this.setAttribute("position",new S(Q,3)),this.setAttribute("normal",new S(J,3)),this.setAttribute("uv",new S(tt,2))}getClosedTorusIndicesForBooleanOrSubdiv(){let t,e,n,r,i=this.userData.parameters,a=Math.ceil(i.tubularSegments),s=i.radialSegments+1,o=Array.from(this.getIndex().array),l=6*(a-1)*i.radialSegments,h=a,d=h===a;for(let c=0;c<i.radialSegments;c++)t=h*s+c,e=t+1,n=(d?c:t)+s,r=(d?c+1:e)+s,o[l++]=t,o[l++]=e,o[l++]=n,o[l++]=e,o[l++]=r,o[l++]=n;return o.length=l,gu.array=o,gu.count=o.length,gu}},yu=class extends $d{constructor(t=1,e=.2,n=4){let r=(1+Math.sqrt(5))/2,i="IcosahedronGeometry";super([-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],i,t,e,n),this.type=i}static fromJSON(t){return new yu(t.radius,t.corner,t.cornerSides)}},bu=new s,xu=new d,wu=new o,_u=class extends b{constructor(){super(),this.uuid=x.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}applyMatrix4(t){let e=(new w).getNormalMatrix(t);for(let n=0,r=this.vertices.length;n<r;n++)this.vertices[n].applyMatrix4(t);for(let n=0,r=this.faces.length;n<r;n++){let t=this.faces[n];t.normal.applyMatrix3(e).normalize();for(let n=0,r=t.vertexNormals.length;n<r;n++)t.vertexNormals[n].applyMatrix3(e).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this}rotateX(t){return bu.makeRotationX(t),this.applyMatrix4(bu),this}rotateY(t){return bu.makeRotationY(t),this.applyMatrix4(bu),this}rotateZ(t){return bu.makeRotationZ(t),this.applyMatrix4(bu),this}translate(t,e,n){return bu.makeTranslation(t,e,n),this.applyMatrix4(bu),this}scale(t,e,n){return bu.makeScale(t,e,n),this.applyMatrix4(bu),this}lookAt(t){return xu.lookAt(t),xu.updateMatrix(),this.applyMatrix4(xu.matrix),this}fromBufferGeometry(t){let e=this,n=null!==t.index?t.index:void 0,r=t.attributes;if(void 0===r.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;let i=r.position,a=r.normal,s=r.color,h=r.uv,d=r.uv2;void 0!==d&&(this.faceVertexUvs[1]=[]);for(let l=0;l<i.count;l++)e.vertices.push((new o).fromBufferAttribute(i,l)),void 0!==s&&e.colors.push((new _).fromBufferAttribute(s,l));function c(t,n,r,i){let c=void 0===s?[]:[e.colors[t].clone(),e.colors[n].clone(),e.colors[r].clone()],u=void 0===a?[]:[(new o).fromBufferAttribute(a,t),(new o).fromBufferAttribute(a,n),(new o).fromBufferAttribute(a,r)],p=new Au(t,n,r,u,c,i);e.faces.push(p),void 0!==h&&e.faceVertexUvs[0].push([(new l).fromBufferAttribute(h,t),(new l).fromBufferAttribute(h,n),(new l).fromBufferAttribute(h,r)]),void 0!==d&&e.faceVertexUvs[1].push([(new l).fromBufferAttribute(d,t),(new l).fromBufferAttribute(d,n),(new l).fromBufferAttribute(d,r)])}let u=t.groups;if(u.length>0)for(let o=0;o<u.length;o++){let t=u[o],e=t.start;for(let r=e,i=e+t.count;r<i;r+=3)void 0!==n?c(n.getX(r),n.getX(r+1),n.getX(r+2),t.materialIndex):c(r,r+1,r+2,t.materialIndex)}else if(void 0!==n)for(let o=0;o<n.count;o+=3)c(n.getX(o),n.getX(o+1),n.getX(o+2));else for(let o=0;o<i.count;o+=3)c(o,o+1,o+2);return this.computeFaceNormals(),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(wu).negate(),this.translate(wu.x,wu.y,wu.z),this}normalize(){this.computeBoundingSphere();let t=this.boundingSphere.center,e=this.boundingSphere.radius,n=0===e?1:1/e,r=new s;return r.set(n,0,0,-n*t.x,0,n,0,-n*t.y,0,0,n,-n*t.z,0,0,0,1),this.applyMatrix4(r),this}computeFaceNormals(){let t=new o,e=new o;for(let n=0,r=this.faces.length;n<r;n++){let r=this.faces[n],i=this.vertices[r.a],a=this.vertices[r.b],s=this.vertices[r.c];t.subVectors(s,a),e.subVectors(i,a),t.cross(e),t.normalize(),r.normal.copy(t)}}computeVertexNormals(t=!0){let e=new Array(this.vertices.length);for(let n=0,r=this.vertices.length;n<r;n++)e[n]=new o;if(t){let t=new o,n=new o;for(let r=0,i=this.faces.length;r<i;r++){let i=this.faces[r],a=this.vertices[i.a],s=this.vertices[i.b],o=this.vertices[i.c];t.subVectors(o,s),n.subVectors(a,s),t.cross(n),e[i.a].add(t),e[i.b].add(t),e[i.c].add(t)}}else{this.computeFaceNormals();for(let t=0,n=this.faces.length;t<n;t++){let n=this.faces[t];e[n.a].add(n.normal),e[n.b].add(n.normal),e[n.c].add(n.normal)}}for(let n=0,r=this.vertices.length;n<r;n++)e[n].normalize();for(let n=0,r=this.faces.length;n<r;n++){let t=this.faces[n],r=t.vertexNormals;3===r.length?(r[0].copy(e[t.a]),r[1].copy(e[t.b]),r[2].copy(e[t.c])):(r[0]=e[t.a].clone(),r[1]=e[t.b].clone(),r[2]=e[t.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeFlatVertexNormals(){this.computeFaceNormals();for(let t=0,e=this.faces.length;t<e;t++){let e=this.faces[t],n=e.vertexNormals;3===n.length?(n[0].copy(e.normal),n[1].copy(e.normal),n[2].copy(e.normal)):(n[0]=e.normal.clone(),n[1]=e.normal.clone(),n[2]=e.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeMorphNormals(){for(let e=0,n=this.faces.length;e<n;e++){let t=this.faces[e];t.__originalFaceNormal?t.__originalFaceNormal.copy(t.normal):t.__originalFaceNormal=t.normal.clone(),t.__originalVertexNormals||(t.__originalVertexNormals=[]);for(let e=0,n=t.vertexNormals.length;e<n;e++)t.__originalVertexNormals[e]?t.__originalVertexNormals[e].copy(t.vertexNormals[e]):t.__originalVertexNormals[e]=t.vertexNormals[e].clone()}let t=new _u;t.faces=this.faces;for(let e=0,n=this.morphTargets.length;e<n;e++){if(!this.morphNormals[e]){this.morphNormals[e]={},this.morphNormals[e].faceNormals=[],this.morphNormals[e].vertexNormals=[];let t=this.morphNormals[e].faceNormals,n=this.morphNormals[e].vertexNormals;for(let e=0,r=this.faces.length;e<r;e++){let e=new o,r={a:new o,b:new o,c:new o};t.push(e),n.push(r)}}let n=this.morphNormals[e];t.vertices=this.morphTargets[e].vertices,t.computeFaceNormals(),t.computeVertexNormals();for(let t=0,e=this.faces.length;t<e;t++){let e=this.faces[t],r=n.faceNormals[t],i=n.vertexNormals[t];r.copy(e.normal),i.a.copy(e.vertexNormals[0]),i.b.copy(e.vertexNormals[1]),i.c.copy(e.vertexNormals[2])}}for(let e=0,n=this.faces.length;e<n;e++){let t=this.faces[e];t.normal=t.__originalFaceNormal,t.vertexNormals=t.__originalVertexNormals}}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new c),this.boundingBox.setFromPoints(this.vertices)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new m),this.boundingSphere.setFromPoints(this.vertices)}merge(t,e,n=0){if(!t||!t.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",t);let r,i=this.vertices.length,a=this.vertices,s=t.vertices,o=this.faces,l=t.faces,h=this.colors,d=t.colors;void 0!==e&&(r=(new w).getNormalMatrix(e));for(let c=0,u=s.length;c<u;c++){let t=s[c].clone();void 0!==e&&t.applyMatrix4(e),a.push(t)}for(let c=0,u=d.length;c<u;c++)h.push(d[c].clone());for(let c=0,u=l.length;c<u;c++){let t,e,a=l[c],s=a.vertexNormals,h=a.vertexColors,d=new Au(a.a+i,a.b+i,a.c+i);d.normal.copy(a.normal),void 0!==r&&d.normal.applyMatrix3(r).normalize();for(let n=0,i=s.length;n<i;n++)t=s[n].clone(),void 0!==r&&t.applyMatrix3(r).normalize(),d.vertexNormals.push(t);d.color.copy(a.color);for(let n=0,r=h.length;n<r;n++)e=h[n],d.vertexColors.push(e.clone());d.materialIndex=a.materialIndex+n,o.push(d)}for(let c=0,u=t.faceVertexUvs.length;c<u;c++){let e=t.faceVertexUvs[c];void 0===this.faceVertexUvs[c]&&(this.faceVertexUvs[c]=[]);for(let t=0,n=e.length;t<n;t++){let n=e[t],r=[];for(let t=0,e=n.length;t<e;t++)r.push(n[t].clone());this.faceVertexUvs[c].push(r)}}}mergeMesh(t){t&&t.isMesh?(t.matrixAutoUpdate&&t.updateMatrix(),this.merge(t.geometry,t.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",t)}mergeVertices(t=4){let e={},n=[],r=[],i=Math.pow(10,t);for(let o=0,l=this.vertices.length;o<l;o++){let t=this.vertices[o],a=Math.round(t.x*i)+"_"+Math.round(t.y*i)+"_"+Math.round(t.z*i);void 0===e[a]?(e[a]=o,n.push(this.vertices[o]),r[o]=n.length-1):r[o]=r[e[a]]}let a=[];for(let o=0,l=this.faces.length;o<l;o++){let t=this.faces[o];t.a=r[t.a],t.b=r[t.b],t.c=r[t.c];let e=[t.a,t.b,t.c];for(let n=0;n<3;n++)if(e[n]===e[(n+1)%3]){a.push(o);break}}for(let o=a.length-1;o>=0;o--){let t=a[o];this.faces.splice(t,1);for(let e=0,n=this.faceVertexUvs.length;e<n;e++)this.faceVertexUvs[e].splice(t,1)}let s=this.vertices.length-n.length;return this.vertices=n,s}setFromPoints(t){this.vertices=[];for(let e=0,n=t.length;e<n;e++){let n=t[e];this.vertices.push(new o(n.x,n.y,n.z||0))}return this}sortFacesByMaterialIndex(){let t=this.faces,e=t.length;for(let s=0;s<e;s++)t[s]._id=s;t.sort((function(t,e){return t.materialIndex-e.materialIndex}));let n,r,i=this.faceVertexUvs[0],a=this.faceVertexUvs[1];i&&i.length===e&&(n=[]),a&&a.length===e&&(r=[]);for(let s=0;s<e;s++){let e=t[s]._id;n&&n.push(i[e]),r&&r.push(a[e])}n&&(this.faceVertexUvs[0]=n),r&&(this.faceVertexUvs[1]=r)}toJSON(){let t={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),void 0!==this.parameters){let e=this.parameters;for(let n in e)void 0!==e[n]&&(t[n]=e[n]);return t}let e=[];for(let p=0;p<this.vertices.length;p++){let t=this.vertices[p];e.push(t.x,t.y,t.z)}let n=[],r=[],i={},a=[],s={},o=[],l={};for(let p=0;p<this.faces.length;p++){let t=this.faces[p],e=!0,r=!1,i=void 0!==this.faceVertexUvs[0][p],a=t.normal.length()>0,s=t.vertexNormals.length>0,o=1!==t.color.r||1!==t.color.g||1!==t.color.b,l=t.vertexColors.length>0,f=0;if(f=h(f,0,0),f=h(f,1,e),f=h(f,2,r),f=h(f,3,i),f=h(f,4,a),f=h(f,5,s),f=h(f,6,o),f=h(f,7,l),n.push(f),n.push(t.a,t.b,t.c),n.push(t.materialIndex),i){let t=this.faceVertexUvs[0][p];n.push(u(t[0]),u(t[1]),u(t[2]))}if(a&&n.push(d(t.normal)),s){let e=t.vertexNormals;n.push(d(e[0]),d(e[1]),d(e[2]))}if(o&&n.push(c(t.color)),l){let e=t.vertexColors;n.push(c(e[0]),c(e[1]),c(e[2]))}}function h(t,e,n){return n?t|1<<e:t&~(1<<e)}function d(t){let e=t.x.toString()+t.y.toString()+t.z.toString();return void 0!==i[e]||(i[e]=r.length/3,r.push(t.x,t.y,t.z)),i[e]}function c(t){let e=t.r.toString()+t.g.toString()+t.b.toString();return void 0!==s[e]||(s[e]=a.length,a.push(t.getHex())),s[e]}function u(t){let e=t.x.toString()+t.y.toString();return void 0!==l[e]||(l[e]=o.length/2,o.push(t.x,t.y)),l[e]}return t.data={},t.data.vertices=e,t.data.normals=r,a.length>0&&(t.data.colors=a),o.length>0&&(t.data.uvs=[o]),t.data.faces=n,t}clone(){return(new _u).copy(this)}copy(t){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=t.name;let e=t.vertices;for(let c=0,u=e.length;c<u;c++)this.vertices.push(e[c].clone());let n=t.colors;for(let c=0,u=n.length;c<u;c++)this.colors.push(n[c].clone());let r=t.faces;for(let c=0,u=r.length;c<u;c++)this.faces.push(r[c].clone());for(let c=0,u=t.faceVertexUvs.length;c<u;c++){let e=t.faceVertexUvs[c];void 0===this.faceVertexUvs[c]&&(this.faceVertexUvs[c]=[]);for(let t=0,n=e.length;t<n;t++){let n=e[t],r=[];for(let t=0,e=n.length;t<e;t++){let e=n[t];r.push(e.clone())}this.faceVertexUvs[c].push(r)}}let i=t.morphTargets;for(let c=0,u=i.length;c<u;c++){let t={};if(t.name=i[c].name,void 0!==i[c].vertices){t.vertices=[];for(let e=0,n=i[c].vertices.length;e<n;e++)t.vertices.push(i[c].vertices[e].clone())}if(void 0!==i[c].normals){t.normals=[];for(let e=0,n=i[c].normals.length;e<n;e++)t.normals.push(i[c].normals[e].clone())}this.morphTargets.push(t)}let a=t.morphNormals;for(let c=0,u=a.length;c<u;c++){let t={};if(void 0!==a[c].vertexNormals){t.vertexNormals=[];for(let e=0,n=a[c].vertexNormals.length;e<n;e++){let n=a[c].vertexNormals[e],r={};r.a=n.a.clone(),r.b=n.b.clone(),r.c=n.c.clone(),t.vertexNormals.push(r)}}if(void 0!==a[c].faceNormals){t.faceNormals=[];for(let e=0,n=a[c].faceNormals.length;e<n;e++)t.faceNormals.push(a[c].faceNormals[e].clone())}this.morphNormals.push(t)}let s=t.skinWeights;for(let c=0,u=s.length;c<u;c++)this.skinWeights.push(s[c].clone());let o=t.skinIndices;for(let c=0,u=o.length;c<u;c++)this.skinIndices.push(o[c].clone());let l=t.lineDistances;for(let c=0,u=l.length;c<u;c++)this.lineDistances.push(l[c]);let h=t.boundingBox;null!==h&&(this.boundingBox=h.clone());let d=t.boundingSphere;return null!==d&&(this.boundingSphere=d.clone()),this.elementsNeedUpdate=t.elementsNeedUpdate,this.verticesNeedUpdate=t.verticesNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.lineDistancesNeedUpdate=t.lineDistancesNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,this}toBufferGeometry(){let t=(new Su).fromGeometry(this),r=new e,i=new Float32Array(3*t.vertices.length);if(r.setAttribute("position",Pu.call(new n(i,3),t.vertices)),t.normals.length>0){let e=new Float32Array(3*t.normals.length);r.setAttribute("normal",Pu.call(new n(e,3),t.normals))}if(t.colors.length>0){let e=new Float32Array(3*t.colors.length);r.setAttribute("color",Mu.call(new n(e,3),t.colors))}if(t.uvs.length>0){let e=new Float32Array(2*t.uvs.length);r.setAttribute("uv",Cu.call(new n(e,2),t.uvs))}if(t.uvs2.length>0){let e=new Float32Array(2*t.uvs2.length);r.setAttribute("uv2",Cu.call(new n(e,2),t.uvs2))}r.groups=t.groups;for(let e in t.morphTargets){let n=[],i=t.morphTargets[e];for(let t=0,e=i.length;t<e;t++){let e=i[t],r=new S(3*e.data.length,3);r.name=e.name,n.push(Pu.call(r,e.data))}r.morphAttributes[e]=n}if(t.skinIndices.length>0){let e=new S(4*t.skinIndices.length,4);r.setAttribute("skinIndex",Du.call(e,t.skinIndices))}if(t.skinWeights.length>0){let e=new S(4*t.skinWeights.length,4);r.setAttribute("skinWeight",Du.call(e,t.skinWeights))}return null!==t.boundingSphere&&(r.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(r.boundingBox=t.boundingBox.clone()),r}computeTangents(){console.error("THREE.Geometry: .computeTangents() has been removed.")}computeLineDistances(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}applyMatrix(t){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)}dispose(){this.dispatchEvent({type:"dispose"})}static createBufferGeometryFromObject(t){let n=new e,r=t.geometry;if(t.isPoints||t.isLine){let t=new S(3*r.vertices.length,3),e=new S(3*r.colors.length,3);if(n.setAttribute("position",Pu.call(t,r.vertices)),n.setAttribute("color",Mu.call(e,r.colors)),r.lineDistances&&r.lineDistances.length===r.vertices.length){let t=new S(r.lineDistances.length,1);n.setAttribute("lineDistance",Ou.call(t,r.lineDistances))}null!==r.boundingSphere&&(n.boundingSphere=r.boundingSphere.clone()),null!==r.boundingBox&&(n.boundingBox=r.boundingBox.clone())}else t.isMesh&&(n=r.toBufferGeometry());return n}};_u.prototype.isGeometry=!0;var Su=class{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(t){let e,n,r,i=[],a=t.faces;for(n=0;n<a.length;n++){let t=a[n];t.materialIndex!==r&&(r=t.materialIndex,void 0!==e&&(e.count=3*n-e.start,i.push(e)),e={start:3*n,materialIndex:r})}void 0!==e&&(e.count=3*n-e.start,i.push(e)),this.groups=i}fromGeometry(t){let e,n=t.faces,r=t.vertices,i=t.faceVertexUvs,a=i[0]&&i[0].length>0,s=i[1]&&i[1].length>0,o=t.morphTargets,h=o.length;if(h>0){e=[];for(let t=0;t<h;t++)e[t]={name:o[t].name,data:[]};this.morphTargets.position=e}let d,c=t.morphNormals,u=c.length;if(u>0){d=[];for(let t=0;t<u;t++)d[t]={name:c[t].name,data:[]};this.morphTargets.normal=d}let p=t.skinIndices,f=t.skinWeights,m=p.length===r.length,g=f.length===r.length;r.length>0&&0===n.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let v=0;v<n.length;v++){let t=n[v];this.vertices.push(r[t.a],r[t.b],r[t.c]);let y=t.vertexNormals;if(3===y.length)this.normals.push(y[0],y[1],y[2]);else{let e=t.normal;this.normals.push(e,e,e)}let b=t.vertexColors;if(3===b.length)this.colors.push(b[0],b[1],b[2]);else{let e=t.color;this.colors.push(e,e,e)}if(!0===a){let t=i[0][v];void 0!==t?this.uvs.push(t[0],t[1],t[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",v),this.uvs.push(new l,new l,new l))}if(!0===s){let t=i[1][v];void 0!==t?this.uvs2.push(t[0],t[1],t[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",v),this.uvs2.push(new l,new l,new l))}for(let n=0;n<h;n++){let r=o[n].vertices;e[n].data.push(r[t.a],r[t.b],r[t.c])}for(let e=0;e<u;e++){let t=c[e].vertexNormals[v];d[e].data.push(t.a,t.b,t.c)}m&&this.skinIndices.push(p[t.a],p[t.b],p[t.c]),g&&this.skinWeights.push(f[t.a],f[t.b],f[t.c])}return this.computeGroups(t),this.verticesNeedUpdate=t.verticesNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),this}},Au=class{constructor(t,e,n,r,i,a=0){this.a=t,this.b=e,this.c=n,this.normal=r&&r.isVector3?r:new o,this.vertexNormals=Array.isArray(r)?r:[],this.color=i&&i.isColor?i:new _,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=a}clone(){return(new this.constructor).copy(this)}copy(t){this.a=t.a,this.b=t.b,this.c=t.c,this.normal.copy(t.normal),this.color.copy(t.color),this.materialIndex=t.materialIndex;for(let e=0,n=t.vertexNormals.length;e<n;e++)this.vertexNormals[e]=t.vertexNormals[e].clone();for(let e=0,n=t.vertexColors.length;e<n;e++)this.vertexColors[e]=t.vertexColors[e].clone();return this}};function Ou(t){return this.array.set(t),this}function Mu(t){let e=this.array,n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new _),e[n++]=i.r,e[n++]=i.g,e[n++]=i.b}return this}function Cu(t){let e=this.array,n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new l),e[n++]=i.x,e[n++]=i.y}return this}function Pu(t){let e=this.array,n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new o),e[n++]=i.x,e[n++]=i.y,e[n++]=i.z}return this}function Du(t){let e=this.array,n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new p),e[n++]=i.x,e[n++]=i.y,e[n++]=i.z,e[n++]=i.w}return this}var Tu=["a","b","c"];function zu(t,e){switch(e){case"c":return t.c;case"b":return t.b;default:return t.a}}function Eu(t,e,n){let r=Math.min(t,e)+"_"+Math.max(t,e);return n.get(r)}function Lu(t,e,n,r,i,a){let s,o=Math.min(t,e),l=Math.max(t,e),h=o+"_"+l;if(r.has(h))s=r.get(h);else{s={a:n[o],b:n[l],newEdge:null,faces:[]},r.set(h,s)}s.faces.push(i),a[t].edges.push(s),a[e].edges.push(s)}function Iu(t,e,n,r,i){t.push(new Au(e,n,r,void 0,void 0,i))}function Nu(t,e){return Math.abs(e-t)/2+Math.min(t,e)}function ju(t,e,n,r){t.push([e.clone(),n.clone(),r.clone()])}var Bu=new o,Uu=class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,depth:0,spikes:5,cornerRadius:0,extrudeBevelSize:0,extrudeBevelSegments:3},t.parameters);return{shape:t.shape&&t.shape instanceof Tc?t.shape:new Tc,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??0)})}}static build(t){let{width:e,height:n,spikes:r,cornerRadius:i,depth:a,extrudeBevelSize:s,extrudeBevelSegments:o}=t.parameters,l=t.shape,h=.5*e,d=.5*n,c=2*Math.PI/r;for(let p=0;p<r;p++){let t=c*p,e=0+Math.sin(t)*h,n=0+Math.cos(t)*d;l.addPoint(l.createPoint(e,n))}l.isClosed=!0;for(let p=0,f=l.points.length;p<f;p++)l.points[p].roundness=i;l.roundness=i,l.update();let u=ou.create({shape:l,parameters:{roundness:i,depth:a,extrudeBevelSize:s,extrudeBevelSegments:o}});return Object.assign(u,{userData:{...t,type:"PolygonGeometry"}})}};function ku(t,e,n){n.x=t.x*e.x,n.y=t.y,n.z=t.x*e.y}function Ru(t,e,n,r,i,a){let s=e.clone().sub(t),o=n.clone().sub(t),l=s.angleTo(o);if(s.normalize(),o.normalize(),r===i){let e=s.add(o).normalize();a.copy(t).addScaledVector(e,r/Math.sin(l/2))}else{let e=s.angleTo(o);a.copy(t),a.addScaledVector(s,i/Math.sin(e)),a.addScaledVector(o,r/Math.sin(e))}}function Fu(t,e,n){let r=t.clone().sub(e),i=n.clone().sub(e);return r.projectOnVector(i),r.add(e)}var Vu=class extends e{constructor(t=.5,e=1,n=4,r=1,i=!1,a=0,s=4){super(),n=Math.floor(Math.max(3,n)),r=Math.floor(r),s=Math.floor(s);let h,d=[],c=[],u=[],p=[],f=0,m=e/2,g=Math.PI/n,v=t*Math.cos(Math.PI/n),y=2*Math.PI/n,b=(n-2)*Math.PI/n,x=Math.PI-b,w=new o(0,-m,0),_=new o(0,m,0),A=new l(t,-m),O=new l(v,-m),M=new l(0,_.y).sub(O),C=new l(0,_.y).sub(A),P=new l(M.y,-M.x).normalize(),D=new l(C.y,-C.x).normalize(),T=t*Math.cos(Math.PI/n)*Math.tan((Math.PI-M.angle())/2)-1e-8;a=Math.min(a,T);{let t=new o(P.x,P.y,0),e=new o(Math.cos(y)*t.x,t.y,Math.sin(y)*t.x);h=t.angleTo(e)}let z=a/Math.tan((Math.PI-M.angle())/2),E=a/Math.tan((Math.PI-h)/2),L=new o;if(!i){c.push(w.x,w.y,w.z),u.push(0,-1,0),p.push(0,0);let t=f++,e=[],r=A.clone(),i=z/Math.cos(Math.PI/n);r.x-=i;for(let a=0;a<n;a++){let t=a/n*Math.PI*2+g;ku(r,new l(Math.sin(t),Math.cos(t)),L),c.push(L.x,L.y,L.z),u.push(0,-1,0),p.push(0,0),e.push(f++)}for(let n=0;n<e.length;n++)d.push(e[n],t,e[(n+1)%e.length])}{let t=new o,e=new o,r=new o,i=new o,m=new o,v=new o;for(let y=0;y<n;y++){let b=y/n*Math.PI*2+g,x=(y+.5)/n*Math.PI*2+g,S=(y+1)/n*Math.PI*2+g,O=new l(Math.sin(b),Math.cos(b)),C=new l(Math.sin(x),Math.cos(x)),T=new l(Math.sin(S),Math.cos(S));ku(A,O,e),ku(A,T,r),ku(P,C,t),Ru(_,e,r,E,E,i),c.push(i.x,i.y,i.z),Ru(e,_,r,E,z,m),c.push(m.x,m.y,m.z),Ru(r,e,_,z,E,v),c.push(v.x,v.y,v.z),u.push(t.x,t.y,t.z),u.push(t.x,t.y,t.z),u.push(t.x,t.y,t.z),p.push(0,0),p.push(0,0),p.push(0,0);let L=f++,j=f++,B=f++;if(d.push(L,j,B),a>0){{let t=e.clone().add(r).multiplyScalar(.5),n=_.clone().sub(t).normalize(),i=w.clone().sub(t).normalize().add(n).normalize().multiplyScalar(-1);I(t,v.clone().sub(m),i,M.angle())}let l,g;{let t=new o;ku(D,T,t);let e=v.clone().add(i).multiplyScalar(.5);e=Fu(e,r,_);let n=v.clone().sub(i);[l,g]=I(e,n,t,h,i.y)}{let t=l,e=t.clone().setY(0).normalize(),n=new o(0,-1,0),r=e.clone().cross(n);N(t,e,n,r)}{let e=M.angle(),r=Math.PI-e,i=_.clone();i.y-=a/Math.sin(e-Math.PI/2);let l=new o,h=[];for(let o=0;o<s;o++){let e=[],d=Math.PI/2-r*o/s,m=Math.cos(d),g=Math.sin(d),v=x;for(let r=0;r<=o;r++){let r=Math.cos(v),s=Math.sin(v);t.x=m*s,t.y=g,t.z=m*r,l.copy(i).addScaledVector(t,a),c.push(l.x,l.y,l.z),u.push(t.x,t.y,t.z),p.push(0,0),e.push(f++),v+=2*Math.PI/o/n}h.push(e)}g.reverse(),h.push(g);let m=h.length-1;for(let t=0;t<m;t++){let e=h[t],n=h[t+1],r=e.length-1;d.push(n[1],e[0],n[0]);for(let t=1;t<=r;t++)d.push(e[t],e[t-1],n[t]),d.push(n[t+1],e[t],n[t])}}}}}function I(t,e,n,r,i){let l=-r/2,h=(Math.PI-r)/2,m=e.clone().normalize().cross(n);t.addScaledVector(n,-a/Math.sin(h));let g=new o,v=new o,y=f,b=[];for(let o=0;o<=s;o++){let h=l+o/s*r;v.set(0,0,0),v.addScaledVector(m,Math.sin(h)),v.addScaledVector(n,Math.cos(h));for(let n=0;n<=1;n++){let r=n/1-.5;if(g.copy(t),g.addScaledVector(e,r),g.addScaledVector(v,a),null!=i){let t=Math.max(0,g.y-i);g.addScaledVector(e,-t/e.y)}c.push(g.x,g.y,g.z),u.push(v.x,v.y,v.z),p.push(0,0),0===n&&b.push(f),f++}}for(let a=0;a<s;a++)for(let t=0;t<1;t++){let e=y+t+2*a,n=e+2,r=n+1,i=e+1;d.push(e,n,i),d.push(n,r,i)}return[t.clone().addScaledVector(e,.5),b]}function N(t,e,n,r){let i=Math.PI/2,l=C.angle()-i,h=[],m=new o,g=new o;for(let o=0;o<=s;o++){let d=[],v=o/s;for(let s=0;s<=o;s++){let h=((o?s/o:0)-.5)*x,y=Math.cos(h),b=Math.sin(h),w=(i+Math.atan(Math.tan(l)*y))*v,_=Math.cos(w),S=Math.sin(w);m.set(0,0,0),m.addScaledVector(e,S*y),m.addScaledVector(n,_),m.addScaledVector(r,S*b),g.copy(t).addScaledVector(m,a),c.push(g.x,g.y,g.z),u.push(m.x,m.y,m.z),p.push(0,0),d.push(f++)}h.push(d)}let v=h.length-1;for(let a=0;a<v;a++){let t=h[a],e=h[a+1],n=t.length-1;d.push(t[0],e[1],e[0]);for(let r=1;r<=n;r++)d.push(t[r-1],t[r],e[r]),d.push(t[r],e[r+1],e[r])}}this.setIndex(d),this.setAttribute("position",new S(c,3)),this.setAttribute("normal",new S(u,3)),this.setAttribute("uv",new S(p,2))}},Gu=class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,depth:0,cornerRadius:[0,0,0,0],cornerType:1,extrudeBevelSize:0,extrudeBevelSegments:1},t.parameters),r=Object.assign((null==e?void 0:e.ui)??{enabledIndieCorners:!1},t.ui);return{shape:t.shape&&t.shape instanceof Tc?t.shape:new Tc,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??0)}),ui:r}}static build(t){let e=t.shape,{width:n,height:r,cornerRadius:i,cornerType:a,depth:s,extrudeBevelSize:o,extrudeBevelSegments:l}=t.parameters,h={x:.5*n,y:.5*r},d={x:-h.x,y:-h.y},c={x:h.x,y:h.y};function u(t,e,i){return e>n&&i>r?Math.min(t*n/e,t*r/i):e>n?t*n/e:i>r?t*r/i:t}let p=[];p[0]=0===i[0]?0:u(i[0],i[0]+i[3],i[0]+i[1]),p[1]=0===i[1]?0:u(i[1],i[1]+i[2],i[1]+i[0]),p[2]=0===i[2]?0:u(i[2],i[2]+i[1],i[2]+i[3]),p[3]=0===i[3]?0:u(i[3],i[3]+i[0],i[3]+i[2]);let f=d.x,m=c.x,g=c.y,v=d.y;e.addPoint(e.createPoint(f,g)),e.addPoint(e.createPoint(m,g)),e.addPoint(e.createPoint(m,v)),e.addPoint(e.createPoint(f,v)),e.isClosed=!0;let y=!0;for(let x=0,w=e.points.length;x<w;x++)e.points[x].roundness=p[x],x>0&&p[x]!==p[x-1]&&(y=!1);y&&(e.roundness=p[0]),e.useCubicForRoundedCorners=1!==a,e.update();let b=ou.create({shape:e,parameters:{depth:s,extrudeBevelSize:o,extrudeBevelSegments:l}});return Object.assign(b,{userData:{...t,type:"RectangleGeometry"}})}},Hu=class extends e{constructor(t=1,e=1,n=1,r=90,i=10,a=24){super(),this.type="BackdropGeometry";let s=[],l=[],h=[],d=.001;0==i&&(a=1),a=Math.max(1,Math.floor(a)),i=Math.min(i,100),r=Math.min(180-d,r),r*=Math.PI/180;let c=[],u=Math.PI/2,p=(t=0,e=0,n=0)=>new o(t,e,n),f=p(),m=p(),[g,v,y]=[e/2,t/2,n/2],b=-v,x=+v,[w,_,A]=[p(b,-g,+y),p(b,-g,-y),p(b,+g,-y)],O=(t,e=!1)=>Math.sin(t-Math.PI/(+e+1)),M=(t,e=!1)=>Math.cos(t-Math.PI/(+e+1));A.y=Math.sin(r)*e-g;let C=Math.cos(r)*e-y,P=w.z-d;r<=u?(A.z=Math.min(C,P),A.z==P&&(A.y-=(C-P)/Math.tan(u-r))):_.z=Math.min(_.z-C-y,w.z-d),f.subVectors(w,_),m.subVectors(A,_);let D=Math.min(f.length(),m.length())*i/100,T=D*Math.tan(r/2),z=D/Math.cos(r/2),E=f.clone().normalize().add(m.normalize()).setLength(z).add(_);f.set(0,O(r,!0),M(r,!0)),c.push([A,f.clone()]);let L=(Math.PI-r)/a;for(let o=0;o<=a;o++){let t=u+r+o*L;f.set(0,Math.sin(t)*T,Math.cos(t)*T),f.add(E),m.set(0,O(t),M(t)),c.push([f.clone(),m.clone()])}c.push([w,p(0,1,0)]);let I=Math.sin(L/2)*T*2,N=c.length-1,j=c[0][0].distanceTo(c[1][0]),B=j+I*a+c[N-1][0].distanceTo(c[N][0]);c[0].push(1);for(let o=0;o<=a;o++)c[o+1].push(1-(j+o*I)/B);c[N].push(0);let U,k,R,[F,V,G]=c[0];for(let o=1;o<c.length;o++)[U,k,R]=c[o],s.push(b,F.y,F.z,b,U.y,U.z,x,F.y,F.z,x,F.y,F.z,b,U.y,U.z,x,U.y,U.z),l.push(0,V.y,V.z,0,k.y,k.z,0,V.y,V.z,0,V.y,V.z,0,k.y,k.z,0,k.y,k.z),h.push(0,G,0,R,1,G,1,G,0,R,1,R),[F,V,G]=[U,k,R];this.setAttribute("position",new S(s,3)),this.setAttribute("normal",new S(l,3)),this.setAttribute("uv",new S(h,2))}},Wu=class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,depth:0,innerRadiusPercent:38.19,spikes:5,cornerRadius:0,angle:360,extrudeBevelSize:0,extrudeBevelSegments:1},t.parameters);return{shape:t.shape&&t.shape instanceof Tc?t.shape:new Tc,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??0)})}}static build(t){let{width:e,height:n,innerRadiusPercent:r,spikes:i,cornerRadius:a,angle:s,depth:o,extrudeBevelSize:l,extrudeBevelSegments:h}=t.parameters,d=t.shape,c=.5*e,u=.5*n,p=s*Math.PI/360/i,f=Math.PI/2*3*-1,m=c*r/100,g=u*r/100;if(3===i&&50===r){p=2*Math.PI/i;for(let t=0;t<i;t++){let e=p*t,n=0+Math.sin(e)*c,r=0+Math.cos(e)*u;d.addPoint(d.createPoint(n,r))}}else for(let y=0;y<i;y++){let t=0+Math.cos(f)*c,e=0+Math.sin(f)*u;d.addPoint(d.createPoint(t,e)),f+=p,t=0+Math.cos(f)*m,e=0+Math.sin(f)*g,d.addPoint(d.createPoint(t,e)),f+=p}d.isClosed=!0;for(let y=0,b=d.points.length;y<b;y++)d.points[y].roundness=a;d.roundness=a,d.update();let v=ou.create({shape:d,parameters:{roundness:a,depth:o,extrudeBevelSize:l,extrudeBevelSegments:h}});return Object.assign(v,{userData:{...t,type:"StarGeometry"}})}};var qu=new s,$u=new s;var Xu=class extends e{constructor(t){super(),this.type="PathExtrusionGeometry",this.inputs=t,this.build()}_isGeometryClosed(){return this.inputs.path.isClosed&&1===this.inputs.parameters.extrusion.depth}_isOpenEnded(){let t=this.inputs.parameters.extrusion;return!(this.inputs.path.isClosed&&1===t.depth&&function(t,e){let n=2*Math.PI;return(t%n+n)%n==(e%n+n)%n}(t.twist,0)&&t.startScale===t.endScale)}build(){let t=this._extractPathPoints();if(t.length<2)return;let e=this._computeBasisMatrices(t),{depth:r,offset:i}=this.inputs.parameters.extrusion,a=this.inputs.path.isClosed?t.length:t.length-1,l=Math.floor(i*a),h=this.inputs.path.isClosed?Math.ceil((r+i)*a):Math.ceil(Math.min(1,r+i)*a),d=Math.min(Math.max(2,h-l+1),a+2),c=[],u=[];for(let n=0;n<d;n++){let r=this.inputs.path.isClosed?(n+l)%t.length:Math.min(n+l,t.length-1);c.push(t[r].clone()),u.push(e[r].clone())}let p=(t,e,n)=>{c[t]=c[t].clone().lerp(c[e],n),u[t]=function(t,e,n){let r=[new o,new o,new o],i=[new o,new o,new o];return t.extractBasis(r[0],r[1],r[2]),e.extractBasis(i[0],i[1],i[2]),r.forEach(((t,e)=>{let r=i[e],a=x.lerp(t.length(),r.length(),n);t.lerp(r,n).setLength(a)})),(new s).makeBasis(r[0],r[1],r[2])}(u[t],u[e],n)},f=0,m=i*a%1;(!this.inputs.path.isClosed||r<=1)&&(m||0===i)&&(f=m,p(0,1,f));let g=0,v=(i+r)*a%1;if((this.inputs.path.isClosed&&r<=1||!this.inputs.path.isClosed&&i+r<1)&&v&&(g=v,p(c.length-1,c.length-2,1-g)),0===r){let t=c.length-1;c[t].copy(c[0]),u[t].copy(u[0])}this._applyPathModifiers(u,f,g);let{bevel:y,bevelSides:b}=this.inputs.parameters.extrusion,w=y>0?this.inputs.parameters.extrusion.capType:"flat",_=5;"Custom"===this.inputs.parameters.extrusion.shape.type&&(_="low"===this.inputs.parameters.extrusion.shape.shapeQuality?5:12);let S,{regions:A,infos:O,vertices:M}=this._computeShapePoints(_),C=0;"round"===w&&(S=new iu(this.inputs.shapeData,2*y,y,_,b,void 0,!0),C=S.getAttribute("position").count);let P=0,D=0;O.sort(((t,e)=>t.start-e.start)),O.forEach((t=>{t.verticesStart=P,t.verticesCount=t.continuous.reduce(((t,e,n)=>t+(0!==n&&e?1:2)),0),D+=t.verticesCount,P=D}));let T,z=D*d,E=0;if(this._isOpenEnded()&&"flat"===w){try{T=Kc({windingRule:_c.ODD,elementType:Sc.POLYGONS,polySize:3,vertexSize:2,strict:!0,contours:A})}catch{T=nu}E=T.vertexCount}let L=z+2*E+2*C,I=z+2*E,N={positions:new Float32Array(3*L),normals:new Float32Array(3*L),uvs:new Float32Array(2*L)},j=[];if(O.forEach((t=>{this._extrudeRegion(t,M,u,c,N,j,this._isGeometryClosed()&&!this._isOpenEnded())})),T&&(this._closeEnd(T,z,j,N,u[0],c[0],!1),this._closeEnd(T,z+E,j,N,u[u.length-1],c[c.length-1],!0)),S){N.positions.set(S.getAttribute("position").array,3*I),N.normals.set(S.getAttribute("normal").array,3*I),N.uvs.set(S.getAttribute("uv").array,2*I);let t=j.length;j.push(...S.getIndex().array.map((t=>t+I))),I+=C,N.positions.set(S.getAttribute("position").array,3*I),N.normals.set(S.getAttribute("normal").array,3*I),N.uvs.set(S.getAttribute("uv").array,2*I);let e=j.length;j.push(...S.getIndex().array.map((t=>t+I))),this.setAttribute("position",new n(N.positions,3)),this.setAttribute("normal",new n(N.normals,3)),this.setAttribute("uv",new n(N.uvs,2)),this.setIndex(j);let r=qu;r.copy(u[u.length-1]).setPosition(c[c.length-1]),this.applyMatrix4OnRange(r,I,L),r.copy(u[0]).setPosition(c[0]).multiply($u.makeScale(1,1,-1)),this.applyMatrix4OnRange(r,I-C,I),this.reverseIndicesOnRange(t,e)}else this.setAttribute("position",new n(N.positions,3)),this.setAttribute("normal",new n(N.normals,3)),this.setAttribute("uv",new n(N.uvs,2)),this.setIndex(j)}_extractPathPoints(){let t=Nd(this.inputs.path).getPoints(this.inputs.path.subdivisions);if(t.length<2)return[];let e=[t[0]];return t.forEach((t=>{e[e.length-1].distanceToSquared(t)>.001&&e.push(t)})),this.inputs.path.isClosed&&e[e.length-1].distanceTo(e[0])<.001&&e.pop(),e}_computeBasisMatrices(t){let e=[],n=t.length,r=this.inputs.path.isClosed,i=new o,a=new o,l=new o,h=new o,d=new o(0,1,0);for(let o=0;o<n;o++){let c,u,p=t[o];c=0===o?r?t[t.length-2]:p.clone().multiplyScalar(2).sub(t[1]):t[o-1],u=o===n-1?r?t[1]:p.clone().multiplyScalar(2).sub(t[o-1]):t[o+1];let f=p.clone().sub(c).normalize(),m=u.clone().sub(p).normalize(),g=f.clone().add(m).normalize();l.copy(g),0===o&&(g.equals(d)||g.clone().negate().equals(d))&&d.set(0,0,1);let v=d.clone().cross(g).normalize(),y=g.clone().cross(v).normalize();d.copy(y),h.copy(v),0===o&&(i.copy(y),a.copy(g));let b=(new s).makeBasis(v,y,g);e.push(b)}let c=r?a:l,u=r?i:new o(0,1,0),p=c.clone().cross(h).normalize(),f=Math.acos(u.dot(p));if(isNaN(f))return e;let m=u.clone().cross(p);c.dot(m)>0&&(f*=-1);for(let o=1;o<e.length;o++){let t=(new s).makeRotationZ(f*o/e.length);e[o].multiply(t)}return e}_applyPathModifiers(t,e,n){let r=t.length,{angle:i,twist:a,startScale:o,endScale:l}=this.inputs.parameters.extrusion,h=new s,d=new s;return t.forEach(((t,s)=>{let c=0===s?0:s===r-1?1:(s-e)/(r-(0===n?0:1)-(e+(1-n)));h.makeRotationZ(x.lerp(i,i+a,c)*x.DEG2RAD);let u=x.lerp(o,l,c);d.makeScale(u,u,u),t.multiply(h).multiply(d)})),t}_computeShapePoints(t=12,e=_c.ODD){let n,r,i=this.inputs.shapeData,a=i.extractShapePointsToFlatArray([],t),s=i.shapeHoles.map((e=>{let n=e.extractShapePointsToFlatArray([],t),r=[];for(let t=n.length-1;t>=1;t-=2){let e=n[t-1],i=n[t-0];r.push(e,i)}return r}));try{n=Kc({windingRule:e,elementType:Sc.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[a]})}catch{n=tu}try{r=Kc({windingRule:_c.ODD,elementType:Sc.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[...s]})}catch{r=eu}if(!n)throw new Error("error generating geometry");let o=n.elementCount;if(r){n.elementCount+=r.elementCount;for(let t=0;t<r.elements.length;t++){let e=r.elements[t],i=t%2==0?n.vertexCount:0;n.elements.push(e+i)}for(let t=0;t<r.vertexIndices.length;t++){let e=r.vertexIndices[t],i=n.vertexCount;n.vertexIndices.push(e+i)}for(let t=0;t<r.vertices.length;t++){let e=r.vertices[t];n.vertices.push(e)}}for(let h=0,d=n.vertexCount;h<d;h++){let t=2*h;n.vertices[t+0],n.vertices[t+1]}let l=[];for(let h=n.elementCount-1;h>=0;h--){let t=h>=o,e=2*h,r=n.elements[e+0],a=n.elements[e+1],s=r+a,d={start:r,count:a,normals:[],isHole:t,continuous:[],verticesStart:0,verticesCount:0};l.push(d);let c=r,u=s-1,p=r+1,f=i.roundedCurves.length;do{let e=c-r;n.vertices[2*u+0],n.vertices[2*u+1];let o=n.vertices[2*c+0],l=n.vertices[2*c+1],h=o-n.vertices[2*p+0],m=l-n.vertices[2*p+1],g=Math.sqrt(h*h+m*m);h/=g,m/=g,d.normals[2*e+0]=-m,d.normals[2*e+1]=h;let v=n.vertexIndices[c];if(Array.isArray(v))d.continuous[e]=!1;else{let[t,n]=i.getCurveIndexFromVertexId(v-1,!0);if(n>0&&n<1)d.continuous[e]=!0;else{let r=1===n?t+1:t-1;r=(r+f)%f;let a=1===n?0:1,s=i.roundedCurves[t].getTangent(n),o=i.roundedCurves[r].getTangent(a);d.continuous[e]=s.dot(o)>.95}}t&&(d.normals[2*e+0]*=-1,d.normals[2*e+1]*=-1),[u,c,p]=[c,p,p+1],p>=s&&(p-=a)}while(p!==r+1)}return{regions:[a,...s],infos:l,vertices:n.vertices}}_insertVertex(t,e,n,r,i){let a=2*e,s=3*e;t.positions[s+0]=n.x,t.positions[s+1]=n.y,t.positions[s+2]=n.z,t.normals[s+0]=r.x,t.normals[s+1]=r.y,t.normals[s+2]=r.z,t.uvs[a+0]=i.x,t.uvs[a+1]=i.y}_extrudeRegion(t,e,n,r,i,a,s){let h=new o,d=new o,c=new o,u=new o,p=new l;n.forEach(((a,s)=>{let o=r[s],l=t.verticesStart*n.length+t.verticesCount*s;for(let r=0;r<t.count;r++){let f=2*(t.start+r);if(h.set(e[f+0],e[f+1],0),c.copy(h).applyMatrix4(a).add(o),t.continuous[r])u.set(t.normals[2*r+0],t.normals[2*r+1],0);else{let n=0===r?2*(t.start+t.count-1):f-2;d.set(e[n+0],e[n+1],0),u.copy(h).sub(d),u.set(-u.y,u.x,0),t.isHole||u.negate()}if(u.applyMatrix4(a).normalize(),p.set(0===r?1:r/t.count,s/(n.length-1)),this._insertVertex(i,l,c,u,p),l++,!t.continuous[r]||0===r){if(0===r)u.set(t.normals[2*r+0],t.normals[2*r+1],0),p.set(0,s/(n.length-1));else{let n=r===t.count-1?2*t.start:f+2;d.set(e[n+0],e[n+1],0),u.copy(d).sub(h),u.set(-u.y,u.x,0),t.isHole||u.negate()}u.applyMatrix4(a).normalize(),this._insertVertex(i,l,c,u,p),l++}}}));let f=n.length-1;for(let o=0;o<f;o++){let e=t.verticesStart*n.length+t.verticesCount*o,r=t.verticesStart*n.length+t.verticesCount*(o+1),i=0;for(let n=0;n<t.count;n++){(!t.continuous[n]||0===n)&&i++;let s=n===t.count-1?0:i+1,o=e+i,l=e+s,h=r+s,d=r+i;t.isHole?a.push(o,h,l,o,d,h):a.push(o,l,h,o,h,d),i++}}}_closeEnd(t,e,n,r,i,a,s){let h=t.vertexCount,d=new o(0,0,s?-1:1).applyMatrix4(i),c=new o,u=new l;for(let o=0;o<h;o++){let n=2*o;c.set(t.vertices[n+0],t.vertices[n+1],0).applyMatrix4(i).add(a),this._insertVertex(r,e+o,c,d,u)}let p=t.elements;for(let o=0;o<t.elementCount;o++){let t=3*o,r=p[t+0]+e,i=p[t+(s?1:2)]+e,a=p[t+(s?2:1)]+e;n.push(r,i,a)}}applyMatrix4OnRange(t,e,n){let r,i,a,s,o=t.elements,l=(new w).getNormalMatrix(t).elements,h=this.attributes.position,d=this.attributes.normal;if(!h||!d)return;let c=h.array,u=d.array,p=h.itemSize;for(let f=e*p,m=n*p;f<m;f+=p)r=c[f+0],i=c[f+1],a=c[f+2],s=1/(o[3]*r+o[7]*i+o[11]*a+o[15]),c[f+0]=(o[0]*r+o[4]*i+o[8]*a+o[12])*s,c[f+1]=(o[1]*r+o[5]*i+o[9]*a+o[13])*s,c[f+2]=(o[2]*r+o[6]*i+o[10]*a+o[14])*s,r=u[f+0],i=u[f+1],a=u[f+2],u[f+0]=l[0]*r+l[3]*i+l[6]*a,u[f+1]=l[1]*r+l[4]*i+l[7]*a,u[f+2]=l[2]*r+l[5]*i+l[8]*a;h.needsUpdate=!0,d.needsUpdate=!0}reverseIndicesOnRange(t,e){let n=this.index;if(n){for(let r=t;r<e;r+=3){let t=n.getX(r),e=n.getX(r+1),i=n.getX(r+2);n.setXYZ(r,i,e,t)}n.needsUpdate=!0}}};function Yu(){let t=new e;return t.setAttribute("position",new n(new Float32Array([]),3)),t.setIndex(new n(new Uint16Array([]),1)),t}var Ku=Yu().attributes,Zu=class extends e{constructor(t,e){super(),this.charWidths=[],this.charCoords=[],this.wrappedText=[],this.isLowResolution=!1,this.vectorShapes=[],Object.assign(this.attributes,Ku),this.userData={parameters:t,type:"TextGeometry"};let n=e.getFont(t.font);(null==n?void 0:n.isLoaded)?(this.font=n,this.update(t)):this.updateFont(t.font,e).then((()=>{this.update(t),null==e||e.requestRender()}))}async updateFont(t,e){let n=e.getFont(t);n&&(this.font=n,await n.loadingPromise)}update(t){let e=this.font;if(this.userData={parameters:t,type:"TextGeometry"},!(null==e?void 0:e.isLoaded))return void console.warn("Cannot update text because its font is not loaded");let{width:n,height:r,depth:i,extrudeBevelSize:a,extrudeBevelSegments:s,text:o,textTransform:l}=t,h=Oh.getDisplayedValue(o),d=function(t,e,n){let r=[""],i="";for(let a of n)i+=a," "===a||"\n"===a?(r[r.length-1]+=i,i="","\n"===a&&r.push("")):e.getTextWidth(r[r.length-1]+i,t)>t.width&&(r[r.length-1].length&&r.push(""),e.getTextWidth(r[r.length-1]+i,t)>t.width&&(1===i.length?(r[r.length-1]+=i,i=""):(r[r.length-1]+=i.slice(0,-1),i=i[i.length-1],r.push(""))));return r[r.length-1]+=i,r}(t,e,2===l?h.toUpperCase():3===l?h.toLowerCase():h),{shapes:c,charWidths:u,charCoords:p}=e.generateShapes(d,t),f=.5*("number"==typeof n?n:1),m=.5*("number"==typeof r?r:1),g=c.map((t=>(new Tc).fromShape(t,!0)));this.vectorShapes=g;let v=g.map((t=>ou.create({shape:t,parameters:{depth:i,extrudeBevelSegments:s,extrudeBevelSize:a,windingRule:i<=0?_c.NONZERO:_c.ODD,subdivisions:this.isLowResolution&&i>0?1:12}}))),y=v.length?zt(v):Yu();y.translate(-f,m,0),this.dispose(),this.wrappedText=d,this.charCoords=p,this.charWidths=u,this.deleteAttribute("extrudeNormal"),Object.entries(y.attributes).forEach((([t,e])=>{this.setAttribute(t,e)})),this.setIndex(y.index),this.computeBoundingSphere()}clone(){let t=Zt(new e,Zu.prototype);return t.copy(this),console.log("CloneGeometry",this,t),t}copy(t){return Object.entries(t.attributes).forEach((([t,e])=>{this.setAttribute(t,e)})),this.setIndex(t.index),this.userData={parameters:{...t.userData.parameters},type:"TextGeometry"},this}async setText(t){this.font&&await this.font.loadingPromise,await this.update({...this.userData.parameters,text:t})}get text(){return this.userData.parameters.text??""}};var Qu,Ju,tp=new Promise((t=>{Qu=t})),ep=!1;function np(){if(!ep)return Ju||(Ju=async function(){let e=t((()=>import("./process-d14b7238.js")),[]),[n,r]=await Promise.all([e,fetch("https://unpkg.com/@splinetool/modelling-wasm@0.9.473/build/process.wasm").then((t=>t.arrayBuffer()))]),i=n.default,a=await i({wasmBinary:r});Qu(a),ep=!0}(),Ju)}function rp(t,e,n,r){var i;let a,s,o;"PathGeometry"===t.type?(s=JSON.parse(JSON.stringify(t)),o=[[],["extrusion"]]):(s={...t},o=[[]]);for(let c of o){let t=s;for(let e of c)t=t[e];for(a in t){let n=t[a];wl(n)&&(t[a]=e.getVariable(n,[r.uuid,"geometry",...c,a]))}}let l,h={parameters:s,type:s.type};if("PathGeometry"===s.type)h.path=s.path;else if("VectorGeometry"===s.type){let t=Tc.createFromState(s.shape,s.width,s.height);h.shape=t}else if("NonParametricGeometry"===s.type)s.data.groups&&(null==(i=s.data.groups)||i.forEach((t=>t.materialIndex=Math.max(t.materialIndex??0,0)))),h.geometry=(new I).parse(s);else{if("SubdivGeometry"===s.type){let e=new up(s,n);return e.data=t,e}if("TextGeometry"===s.type)return new Zu(s,e)}try{l=Ep(h)}catch(d){console.error(d)}if(!l){let t=Tc.createFromState(Rl.defaultData(),100,100);h.shape=t,l=Ep(h)}return l}var ip=new s;function ap(t,e,n,r){let i,a,s,o=t.position.array,l=t.normal.array,h=ip.makeScale(e,n,r).invert().elements;for(var d=0,c=o.length;d<c;d+=3)o[d]*=e,o[d+1]*=n,o[d+2]*=r,i=l[d],a=l[d+1],s=l[d+2],l[d]=h[0]*i+h[4]*a+h[8]*s,l[d+1]=h[1]*i+h[5]*a+h[9]*s,l[d+2]=h[2]*i+h[6]*a+h[10]*s;t.position.needsUpdate=!0,t.normal.needsUpdate=!0}var sp,op=new c,lp=new o;tp.then((t=>{sp=t}));var hp=new Float32Array([10,10,0,-10,10,0,-10,-10,0,10,-10,0]),dp=new Uint32Array([0,1,2,3]),cp=new Uint8Array([4]),up=class extends e{constructor(t,e){super(),this.data=t,this.flatShading=e,this.subdivPointer=0,this.rebuild(),this.freeSubdivPointer()}mutateDirectlyScaleBaked(t,e){this.freeSubdivPointer();let n=this.data.scaleBaked,r=el.div(e,n);this.subdividedGeometry&&ap(this.subdividedGeometry.attributes,...r),this.originalGeometry&&ap(this.originalGeometry.attributes,...r),this.data=t;let i=this.userData.parameters;this.userData.parameters={width:i.width*r[0],height:i.height*r[1],depth:i.depth*r[2]},this.originalGeometry.boundingSphere.center.multiply(lp.fromArray(r));let a=lp.set(i.width,i.height,i.depth).length();this.originalGeometry.boundingSphere.radius=a/2}ensureSubdivPointer(){return 0===this.subdivPointer&&this.rebuild(),this.subdivPointer}rebuild(){let t,e,n;try{({originalGeometry:t,subdividedGeometry:e,subdivPointer:n}=up.build(this.data,void 0,!this.flatShading,void 0))}catch{t=new O(100,100,100),n=0}this.subdivPointer=n,this.originalGeometry=t,this.subdividedGeometry=e??void 0;let r=this.subdividedGeometry??this.originalGeometry;Object.assign(this,r),this.calcBoundingBox()}freeSubdivPointer(){this.subdivPointer&&(up.freeSubdivPointer(this.subdivPointer),this.subdivPointer=0)}dispose(){super.dispose(),this.freeSubdivPointer()}calcBoundingBox(){let t=this.originalGeometry;null===t.boundingSphere&&(t.boundingSphere=new m,this.subdividedGeometry&&(this.subdividedGeometry.boundingSphere=t.boundingSphere));let e=t.attributes.position,n=t.boundingSphere.center;op.setFromBufferAttribute(e),op.getCenter(n),t.boundingSphere.radius=n.distanceTo(op.max),isNaN(t.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this),op.getSize(lp);let r={width:lp.x,height:lp.y,depth:lp.z};return this.userData.parameters=r,r}static build(t,e,n,r){let i,a,s,o=(null==t?void 0:t.phongAngle)??35;!1===n&&(o=-1),e&&(sp.free_bvh(e),sp.free_subdivision_surface(e));try{i=up.allocate(t,r)}catch(ol){console.error(ol,t),i=up.allocate({positionWASM:hp,indexWASM:dp,verticesPerFaceWASM:cp},r)}if(sp.set_destination_refinement_level(i,0),a=up.buildLevel(i,!0,o),t.subdivisions>0)try{sp.set_destination_refinement_level(i,t.subdivisions),s=up.buildLevel(i,!1,o)}catch{try{sp.set_destination_refinement_level(i,t.subdivisions-1),s=up.buildLevel(i,!1,o)}catch{s=null}}else s=null;return{subdivPointer:i,originalGeometry:a,subdividedGeometry:s}}static primitiveToQuads(t,e,n){t.widthSegments>16&&(t.widthSegments=16),t.heightSegments>16&&(t.heightSegments=16),t.depthSegments>16&&(t.depthSegments=16),t.radialSegments>16&&(t.radialSegments=16),"DodecahedronGeometry"===t.type&&(t.detail=0);let r,i,a,s,o,l,h=void 0!==t.shape||void 0!==t.path?e.geometry:rp(t,n,!1);if(r="TorusGeometry"===t.type&&t.arc===2*Math.PI?h.getClosedTorusIndicesForBooleanOrSubdiv():h.getIndex(),({positions:i,triIndices:o}=fp(h.getAttribute("position"),r)),"CylinderGeometry"===t.type&&0===t.cornerRadius&&0===t.hollow&&!1===t.openEnded){let e=t.radialSegments*t.heightSegments*3*2;l=[e,e+3*t.radialSegments]}return({indices:a,verticesPerFace:s}=bp(i,o,h,l)),{positions:i,indices:a,verticesPerFace:s}}static allocate(t,e){var n;let r,i,a,o=[],l=[];t.positionWASM&&t.positionWASM.length>0?(r=t.positionWASM,i=t.indexWASM,a=t.verticesPerFaceWASM):(r=hp,i=dp,a=cp);let h,d=r.length,c=i.length,u=a.length,p=r.length+o.length+l.length,f=i.length+a.length,m=p*Float32Array.BYTES_PER_ELEMENT+f*Uint32Array.BYTES_PER_ELEMENT,g=p*Float32Array.BYTES_PER_ELEMENT,v=sp._malloc(m),y=new Float32Array(sp.HEAPF32.buffer,v,p),b=new Uint32Array(sp.HEAPU32.buffer,v+g,f);y.set(r,0),y.set(o,r.length),y.set(l,r.length+o.length),b.set(i,0),b.set(a,i.length),(null==(n=null==t?void 0:t.scaleBaked)?void 0:n.some((t=>1!==t)))&&(h=(new s).makeScale(...t.scaleBaked)),e&&(h?h.premultiply(e):h=e);let x=h?sp.alloc_subdivision_surface2(v,d,v+g,c,v+g+i.length*Uint32Array.BYTES_PER_ELEMENT,u,h.elements):sp.alloc_subdivision_surface(v,d,v+g,c,v+g+i.length*Uint32Array.BYTES_PER_ELEMENT,u);return sp._free(v),x}static buildLevel(t,r,i,a,s){let o=s?sp.get_mesh_data2(t,r?sp.Level.CONTROL:sp.Level.REFINED,i,s.elements):sp.get_mesh_data(t,r?sp.Level.CONTROL:sp.Level.REFINED,i),l=sp.HEAPU32.subarray(o>>2,8+(o>>2)),d=l.subarray(4,8),c=0,u=sp.HEAPU32[l[c]>>2],p=sp.HEAPF32.subarray(u>>2,(u>>2)+d[c]);c++;let f=sp.HEAPU32[l[c]>>2],m=sp.HEAPF32.subarray(f>>2,(f>>2)+d[c]);c++;let g=sp.HEAPU32[l[c]>>2],v=sp.HEAPU32.subarray(g>>2,(g>>2)+d[c]);c++;let y=sp.HEAPU32[l[c]>>2],b=sp.HEAPU32.subarray(y>>2,(y>>2)+d[c]);if(c++,void 0===a){let t=new e;if(t.setIndex(new h(b,1)),t.setAttribute("position",new S(p,3)),t.setAttribute("normal",new S(m,3)),r){t.setAttribute("faceMap",new h(v,1));let e=new Float32Array(m.length/3*4).fill(0);t.setAttribute("color",new n(e,4))}return sp.free_mesh_data(o),t.userData.type="SubdivGeometry",t}a.getAttribute("position").copyArray(p),a.getAttribute("normal").copyArray(m),a.attributes.position.needsUpdate=!0,a.attributes.normal.needsUpdate=!0,sp.free_mesh_data(o)}static freeSubdivPointer(t){sp.free_bvh(t),sp.free_subdivision_surface(t)}static buildControlCageWireframe(t,r,i){let a=sp.get_wireframe_data_for_base_level(t),s=sp.HEAPU32.subarray(a>>2,4+(a>>2)),o=s.subarray(2,4),l=0,d=sp.HEAPU32[s[l]>>2],c=sp.HEAPF32.subarray(d>>2,(d>>2)+o[l]);l++;let u=sp.HEAPU32[s[l]>>2],p=sp.HEAPU32.subarray(u>>2,(u>>2)+o[l]);if(void 0===r){let t=new e;t.setAttribute("position",new S(c,3));let r=new Float32Array(c.length);for(let e=0,n=c.length;e<n;)r[e++]=i.r,r[e++]=i.g,r[e++]=i.b;return t.setAttribute("color",new n(r,3)),t.setIndex(new h(p,1)),sp.free_wireframe_data_for_base_level(a),t}r.getAttribute("position").copyArray(c),r.attributes.position.needsUpdate=!0,sp.free_wireframe_data_for_base_level(a)}static updateCollabMesh(t,e,n){let r=0===e;r||sp.set_destination_refinement_level(t,e);let i=n?sp.get_topological_data2(t,r?sp.Level.CONTROL:sp.Level.REFINED,n.elements):sp.get_topological_data(t,r?sp.Level.CONTROL:sp.Level.REFINED),a=sp.HEAPU32.subarray(i>>2,6+(i>>2)),s=a.subarray(3,6),o=0,l=sp.HEAPU32[a[o]>>2],h=new Float32Array(sp.HEAPF32.subarray(l>>2,(l>>2)+s[o]));o++;let d=sp.HEAPU32[a[o]>>2],c=new Uint32Array(sp.HEAPU32.subarray(d>>2,(d>>2)+s[o]));o++;let u=sp.HEAPU32[a[o]>>2],p=new Uint8Array(sp.HEAPU32.subarray(u>>2,(u>>2)+s[o]));return sp.free_topological_data(i),{positions:h,indices:c,verticesPerFace:p}}},pp=["getX","getY","getZ"];function fp(t,e){let n={},r=e?e.count:t.count,i=0,a=[],s=[];for(let l=0;l<r;l++){let r=e?e.getX(l):l,o="";for(let e=0;e<3;e++)o+=~~(1e4*t[pp[e]](r))+",";if(o in n)a.push(n[o]);else{for(let e=0;e<3;e++)s.push(t[pp[e]](r));n[o]=i,a.push(i),i++}}let o=[];for(let l=0;l<a.length;l+=3)a[l]===a[l+1]||a[l]===a[l+2]||a[l+1]===a[l+2]||o.push(a[l],a[l+1],a[l+2]);return{positions:s,triIndices:o}}var mp=new o,gp=new o,vp=new o,yp=new o;function bp(t,e,n,r){let i=[],a=[];if(void 0!==n.userData.shape&&0===n.userData.parameters.depth&&0===n.userData.shape.shapeHoles.length){let e=n.userData.shape.extractShapePointsToFlatArray([]),r=n.userData.parameters.spikes;if("EllipseGeometry"===n.userData.type&&r<=24&&r%4==0&&n.userData.parameters.angle>=360){let t=e.length/2/r;e=e.filter(((e,n)=>Math.floor(n/2)%t==0))}let s=0;for(let t=0;t<e.length;t+=2)s+=(e[t]-e[(0===t?e.length:t)-2])*(e[t+1]+e[(0===t?e.length:t)-1]);t.length=0;let o=0;if(s<0)for(let n=0;n<e.length;n+=2)t.push(e[n],e[n+1],0),i.push(o++);else for(let n=e.length-2;n>=0;n-=2)t.push(e[n],e[n+1],0),i.push(o++);return a.push(o),{indices:i,verticesPerFace:a}}let s=new Float32Array([n.userData.parameters.depth])[0],o=0;for(;o<e.length;){if(n.useNgonForTopBottomFaceDuringBake){let n=0;if((t[3*e[o]+2]===s||0===t[3*e[o]+2])&&n++,(t[3*e[o+1]+2]===s||0===t[3*e[o+1]+2])&&n++,(t[3*e[o+2]+2]===s||0===t[3*e[o+2]+2])&&n++,3===n)break}if(e[o+1]===e[o+3]&&e[o+2]===e[o+5]||e[o+0]===e[o+3]&&e[o+2]===e[o+4]){mp.set(t[3*e[o]],t[3*e[o]+1],t[3*e[o]+2]),gp.set(t[3*e[o+1]],t[3*e[o+1]+1],t[3*e[o+1]+2]),vp.set(t[3*e[o+4]],t[3*e[o+4]+1],t[3*e[o+4]+2]),yp.set(t[3*e[o+5]],t[3*e[o+5]+1],t[3*e[o+5]+2]),gp.sub(mp).normalize(),vp.sub(mp).normalize(),yp.sub(mp).normalize();let n=gp.cross(vp).dot(yp);Math.abs(n)>.005||r&&r.some(((t,e)=>e%2!=1&&(o>=r[e]&&o<r[e+1])))?(i.push(e[o],e[o+1],e[o+2]),a.push(3),o+=3):(i.push(e[o],e[o+1],e[o+4],e[o+5]),a.push(4),o+=6)}else i.push(e[o],e[o+1],e[o+2]),a.push(3),o+=3}if(n.useNgonForTopBottomFaceDuringBake){let e=[],r=[],o=0;for(let n=0,i=0;n<t.length;n+=3,i++)0===t[n+2]&&(e.push(i),o++),t[n+2]===s&&r.push(i);if(0===n.userData.parameters.extrudeBevelSize){let t=r[0];r[0]=r[1],r[1]=t}e.reverse(),i.push(...e,...r),a.push(o,o)}return{indices:i,verticesPerFace:a}}var xp,wp,_p={};function Sp(t){let e=t.length,n=e*Uint32Array.BYTES_PER_ELEMENT,r=e*Float32Array.BYTES_PER_ELEMENT,i=Number.isInteger(t[0])?n:r,a=xp._malloc(i);return(Number.isInteger(t[0])?new Uint32Array(xp.HEAPU32.buffer,a,e):new Float32Array(xp.HEAPF32.buffer,a,e)).set(t,0),a}function Ap(t){switch(t){case 0:return xp.OP.UNION;case 1:return xp.OP.INTERSECTION;case 2:return xp.OP.A_MINUS_B;case 3:return xp.OP.B_MINUS_A;case 4:return xp.OP.SYMMETRIC_DIFFERENCE;case 5:return xp.OP.ALL;default:throw new Error("Unknown boolean operation "+t)}}function Op(t,e){void 0===wp&&(wp=xp.init_csg());let n=Sp(t),r=xp.csg_calc_topological(wp,n,t.length,Ap(e));xp._free(n);let i=xp.HEAPU32.subarray(r>>2,6+(r>>2)),a=i.subarray(3,6),s=0,o=xp.HEAPU32[i[s]>>2],l=new Float32Array(xp.HEAPF32.subarray(o>>2,(o>>2)+a[s]));s++;let h=xp.HEAPU32[i[s]>>2],d=new Uint32Array(xp.HEAPU32.subarray(h>>2,(h>>2)+a[s]));s++;let c=xp.HEAPU32[i[s]>>2],u=new Uint8Array(xp.HEAPU32.subarray(c>>2,(c>>2)+a[s]));return xp.free_mesh_data(r),{positions:l,indices:d,verticesPerFace:u}}function Mp(t,e,n,r){void 0===wp&&(wp=xp.init_csg());let i=Sp(t),a=xp.csg_calc(wp,i,t.length,r,Ap(e));xp._free(i);let s=xp.HEAPU32.subarray(a>>2,5+(a>>2)),o=s.subarray(2,5),l=0,h=xp.HEAPU32[s[l]>>2],d=xp.HEAPF32.subarray(h>>2,(h>>2)+o[l]);l++;let c=xp.HEAPU32[s[l]>>2],u=xp.HEAPF32.subarray(c>>2,(c>>2)+o[l]);l++;let p=o[l];n.setAttribute("position",new S(d,3)),n.setAttribute("normal",new S(u,3));let f=xp.HEAPF32.subarray(5+(a>>2),5+(a>>2)+6);return null===n.boundingSphere&&(n.boundingSphere=new m),n.boundingSphere.radius=-1,n.userData.parameters={width:2*f[3],height:2*f[4],depth:2*f[5]},xp.free_mesh_data(a),p}function Cp(t,e,n){if(void 0===xp)return-1;let r,i,a;if(e&&void 0!==t.userData.positions){let e=t.userData;a=e.verticesPerFace.length,r=e.positions,i=Array(e.verticesPerFace.reduce(((t,e)=>t+e),0)+a);for(let t=0,n=0,r=0;t<e.verticesPerFace.length;t++){i[r++]=e.verticesPerFace[t];for(let a=0;a<e.verticesPerFace[t];a++)i[r++]=e.indices[n++]}}else({positions:r,faceIndices:i,nFaces:a}=function(t,e,n){let r,i;i="TorusGeometry"===t.userData.parameters.type&&t.userData.parameters.arc===2*Math.PI?t.getClosedTorusIndicesForBooleanOrSubdiv():t.getIndex();let a,{positions:s,triIndices:o}=fp(t.getAttribute("position"),i);if(e&&n){let{indices:e,verticesPerFace:n}=bp(s,o,t);a=n.length,r=[];for(let t=0,i=0;t<a;t++){r.push(n[t]);for(let a=0;a<n[t];a++)r.push(e[i++])}}else{let t=o.length;r=Array(t+t/3),a=0;for(let e=0,n=0;n<r.length;)r[n++]=3,a++,r[n++]=o[e++],r[n++]=o[e++],r[n++]=o[e++]}return{positions:s,faceIndices:r,nFaces:a}}(t,e,n));let s=r.length,o=i.length,l=r.length,h=i.length,d=l*Float32Array.BYTES_PER_ELEMENT+h*Uint32Array.BYTES_PER_ELEMENT,c=l*Float32Array.BYTES_PER_ELEMENT,u=xp._malloc(d),p=new Float32Array(xp.HEAPF32.buffer,u,l),f=new Uint32Array(xp.HEAPU32.buffer,u+c,h);return p.set(r,0),f.set(i,0),xp.get_csg_mesh(u,s,u+c,o,a)}function Pp(t){return xp.has_open_edges(t)}function Dp(t,e){xp.transform_csg_mesh(t,e.elements)}function Tp(t){xp.free_csg_mesh(t)}((t,e)=>{for(var n in e)Ut(t,n,{get:e[n],enumerable:!0})})(_p,{calcBoolean:()=>Mp,calcBooleanTopological:()=>Op,freeMeshSet:()=>Tp,getMeshSet:()=>Cp,hasOpenEdges:()=>Pp,transformMeshSet:()=>Dp}),new Promise((t=>{})).then((t=>xp=t));var zp={ConeGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,radialSegments:32,heightSegments:8,openEnded:!1,thetaStart:0,thetaLength:360,cornerRadiusTop:8,cornerRadiusBottom:8,cornerSegments:8},t.parameters);return n.thetaLength=x.clamp(n.thetaLength,0,360),{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??n.width)})}}static build(t){let n,{width:r,depth:i,height:a,radialSegments:s,heightSegments:o,openEnded:l,thetaStart:h,thetaLength:d,cornerRadiusTop:c,cornerRadiusBottom:u,cornerSegments:p}=t.parameters;return 0===d?(n=new e,n.setAttribute("position",new S([],3))):n=c>0||u>0||d<360?new Hd(0,r/2,a,s,o,l,h,d*Math.PI/180,c,u,p,0,!0):new nt(r/2,a,s,o,l),n.scale(1,1,i/r),Object.assign(n,{userData:{...t,type:"ConeGeometry"}})}},CubeGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,widthSegments:1,heightSegments:1,depthSegments:1,cornerRadius:8,cornerSegments:8},t.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??n.width)})}}static build(t){let e,{width:n,height:r,depth:i,widthSegments:a,heightSegments:s,depthSegments:o,cornerRadius:l,cornerSegments:h}=t.parameters;return e=0==l?new O(n,r,i,a,s,o):new qd(n,r,i,a,s,o,l,h),Object.assign(e,{userData:{...t,type:"CubeGeometry"}})}},CylinderGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,radialSegments:64,heightSegments:1,openEnded:!1,thetaStart:0,thetaLength:360,cornerRadius:8,cornerSegments:8,hollow:0},t.parameters);n.thetaLength=x.clamp(n.thetaLength,0,360);let r=n.width/2,i=n.radiusTop??r,a=n.radiusBottom??r;return i===a?(i=r,a=r):i>a?(i=r,a=a*r/i):(i=i*r/a,a=r),{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??n.width),radiusTop:i,radiusBottom:a})}}static build(t){let n,{width:r,depth:i,height:a,radialSegments:s,heightSegments:o,openEnded:l,thetaStart:h,thetaLength:d,radiusTop:c,radiusBottom:u,cornerRadius:p,cornerSegments:f,hollow:m}=t.parameters;return 0===d?(n=new e,n.setAttribute("position",new S([],3))):n=p||m?new Hd(c,u,a,s,o,l,h,d*Math.PI/180,p,p,f,m):new et(c,u,a,s,o,l,h,d*Math.PI/180),n.scale(1,1,i/r),Object.assign(n,{userData:{...t,type:"CylinderGeometry"}})}},DodecahedronGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,detail:0,corner:0,cornerSides:4},t.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??n.width)})}}static build(t){let{width:e,height:n,depth:r,detail:i,corner:a,cornerSides:s}=t.parameters,o=0===i&&0!==a?new Xd(.5*e,a,s):new rt(.5*e,i);return o.scale(1,n/e,r/e),Object.assign(o,{userData:{...t,type:"DodecahedronGeometry"}})}},EllipseGeometry:hu,HelixGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,revolutions:2,segments:40,pathRadius:10,pathType:0,pathSegments:30,cornerRadius:30,cornerSegments:4},t.parameters),r=Math.abs(n.width),i=Math.abs(n.height??r),a=Math.abs(n.depth??r),s=Math.abs(Math.min(r,a))/2;return{parameters:Object.assign(n,{width:r,height:i,depth:a,radius:s,segments:Math.round(n.segments),pathSegments:Math.round(n.pathSegments),cornerSegments:Math.round(n.cornerSegments)})}}static build(t){let{width:e,height:n,depth:r,radius:i,revolutions:a,segments:s,pathRadius:o,pathType:l,pathSegments:h,cornerRadius:d,cornerSegments:c}=t.parameters,u=new vu(!1,e,n,r,i,a,s,o,l,h,d,c);return Object.assign(u,{userData:{...t,type:"HelixGeometry"}})}},IcosahedronGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,detail:0,corner:0,cornerSides:4},t.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??n.width)})}}static build(t){let{width:e,height:n,depth:r,detail:i,corner:a,cornerSides:s}=t.parameters,o=0===i&&0!==a?new yu(.5*e,a,s):new ot(.5*e,i);return o.scale(1,n/e,r/e),Object.assign(o,{userData:{...t,type:"IcosahedronGeometry"}})}},LatheGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){var n;((null==(n=t.parameters)?void 0:n.points)??[]).forEach((t=>{Array.isArray(t)&&(t.x=t[0],t.y=t[1])}));let r=Object.assign({},(null==e?void 0:e.parameters)??{width:100,segments:64,verticalSegments:64,points:[{x:0,y:-50,id:0},{x:50,y:-50,id:1},{x:50,y:50,id:2},{x:0,y:50,id:3}]},t.parameters);return{parameters:Object.assign(r,{width:Math.abs(r.width),height:Math.abs(r.height??r.width),depth:Math.abs(r.depth??r.width)})}}static build(t){let{points:e,segments:n,verticalSegments:r}=t.parameters,i=new $;i.moveTo(e[0].x,e[0].y),i.bezierCurveTo(e[1].x,e[1].y,e[2].x,e[2].y,e[3].x,e[3].y);let a=new lt(i.extractPoints(r).shape,n);return a.rotateZ(Math.PI),Object.assign(a,{userData:{...t,type:"LatheGeometry"}})}},NonParametricGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,n){let r,i=t.geometry??(null==n?void 0:n.geometry)??(new e).copy(new O(100,100,100));void 0===n?(i.computeBoundingBox(),i.boundingBox.getSize(Bu),r={width:Bu.x,height:Bu.y,depth:Bu.z,subdivisions:0}):r=n.parameters;let a={...r,...t.parameters};return{parameters:{width:Math.abs(a.width),height:Math.abs(a.height),depth:Math.abs(a.depth),subdivisions:Math.abs(a.subdivisions)},geometry:i}}static build(t){let{width:n,height:r,depth:i,subdivisions:a}=t.parameters,s=t.geometry??(new e).copy(new O(100,100,100)),h=s.userData.parameters;void 0===h?(s.computeBoundingBox(),s.boundingBox.getSize(Bu)):Bu.set(h.width,h.height,h.depth),(n!==Bu.x||r!==Bu.y||i!==Bu.z)&&s.scale(0===Bu.x?1:n/Bu.x,0===Bu.y?1:r/Bu.y,0===Bu.z?1:i/Bu.z);let d=s.originalGeometry;try{a>0?(void 0===d||(null==h?void 0:h.subdivisions)!==a)&&(void 0===d&&(d=s),s=new class{constructor(t=1){this.subdivisions=t}modify(t){(t=t instanceof e?(new _u).fromBufferGeometry(t):t.clone()).mergeVertices();let n=this.subdivisions;for(;n-- >0;)this._smooth(t);return t.computeFaceNormals(),t.computeVertexNormals(),t}_smooth(t){let e,n,r,i,a,s=new o,h=t.vertices,d=t.faces,c=t.faceVertexUvs[0],u=void 0!==c&&c.length>0,p=[],f=new Map;!function(t,e,n,r){let i,a,s;for(i=0,a=t.length;i<a;i++)n[i]={edges:[]};for(i=0,a=e.length;i<a;i++)s=e[i],Lu(s.a,s.b,t,r,s,n),Lu(s.b,s.c,t,r,s,n),Lu(s.c,s.a,t,r,s,n)}(h,d,p,f);let m,g,v,y,b,x,w,_=[];for(let l of Array.from(f.keys())){for(g=f.get(l),v=new o,b=3/8,x=1/8,w=g.faces.length,2!=w&&(b=.5,x=0),v.addVectors(g.a,g.b).multiplyScalar(b),s.set(0,0,0),i=0;i<w;i++){for(y=g.faces[i],a=0;a<3&&(m=h[zu(y,Tu[a])],m===g.a||m===g.b);a++);m&&s.add(m)}s.multiplyScalar(x),v.add(s),g.newEdge=_.length,_.push(v)}let S,A,O,M,C,P,D,T=[];for(n=0,r=h.length;n<r;n++){for(P=h[n],C=p[n].edges,e=C.length,3==e?S=3/16:e>3&&(S=3/(8*e)),A=1-e*Number(S),O=S,e<=2&&2==e&&(A=3/4,O=1/8),D=P.clone().multiplyScalar(A),s.set(0,0,0),i=0;i<e;i++)M=C[i],m=M.a!==P?M.a:M.b,s.add(m);s.multiplyScalar(Number(O)),D.add(s),T.push(D)}let z,E,L,I,N,j,B,U=T.concat(_),k=T.length,R=[],F=[],V=new l,G=new l,H=new l;for(n=0,r=d.length;n<r;n++)y=d[n],z=Number(Eu(y.a,y.b,f).newEdge)+k,E=Number(Eu(y.b,y.c,f).newEdge)+k,L=Number(Eu(y.c,y.a,f).newEdge)+k,Iu(R,z,E,L,y.materialIndex),Iu(R,y.a,z,L,y.materialIndex),Iu(R,y.b,E,z,y.materialIndex),Iu(R,y.c,L,E,y.materialIndex),u&&(I=c[n],N=I[0],j=I[1],B=I[2],V.set(Nu(N.x,j.x),Nu(N.y,j.y)),G.set(Nu(j.x,B.x),Nu(j.y,B.y)),H.set(Nu(N.x,B.x),Nu(N.y,B.y)),ju(F,V,G,H),ju(F,N,V,H),ju(F,j,G,V),ju(F,B,H,G));t.vertices=U,t.faces=R,u&&(t.faceVertexUvs[0]=F)}}(a).modify(d).toBufferGeometry()):(void 0!==d&&(s=d),d=void 0,void 0===s.getAttribute("normal")&&s.computeVertexNormals())}catch{void 0!==d&&(s=d),d=void 0,void 0===s.getAttribute("normal")&&s.computeVertexNormals()}return void 0!==d&&Object.assign(s,{originalGeometry:d}),delete t.geometry,Object.assign(s,{userData:{...t,type:"NonParametricGeometry"}})}static loadFromUrl(t,e,n){new I(n).load(t,(t=>{let n=this.normalizeInputs({geometry:t});t.boundingBox.getSize(Bu);let r=100/Bu.x;Object.assign(n.parameters,{width:100,height:Bu.y*r,depth:Bu.z*r}),e(this.build(n))}))}},PolygonGeometry:Uu,PyramidGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,radialSegments:4,heightSegments:1,cornerRadius:0,cornerSegments:8,openEnded:!1},t.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??n.width)})}}static build(t){let{width:e,height:n,depth:r,radialSegments:i,heightSegments:a,openEnded:s,cornerRadius:o,cornerSegments:l}=t.parameters,h=new Vu(.5*e,n,i,a,s,o,l);return h.scale(1,1,r/e),Object.assign(h,{userData:{...t,type:"PyramidGeometry"}})}},RectangleGeometry:Gu,SphereGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,widthSegments:64,heightSegments:64,phiStart:0,phiLength:2*Math.PI,thetaStart:0,thetaLength:180},t.parameters);return n.thetaLength=x.clamp(n.thetaLength,0,180),{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??n.width)})}}static build(t){let n,{width:r=100,height:i=r,depth:a=r,widthSegments:s=64,heightSegments:o=64,phiStart:l,phiLength:h,thetaStart:d,thetaLength:c}=t.parameters;return 0===c?(n=new e,n.setAttribute("position",new S([],3))):n=new ht(.5*r,s,o,l,h,d,c*x.DEG2RAD),n.scale(1,i/r,a/r),Object.assign(n,{userData:{...t,type:"SphereGeometry"}})}},PlaneGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,depth:0,widthSegments:8,heightSegments:8},t.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:0})}}static build(t){let{width:e=100,height:n=e,widthSegments:r=8,heightSegments:i=8}=t.parameters,a=new dt(e,n,r,i);return a.scale(1,1,1),Object.assign(a,{userData:{...t,type:"PlaneGeometry"}})}},BackdropGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,angle:90,cornerRadius:24,cornerSegments:8},t.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??n.width)})}}static build(t){let{width:e,height:n,depth:r,angle:i,cornerRadius:a,cornerSegments:s}=t.parameters,o=new Hu(e,n,r,i,a,s);return Object.assign(o,{userData:{...t,type:"BackdropGeometry"}})}},StarGeometry:Wu,TextFrameGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,depth:0},t.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??0)})}}static build(t){let{width:e,height:n}=t.parameters,r=new dt(e,n);return Object.assign(r,{userData:{...t,type:"TextFrameGeometry"}})}},TorusGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,radialSegments:32,tubularSegments:64,arc:360,cornerRadius:30,cornerSegments:8},t.parameters),r=Math.abs(n.width),i=Math.abs(n.height??n.width),a=Math.round(Math.abs(n.depth??.25*n.width));return{parameters:Object.assign(n,{width:r,height:i,depth:a})}}static build(t){let{width:n,height:r,depth:i,radialSegments:a,tubularSegments:s,arc:o,cornerRadius:l,cornerSegments:h}=t.parameters,d=function(t,n,r,i,a,s,o,l,h,d,c){[n,r]=[r,n],o=n/2;let u=x.clamp(a/360,0,1);if(0===u){let t=new e;return t.setAttribute("position",new S([],3)),t}return 1===u&&(d=0),new vu(!0,t,n,r,i,u,s,o,l,h,d,c)}(n,r,i,.5*n,o,s,0,0,a,l,h);return d.scale(1,r/n,1),Object.assign(d,{userData:{...t,type:"TorusGeometry"}})}},TorusKnotGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,tubularSegments:64,radialSegments:32,p:2,q:3},t.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width),depth:Math.abs(n.depth??n.width),tube:n.tube??.125*n.width})}}static build(t){let{width:e,tube:n,tubularSegments:r,radialSegments:i,p:a,q:s}=t.parameters,o=.5*e;o!==n&&(o-=n);let l=new ct(o,n,r,i,a,s);return Object.assign(l,{userData:{...t,type:"TorusKnotGeometry"}})}},TriangleGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,depth:0,spikes:5,cornerRadius:0,extrudeBevelSize:0,extrudeBevelSegments:1,isRect:!1},t.parameters);return{shape:t.shape&&t.shape instanceof Tc?t.shape:new Tc,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs(n.height??n.width*(n.isRect?1:Math.sqrt(3)/2)),depth:Math.abs(n.depth??0)})}}static build(t){let{width:e=100,height:n,cornerRadius:r,depth:i,extrudeBevelSize:a,extrudeBevelSegments:s,isRect:o}=t.parameters,l=t.shape,h=.5*e,d=.5*n;o?(l.addPoint(l.createPoint(-h,d)),l.addPoint(l.createPoint(h,-d)),l.addPoint(l.createPoint(-h,-d))):(l.addPoint(l.createPoint(0,d)),l.addPoint(l.createPoint(h,-d)),l.addPoint(l.createPoint(-h,-d))),l.isClosed=!0;for(let u=0,p=l.points.length;u<p;u++)l.points[u].roundness=r;l.roundness=r,l.update();let c=ou.create({shape:l,parameters:{roundness:r,depth:i,extrudeBevelSize:a,extrudeBevelSegments:s}});return Object.assign(c,{userData:{...t,type:"TriangleGeometry"}})}},PathGeometry:class{static create(t){return this.build(this.normalizeInputs(t))}static normalizeInputs(t,e){let n=Object.assign({},(null==e?void 0:e.parameters)??{width:100,height:100,depth:1,subdivisions:12,roundness:0,extrudeBevelSize:0,extrudeBevelSegments:3},t.parameters),r=Math.abs(n.width),i=Math.abs(n.height??n.width),a=Math.abs(n.depth??0),s=(null==e?void 0:e.shapeData)??hu.create({parameters:Wl}).userData.shape;return{path:t.path??Fl.defaultData(),parameters:Object.assign(n,{width:r,height:i,depth:a,extrusion:{...Lh,...n.extrusion}}),shapeData:s}}static build(t){if(t.path.points.length>=2){let e=new Xu(t);return Object.assign(e,{userData:{...t,type:"PathGeometry"}})}return Object.assign(new e,{userData:{...t,type:"PathGeometry"}})}},VectorGeometry:ou},Ep=t=>zp[t.type].create(t);function Lp(t){return null!==t&&"booleanOp"in t}var Ip=class extends(Fd(Ot)){constructor(){super(...arguments),this.booleanMeshSetAddress=-1,this.booleanWasTransformed=!1,this.booleanMatrixInvOld=new s}updateVisible(){super.updateVisible(),this.visible=!Lp(this.parent)&&this.visible,Lp(this.parent)&&this.parent.invalidateDownstreamBooleanData()}freeBooleanPointer(){-1!==this.booleanMeshSetAddress&&(_p.freeMeshSet(this.booleanMeshSetAddress),this.booleanMeshSetAddress=-1)}invalidateDownstreamBooleanData(t=!1){return t?this.booleanWasTransformed=!0:this.freeBooleanPointer(),Lp(this.parent)?this.parent.invalidateDownstreamBooleanData():this}invalidateUpstreamBooleanData(){this.freeBooleanPointer();for(let t of this.children)t instanceof Ip&&(t.freeBooleanPointer(),Lp(t)&&t.invalidateUpstreamBooleanData())}updateTransformState(t,e){let n=super.updateTransformState(t,e);return n&&Lp(this.parent)&&this.invalidateDownstreamBooleanData(!0),n}onVariableUpdate(t=!1){super.onVariableUpdate(t),Lp(this.parent)&&this.invalidateDownstreamBooleanData(!0)}},Np=new c;function jp(t,e=0,n=t.count,r,i){let a=1/0,s=1/0,o=1/0,l=-1/0,h=-1/0,d=-1/0;for(let c=e;c<n;c++){let e=t.getX(c),n=t.getY(c),r=t.getZ(c);e<a&&(a=e),n<s&&(s=n),r<o&&(o=r),e>l&&(l=e),n>h&&(h=n),r>d&&(d=r)}Np.min.set(a,s,o),Np.max.set(l,h,d),Np.getCenter(r),Np.getSize(i).multiplyScalar(.5)}var Bp=new e,Up=new u,kp=class extends Ip{constructor(t,e){super(Bp,Up),this.super_Entity(t,e)}updateState(t,e){this.updateState_Entity(t,e)}updateEntityBoxSize(t,e){let n=this.geometry.getAttribute("position");void 0!==n?jp(n,this.geometry.drawRange.start,this.geometry.drawRange.count<1/0?this.geometry.drawRange.count:n.count,t,e):super.updateEntityBoxSize(t,e)}},Rp=class{constructor(t){t=t??{},this.name=t.name,this.type=t.type,this.node=t.node,this.size=t.size,this.needsUpdate=t.needsUpdate}get value(){return this.node.value}set value(t){this.node.value=t}},Fp=class{constructor(t){this.hashProperties=void 0,this.isNode=!0,this.shortcuts={},this.uuid=x.generateUUID(),this.type=t,this.name=""}analyze(t,e){e=e??{},t.analyzing=!0,this.build(t.addFlow(e.slot,e.cache,e.context),"v4"),t.clearVertexNodeCode(),t.clearFragmentNodeCode(),t.removeFlow(),t.analyzing=!1}analyzeAndFlow(t,e,n){return n=n??{},this.analyze(t,n),this.flow(t,e,n)}flow(t,e,n){n=n??{},t.addFlow(n.slot,n.cache,n.context);let r={result:this.build(t,e),code:t.clearNodeCode(),extra:t.context.extra};return t.removeFlow(),r}build(t,e,n){e=e??this.getType(t,e);let r=t.getNodeData(n??this);return t.analyzing&&this.appendDepsNode(t,r,e),-1===t.nodes.indexOf(this)&&t.nodes.push(this),void 0!==this.updateFrame&&-1===t.updaters.indexOf(this)&&t.updaters.push(this),this.generate(t,e,n)}updateFrame(t){}generateReadonly(t,e,n,r,i,a){return""}generate(t,e,n,r,i){return""}parse(t,e,n,r){}appendDepsNode(t,e,n){e.deps=(e.deps||0)+1;let r=t.getTypeLength(n);(r>(e.outputMax||0)||this.getType(t,n))&&(e.outputMax=r,e.output=n)}setName(t){this.name=t}getName(){return this.name}getType(t,e){return"sampler2D"===e||"samplerCube"===e?e:this.type}getHash(){let t,e,n="{";for(t in this)e=this[t],e instanceof Fp&&(n+='"'+t+'":'+e.getHash()+",");if(this.hashProperties)for(let r=0;r<this.hashProperties.length;r++)t=this.hashProperties[r],e=this[t],n+='"'+t+'":"'+String(e)+'",';return n+='"id":"'+this.uuid+'"}',n}},Vp=new class{constructor(){this.nodes={},this.keywords={}}add(t){this.nodes[t.name]=t}addKeyword(t,e,n){n=void 0===n||n,this.keywords[t]={callback:e,cache:n}}remove(t){delete this.nodes[t.name]}removeKeyword(t){delete this.keywords[t]}get(t){return this.nodes[t]}getKeyword(t,e){return this.keywords[t].callback(e)}getKeywordData(t){return this.keywords[t]}contains(t){return void 0!==this.nodes[t]}containsKeyword(t){return void 0!==this.keywords[t]}},Gp=class extends Fp{constructor(t,e){super(t),this.scope="",e=e??{},this.shared=void 0===e.shared||e.shared,this.unique=void 0!==e.unique&&e.unique}build(t,e,n,r){if(e=e??this.getType(t),this.getShared(t,e)){let i=this.getUnique(t,e);i&&void 0===this.uuid&&(this.uuid=x.generateUUID()),n=t.getUUID(n??this.getUUID(),!i);let a=t.getNodeData(n),s=a.output||this.getType(t);if(t.analyzing)return(a.deps||0)>0||this.getLabel()?(this.appendDepsNode(t,a,e),this.generate(t,e,n)):super.build(t,e,n);if(i)return a.name=a.name||super.build(t,e,n),a.name;if(!this.getLabel()&&(!this.getShared(t,s)||t.context.ignoreCache||1===a.deps))return super.build(t,e,n);n=this.getUUID(!1);let o=this.getTemp(t,n);if(o)return t.format(o,s,e);{o=super.generate(t,e,n,a.output,r);let i=this.generate(t,s,n);return t.addNodeCode(o+" = "+i+";"),t.format(o,s,e)}}return super.build(t,e,n)}getShared(t,e){return"sampler2D"!==e&&"samplerCube"!==e&&this.shared}getUnique(t,e){return this.unique}setLabel(t){return this.label=t,this}getLabel(){return this.label}getUUID(t){let e=this.uuid;return"string"==typeof this.scope&&(e=this.scope+"-"+e),e}getTemp(t,e){e=e||this.uuid;let n=t.getVars()[e];return n?n.name:void 0}generate(t,e,n,r,i){return this.getShared(t,e)||console.error("TempNode is not shared"),n=n??this.uuid,t.getTempVar(n,r??this.getType(t),i,this.getLabel()).name}},Hp=class extends Gp{constructor(t,e){(e=e??{}).shared=void 0!==e.shared&&e.shared,super(t,e),this.readonly=!1}setReadonly(t){return this.readonly=t,this.hashProperties=this.readonly?["value"]:void 0,this}getReadonly(){return this.readonly}generate(t,e,n,r,i,a){n=t.getUUID(n??this.getUUID()),r=r??this.getType(t);let s=t.getNodeData(n);return this.getReadonly()&&void 0!==this.generateReadonly?this.generateReadonly(t,e,n,r,i,a):t.isShader("vertex")?(s.vertex||(s.vertex=t.createVertexUniform(r,this,i,a,this.getLabel())),t.format(s.vertex.name,r,e)):(s.fragment||(s.fragment=t.createFragmentUniform(r,this,i,a,this.getLabel())),t.format(s.fragment.name,r,e))}},Wp=class extends Hp{constructor(t=0,e){super("v2"),this.nodeType="Vector2",this.value=t instanceof l?t:new l(t,e)}get x(){return this.value.x}set x(t){this.value.x=t}get y(){return this.value.y}set y(t){this.value.y=t}generateReadonly(t,e,n,r,i,a){return t.format("vec2("+this.value.x+", "+this.value.y+")",r,e)}},qp=class extends Hp{constructor(t=0,e,n){super("v3"),this.nodeType="Vector3",this.value=t instanceof o?t:new o(t,e,n)}get x(){return this.value.x}set x(t){this.value.x=t}get y(){return this.value.y}set y(t){this.value.y=t}get z(){return this.value.z}set z(t){this.value.z=t}generateReadonly(t,e,n,r,i,a){return t.format("vec3("+this.value.x+", "+this.value.y+", "+this.value.z+")",r,e)}},$p=class extends _{constructor(t,e,n,r){super(t,e,n),this.isColorA=!0,this.a=r}setRGBA(t,e,n,r){super.setRGB(t,e,n),this.a=r}copy(t){return super.copy(t),this.a="a"in t?t.a:1,this}clone(){return new this.constructor(this.r,this.g,this.b,this.a)}setStyle(t,e="srgb"){let n;if("transparent"===t)return this.setRGBA(0,0,0,0),this;if(n=/^((?:rgb|hsl)a?)\(([^)]*)\)/.exec(t)){let r,i=n[1],a=n[2];switch(i){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.a="rgba"===i?parseFloat(r[4]):1,super.setStyle(t,e);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.a="hsla"===i?parseFloat(r[4]):1,super.setStyle(t,e)}}return super.setStyle(t,e)}get x(){return this.r}get y(){return this.g}get z(){return this.b}get w(){return this.a}set x(t){this.r=t}set y(t){this.g=t}set z(t){this.b=t}set w(t){this.a=t}},Xp=class extends Hp{constructor(t){super("v4"),this.nodeType="Vector4",this.value=t instanceof $p?t:new $p(t.r,t.g,t.b,t.a)}generateReadonly(t,e,n,r,i,a){return t.format("vec4("+this.value.r+", "+this.value.g+", "+this.value.b+", "+this.value.a+")",r,e)}},Yp=/^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,Kp=/[a-z_0-9]+/gi,Zp=class extends Gp{constructor(t,e,n,r,i){super(i),this.src="",this.nodeType="Function",this.useKeywords=!0,this.includes=[],this.extensions={},this.keywords={},this.isMethod=void 0===i,this.isInterface=!1,this.parse(t,e,n,r)}getShared(t,e){return!this.isMethod}getType(t){return t.getTypeByFormat(this.type)}getInputByName(t){if(this.inputs){let e=this.inputs.length;for(;e--;)if(this.inputs[e].name===t)return this.inputs[e]}}getIncludeByName(t){if(this.includes){let e=this.includes.length;for(;e--;)if(this.includes[e].name===t)return this.includes[e]}}generate(t,e,n,r,i){let a,s=0,o=this.src;if(this.includes)for(let h=0;h<this.includes.length;h++)t.include(this.includes[h],this);for(let h in this.extensions)t.extensions[h]=!0;let l=[];for(;a=Kp.exec(this.src);)l.push(a);for(let h=0;h<l.length;h++){let e=l[h],n=e[0],r=!this.isMethod||!this.getInputByName(n),i=n;if(this.keywords[n]||this.useKeywords&&r&&Vp.containsKeyword(n)){let e=this.keywords[n];if(!e){let r=Vp.getKeywordData(n);r.cache&&(e=t.keywords[n]),e=e||Vp.getKeyword(n,t),r.cache&&(t.keywords[n]=e)}i=e.build(t)}n!==i&&"."!==o[e.index+s-1]&&(o=o.substring(0,e.index+s)+i+o.substring(e.index+n.length+s),s+=i.length-n.length),void 0===this.getIncludeByName(i)&&Vp.contains(i)&&t.include(Vp.get(i))}return"source"===e?o:this.isMethod?(this.isInterface||t.include(this,void 0,o),this.name):t.format("( "+o+" )",this.getType(t),e)}parse(t,e,n,r){if(this.src=t||"",this.includes=e??[],this.extensions=n??{},this.keywords=r??{},this.isMethod){let t=Yp.exec(this.src);if(this.inputs=[],t&&4==t.length){this.type=t[1],this.name=t[2];let e=t[3].match(Kp);if(e){let t=0;for(;t<e.length;){let n,r=e[t++];"in"===r||"out"===r||"inout"===r?n=e[t++]:(n=r,r="");let i=e[t++];this.inputs.push({name:i,type:n,qualifier:r})}}this.isInterface=-1===this.src.indexOf("{")}else this.type="",this.name=""}}},Qp=/^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i,Jp=class extends Gp{constructor(t="",e){super(),this.src="",this.useDefine=!1,this.nodeType="Const",this.parse(t||Jp.PI,void 0,void 0,void 0,e)}getType(t){return t.getTypeByFormat(this.type)}parse(t,e,n,r,i){this.src=t||"";let a,s,o="",l=Qp.exec(t);this.useDefine=i??"#"===this.src.charAt(0),l&&l.length>1?(s=l[1],a=l[2],o=l[3]):(a=this.src,s="f"),this.name=a,this.type=s,this.value=o}build(t,e){if("source"===e){if(this.value)return this.useDefine?"#define "+this.name+" "+this.value:"const "+this.type+" "+this.name+" = "+this.value+";";if(this.useDefine)return this.src}return t.include(this),t.format(this.name,this.getType(t),e)}generate(t,e,n,r,i){return t.format(this.name,this.getType(t),e)}},tf=Jp;tf.PI="PI",tf.PI2="PI2",tf.RECIPROCAL_PI="RECIPROCAL_PI",tf.RECIPROCAL_PI2="RECIPROCAL_PI2",tf.LOG2="LOG2",tf.EPSILON="EPSILON";var ef=new RegExp("^structs*([a-z_0-9]+)s*{s*((.|\n)*?)}","gim"),nf=new RegExp("s*(w*?)s*(w*?)(=|;)","gim"),rf=class extends Gp{constructor(t=""){super(),this.inputs=[],this.src="",this.nodeType="Struct",this.parse(t)}getType(t){return t.getTypeByFormat(this.name)}getInputByName(t){let e=this.inputs.length;for(;e--;)if(this.inputs[e].name===t)return this.inputs[e]}generate(t,e,n,r,i){return"source"===e?this.src+";":t.format("( "+this.src+" )",this.getType(t),e)}parse(t=""){this.src=t,this.inputs=[];let e=ef.exec(t);if(e){let t,n=e[2];for(;t=nf.exec(n);)this.inputs.push({type:t[1],name:t[2]});this.name=e[1]}else this.name="";this.type=this.name}},af=class extends Gp{constructor(t){super("v2",{shared:!1}),this.nodeType="UV",this.index=t??0}generate(t,e){t.requires.uv[this.index]=!0;let n=this.index>0?this.index+1:"",r=t.isShader("vertex")?"uv"+n:"vUv"+n;return t.format(r,this.getType(t),e)}};Vp.addKeyword("uv",(function(){return new af})),Vp.addKeyword("uv2",(function(){return new af(1)}));var sf=class extends Gp{constructor(t,e){super("v4"),this.nodeType="ColorSpace",this.input=t,this.method=e??sf.LINEAR_TO_LINEAR,this.hashProperties=["method"]}static getEncodingComponents(t){switch(t){case j:return["Linear"];case N:return["sRGB"];default:return[]}}generate(t,e){var n;let r=this.input.build(t,"v4"),i=this.getType(t),a=sf.Nodes[this.method],s=t.include(a);if(s===sf.LINEAR_TO_LINEAR)return t.format(r,i,e);if(2===(null==(n=a.inputs)?void 0:n.length)){let n=this.factor.build(t,"f");return t.format(s+"( "+r+", "+n+" )",i,e)}return t.format(s+"( "+r+" )",i,e)}fromEncoding(t){let e=sf.getEncodingComponents(t);this.method="LinearTo"+e[0],this.factor=e[1]}fromDecoding(t){let e=sf.getEncodingComponents(t);this.method=e[0]+"ToLinear",this.factor=e[1]}},of=sf;of.Nodes={LinearToLinear:new Zp(["vec4 LinearToLinear( in vec4 value ) {","\treturn value;","}"].join("\n")),sRGBToLinear:new Zp(["vec4 sRGBToLinear( in vec4 value ) {","\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );","}"].join("\n")),LinearTosRGB:new Zp(["vec4 LinearTosRGB( in vec4 value ) {","\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );","}"].join("\n"))},of.LINEAR_TO_LINEAR="LinearToLinear",of.SRGB_TO_LINEAR="sRGBToLinear",of.LINEAR_TO_SRGB="LinearTosRGB";var lf=class extends Zp{constructor(t="",e,n,r,i){super(t,i,r,n,e),this.nodeType="Expression"}},hf=class extends Hp{constructor(t=new A,e,n,r){super("v4",{shared:!0}),this.nodeType="Texture",this.value=t,this.uv=e??new af,this.bias=n,this.project=void 0!==r&&r}getTexture(t,e){return super.generate(t,e,this.value.uuid,"t")}generate(t,e){if("sampler2D"===e)return this.getTexture(t,e);let n,r,i=this.getTexture(t,e),a=this.uv.build(t,this.project?"v4":"v2"),s=this.bias?this.bias.build(t,"f"):void 0;void 0===s&&t.context.bias&&(s=t.context.bias.setTexture(this).build(t,"f")),n=this.project?"texture2DProj":s?"tex2DBias":"tex2D",r=s?n+"( "+i+", "+a+", "+s+" )":n+"( "+i+", "+a+" )";let o={include:t.isShader("vertex"),ignoreCache:!0},l=this.getType(t);return t.addContext(o),this.colorSpace=this.colorSpace??new of(new lf("",l)),this.colorSpace.fromDecoding(t.getTextureEncodingFromMap(this.value)),this.colorSpace.input.parse(r),r=this.colorSpace.build(t,l),t.removeContext(),t.format(r,l,e)}},df=class extends Hp{constructor(t){super("f"),this.nodeType="Float",this.value=t??0}generateReadonly(t,e,n,r,i,a){return t.format(this.value+(this.value%1?"":".0"),r,e)}},cf=class extends Gp{constructor(t,e){super(),this.inputs=[],this.nodeType="FunctionCall",this.value=t,this.inputs=e??[]}getFunction(){return this.value}getType(t){return this.value.getType(t)}generate(t,e,n,r,i){r=this.getType(t);let a=this.value,s=a.build(t,e)+"( ",o=[];if(a.inputs){for(let e=0;e<a.inputs.length;e++){let n=a.inputs[e],r=this.inputs[e]||this.inputs[n.name];o.push(r.build(t,t.getTypeByFormat(n.type)))}s+=o.join(", ")+" )"}return t.format(s,r,e)}},uf=class extends Gp{constructor(t,e,n=uf.ADD){super(),this.nodeType="Operator",this.type=t.type,this.a=t,this.b=e,this.op=n}getType(t){let e=this.a.getType(t),n=this.b.getType(t);return t.isTypeMatrix(e)?"v4":t.getTypeLength(n)>t.getTypeLength(e)?n:e}generate(t,e){let n=this.getType(t);this.type=n;let r=this.a.build(t,n),i=this.b.build(t,n);return t.format("( "+r+" "+this.op+" "+i+" )",n,e)}},pf=uf;pf.ADD="+",pf.SUB="-",pf.MUL="*",pf.DIV="/";var ff=class extends Gp{constructor(t,e=ff.ABS,n,r){super(),this.nodeType="Math",this.a=t,"string"!=typeof e?this.b=e:r=e,"string"!=typeof n?this.c=n:r=n,this.method=r,this.hashProperties=["method"]}getNumInputs(t){switch(this.method){case ff.MIX:case ff.CLAMP:case ff.REFRACT:case ff.SMOOTHSTEP:case ff.FACEFORWARD:return 3;case ff.MIN:case ff.MAX:case ff.MOD:case ff.STEP:case ff.REFLECT:case ff.DISTANCE:case ff.DOT:case ff.CROSS:case ff.POW:return 2;default:return 1}}getInputType(t){let e=t.getTypeLength(this.a.getType(t)),n=this.b?t.getTypeLength(this.b.getType(t)):0,r=this.c?t.getTypeLength(this.c.getType(t)):0;return e>n&&e>r?this.a.getType(t):n>r?this.b.getType(t):this.c.getType(t)}getType(t){switch(this.method){case ff.LENGTH:case ff.DISTANCE:case ff.DOT:return"f";case ff.CROSS:return"v3"}return this.getInputType(t)}generate(t,e){let n,r,i,a=this.a?t.getTypeLength(this.a.getType(t)):0,s=this.b?t.getTypeLength(this.b.getType(t)):0,o=this.c?t.getTypeLength(this.c.getType(t)):0,l=this.getInputType(t),h=this.getType(t);switch(this.type=h,this.method){case ff.NEGATE:return t.format("( -"+this.a.build(t,l)+" )",l,e);case ff.INVERT:return t.format("( 1.0 - "+this.a.build(t,l)+" )",l,e);case ff.CROSS:n=this.a.build(t,"v3"),r=this.b.build(t,"v3");break;case ff.STEP:n=this.a.build(t,1===a?"f":l),r=this.b.build(t,l);break;case ff.MIN:case ff.MAX:case ff.MOD:n=this.a.build(t,l),r=this.b.build(t,1===s?"f":l);break;case ff.REFRACT:n=this.a.build(t,l),r=this.b.build(t,l),i=this.c.build(t,"f");break;case ff.MIX:n=this.a.build(t,l),r=this.b.build(t,l),i=this.c.build(t,1===o?"f":l);break;default:n=this.a.build(t,l),this.b&&(r=this.b.build(t,l)),this.c&&(i=this.c.build(t,l))}let d=[];d.push(n),r&&d.push(r),i&&d.push(i);let c=this.getNumInputs(t);if(d.length!==c)throw Error(`Arguments not match used in "${this.method}". Require ${c}, currently ${d.length}.`);return t.format(this.method+"( "+d.join(", ")+" )",h,e)}},mf=ff;mf.RAD="radians",mf.DEG="degrees",mf.EXP="exp",mf.EXP2="exp2",mf.LOG="log",mf.LOG2="log2",mf.SQRT="sqrt",mf.INV_SQRT="inversesqrt",mf.FLOOR="floor",mf.CEIL="ceil",mf.NORMALIZE="normalize",mf.FRACT="fract",mf.SATURATE="saturate",mf.SIN="sin",mf.COS="cos",mf.TAN="tan",mf.ASIN="asin",mf.ACOS="acos",mf.ARCTAN="atan",mf.ABS="abs",mf.SIGN="sign",mf.LENGTH="length",mf.NEGATE="negate",mf.INVERT="invert",mf.MIN="min",mf.MAX="max",mf.MOD="mod",mf.STEP="step",mf.REFLECT="reflect",mf.DISTANCE="distance",mf.DOT="dot",mf.CROSS="cross",mf.POW="pow",mf.MIX="mix",mf.CLAMP="clamp",mf.REFRACT="refract",mf.SMOOTHSTEP="smoothstep",mf.FACEFORWARD="faceforward";var gf=class extends Gp{constructor(t,e,n){super("v4"),this.nodeType="TextureCubeUV",this.value=t,this.uv=e,this.bias=n}bilinearCubeUV(t,e,n,r){let i=new cf(gf.Nodes.bilinearCubeUV,[e,n,r]);this.colorSpaceTL=this.colorSpaceTL??new of(new lf("","v4")),this.colorSpaceTL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTL.input.parse(i.build(t)+".tl"),this.colorSpaceTR=this.colorSpaceTR??new of(new lf("","v4")),this.colorSpaceTR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTR.input.parse(i.build(t)+".tr"),this.colorSpaceBL=this.colorSpaceBL??new of(new lf("","v4")),this.colorSpaceBL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBL.input.parse(i.build(t)+".bl"),this.colorSpaceBR=this.colorSpaceBR??new of(new lf("","v4")),this.colorSpaceBR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBR.input.parse(i.build(t)+".br");let a={include:t.isShader("vertex"),ignoreCache:!0};t.addContext(a),this.colorSpaceTLExp=new lf(this.colorSpaceTL.build(t,"v4"),"v4"),this.colorSpaceTRExp=new lf(this.colorSpaceTR.build(t,"v4"),"v4"),this.colorSpaceBLExp=new lf(this.colorSpaceBL.build(t,"v4"),"v4"),this.colorSpaceBRExp=new lf(this.colorSpaceBR.build(t,"v4"),"v4"),t.removeContext();let s=new lf("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )","v4");return s.keywords.cubeUV_TL=this.colorSpaceTLExp,s.keywords.cubeUV_TR=this.colorSpaceTRExp,s.keywords.cubeUV_BL=this.colorSpaceBLExp,s.keywords.cubeUV_BR=this.colorSpaceBRExp,s.keywords.cubeUV=i,s}generate(t,e){if(t.isShader("fragment")){let n=this.uv,r=this.bias||t.context.roughness,i=new cf(gf.Nodes.roughnessToMip,[r]),a=new mf(i,gf.Nodes.m0,gf.Nodes.cubeUV_maxMipLevel,mf.CLAMP),s=new mf(a,mf.FLOOR),o=new mf(a,mf.FRACT),l=this.bilinearCubeUV(t,this.value,n,s),h=this.bilinearCubeUV(t,this.value,n,new pf(s,new df(1).setReadonly(!0),pf.ADD)),d=new mf(l,h,o,mf.MIX);return t.format(d.build(t),"v4",e)}return console.warn("TextureCubeUVNode is not compatible with "+t.shader+" shader."),t.format("vec4( 0.0 )",this.getType(t),e)}},vf=gf;vf.Nodes=function(){let t=new rf("struct TextureCubeUVData {\n\t\t\tvec4 tl;\n\t\t\tvec4 tr;\n\t\t\tvec4 br;\n\t\t\tvec4 bl;\n\t\t\tvec2 f;\n\t\t}"),e=new tf("float cubeUV_maxMipLevel 8.0",!0),n=new tf("float cubeUV_minMipLevel 4.0",!0),r=new tf("float cubeUV_maxTileSize 256.0",!0),i=new tf("float cubeUV_minTileSize 16.0",!0),a=new Zp("float getFace(vec3 direction) {\n\t\t\t\tvec3 absDirection = abs(direction);\n\t\t\t\tfloat face = -1.0;\n\t\t\t\tif (absDirection.x > absDirection.z) {\n\t\t\t\t\tif (absDirection.x > absDirection.y)\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (absDirection.z > absDirection.y)\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t}\n\t\t\t\treturn face;\n\t\t}");a.useKeywords=!1;let s=new Zp("vec2 getUV(vec3 direction, float face) {\n\t\t\t\tvec2 uv;\n\t\t\t\tif (face == 0.0) {\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\n\t\t\t\t} else if (face == 1.0) {\n\t\t\t\t\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\n\t\t\t\t} else if (face == 2.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\n\t\t\t\t} else if (face == 3.0) {\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\n\t\t\t\t} else if (face == 4.0) {\n\t\t\t\t\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\n\t\t\t\t} else {\n\t\t\t\t\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\n\t\t\t\t}\n\t\t\t\treturn 0.5 * (uv + 1.0);\n\t\t}");s.useKeywords=!1;let o=new Zp("TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n\t\t\tfloat face = getFace(direction);\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\n\t\t\tfloat faceSize = exp2(mipInt);\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\n\t\t\tvec2 f = fract(uv);\n\t\t\tuv += 0.5 - f;\n\t\t\tif (face > 2.0) {\n\t\t\t\tuv.y += faceSize;\n\t\t\t\tface -= 3.0;\n\t\t\t}\n\t\t\tuv.x += face * faceSize;\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t}\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n\t\t\tuv *= texelSize;\n\t\t\tvec4 tl = texture2D(envMap, uv);\n\t\t\tuv.x += texelSize;\n\t\t\tvec4 tr = texture2D(envMap, uv);\n\t\t\tuv.y += texelSize;\n\t\t\tvec4 br = texture2D(envMap, uv);\n\t\t\tuv.x -= texelSize;\n\t\t\tvec4 bl = texture2D(envMap, uv);\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\n\t\t}",[t,a,s,e,n,r,i]);o.useKeywords=!1;let l=new tf("float r0 1.0",!0),h=new tf("float v0 0.339",!0),d=new tf("float m0 -2.0",!0),c=new tf("float r1 0.8",!0),u=new tf("float v1 0.276",!0),p=new tf("float m1 -1.0",!0),f=new tf("float r4 0.4",!0),m=new tf("float v4 0.046",!0),g=new tf("float m4 2.0",!0),v=new tf("float r5 0.305",!0),y=new tf("float v5 0.016",!0),b=new tf("float m5 3.0",!0),x=new tf("float r6 0.21",!0),w=new tf("float v6 0.0038",!0),_=new tf("float m6 4.0",!0);return{bilinearCubeUV:o,roughnessToMip:new Zp("float roughnessToMip(float roughness) {\n\t\t\tfloat mip = 0.0;\n\t\t\tif (roughness >= r1) {\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n\t\t\t} else if (roughness >= r4) {\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n\t\t\t} else if (roughness >= r5) {\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n\t\t\t} else if (roughness >= r6) {\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n\t\t\t} else {\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n\t\t\t}\n\t\t\treturn mip;\n\t\t}",[l,h,d,c,u,p,f,m,g,v,y,b,x,w,_]),m0:d,cubeUV_maxMipLevel:e}}();var yf=class extends Gp{constructor(t){super("v3"),this.nodeType="Normal",this.scope=t??yf.VIEW}getShared(){return this.scope===yf.WORLD}build(t,e,n,r){let i=t.context[this.scope+"Normal"];return i?i.build(t,e,n,r):super.build(t,e,n)}generate(t,e,n,r,i){let a;switch(this.scope){case yf.VIEW:a=t.isShader("vertex")?"transformedNormal":"geometryNormal";break;case yf.LOCAL:t.isShader("vertex")?a="objectNormal":(t.requires.normal=!0,a="vObjectNormal");break;case yf.WORLD:t.isShader("vertex")?a="inverseTransformDirection( transformedNormal, viewMatrix ).xyz":(t.requires.worldNormal=!0,a="vWNormal")}return t.format(a,this.getType(t),e)}},bf=yf;bf.LOCAL="local",bf.WORLD="world",bf.VIEW="view",bf.NORMAL="normal",Vp.addKeyword("viewNormal",(function(){return new bf(bf.VIEW)})),Vp.addKeyword("localNormal",(function(){return new bf(bf.NORMAL)})),Vp.addKeyword("worldNormal",(function(){return new bf(bf.WORLD)}));var xf=class extends Gp{constructor(t){super("v3"),this.nodeType="Position",this.scope=t??xf.LOCAL}getType(){return this.scope===xf.PROJECTION?"v4":this.type}getShader(){switch(this.scope){case xf.LOCAL:case xf.WORLD:return!1}return!0}generate(t,e,n,r,i){let a;switch(this.scope){case xf.LOCAL:t.isShader("vertex")?a="transformed":(t.requires.position=!0,a="vPosition");break;case xf.WORLD:if(t.isShader("vertex"))return"( modelMatrix * vec4( transformed, 1.0 ) ).xyz";t.requires.worldPosition=!0,a="vWPosition";break;case xf.VIEW:a=t.isShader("vertex")?"-mvPosition.xyz":"vViewPosition";break;case xf.PROJECTION:a=t.isShader("vertex")?"( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )":"vec4( 0.0 )"}return t.format(a,this.getType(),e)}},wf=xf;wf.LOCAL="local",wf.WORLD="world",wf.VIEW="view",wf.PROJECTION="projection",Vp.addKeyword("position",(function(){return new wf})),Vp.addKeyword("worldPosition",(function(){return new wf(wf.WORLD)})),Vp.addKeyword("viewPosition",(function(){return new wf(wf.VIEW)}));var _f=class extends Gp{constructor(t){super("v3"),this.nodeType="Reflect",this.scope=t??_f.CUBE}getUnique(t){return!t.context.viewNormal}getType(){return this.scope===_f.SPHERE?"v2":this.type}generate(t,e){let n=this.getUnique(t);if(t.isShader("fragment")){let r;switch(this.scope){case _f.VECTOR:{let e=new bf(bf.VIEW),i=t.context.roughness,a=e.build(t,"v3"),s=new wf(wf.VIEW).build(t,"v3"),o=i?i.build(t,"f"):void 0,l=`reflect( -normalize( ${s} ), ${a} )`;o&&(l=`normalize( mix( ${l}, ${a}, ${o} * ${o} ) )`);let h=`inverseTransformDirection( ${l}, viewMatrix )`;n?(t.addNodeCode(`vec3 reflectVec = ${h};`),r="reflectVec"):r=h;break}case _f.CUBE:{let e=new _f(_f.VECTOR).build(t,"v3"),i="vec3( -"+e+".x, "+e+".yz )";n?(t.addNodeCode(`vec3 reflectCubeVec = ${i};`),r="reflectCubeVec"):r=i;break}case _f.SPHERE:{let e="normalize( ( viewMatrix * vec4( "+new _f(_f.VECTOR).build(t,"v3")+", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";n?(t.addNodeCode(`vec2 reflectSphereVec = ${e};`),r="reflectSphereVec"):r=e;break}}return t.format(r,this.getType(),e)}return console.warn("ReflectNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.type,e)}},Sf=_f;Sf.CUBE="cube",Sf.SPHERE="sphere",Sf.VECTOR="vector";var Af=class extends Gp{constructor(t=new hf,e,n){super("v4"),this.nodeType="TextureCube",this.value=t,this.radianceNode=new vf(this.value,e??new Sf(Sf.VECTOR),n),this.irradianceNode=new vf(this.value,new bf(bf.WORLD),new df(1).setReadonly(!0))}generate(t,e){return t.isShader("fragment")?(t.require("irradiance"),t.context.bias&&t.context.bias.setTexture(this.value),("irradiance"===t.slot?this.irradianceNode:this.radianceNode).build(t,e)):(console.warn("TextureCubeNode is not compatible with "+t.shader+" shader."),t.format("vec4( 0.0 )",this.getType(t),e))}},Of=class extends Hp{constructor(t=new Z,e,n){super("v4",{shared:!0}),this.nodeType="CubeTexture",this.value=t,this.uv=e??new Sf,this.bias=n}getTexture(t,e){return super.generate(t,e,this.value.uuid,"tc")}generate(t,e){var n;if("samplerCube"===e)return this.getTexture(t,e);let r,i=this.getTexture(t,e),a=null==(n=this.uv)?void 0:n.build(t,"v3"),s=this.bias?this.bias.build(t,"f"):void 0;void 0===s&&t.context.bias&&(s=t.context.bias.setTexture(this).build(t,"f")),r=s?"texCubeBias( "+i+", "+a+", "+s+" )":"texCube( "+i+", "+a+" )";let o={include:t.isShader("vertex"),ignoreCache:!0},l=this.getType(t);return t.addContext(o),this.colorSpace=this.colorSpace??new of(new lf("",l)),this.colorSpace.fromDecoding(t.getTextureEncodingFromMap(this.value)),this.colorSpace.input.parse(r),r=this.colorSpace.build(t,l),t.removeContext(),t.format(r,l,e)}},Mf=["x","y","z","w"],Cf=["float","vec2","vec3","vec4"],Pf={float:"f",vec2:"v2",vec3:"v3",vec4:"v4",mat4:"v4",int:"i",bool:"b","float[]":"f[]","vec4[]":"v4[]"},Df={t:"sampler2D",tc:"samplerCube",b:"bool",i:"int",f:"float",c:"vec3",v2:"vec2",v3:"vec3",v4:"vec4",m3:"mat3",m4:"mat4","f[]":"float[]","v4[]":"vec4[]"},Tf=class extends Hp{constructor(t=0,e,n,r){super("c"),this.nodeType="Color",this.value=t instanceof $p?t:new $p(t||0,e,n,r)}setRGBA(t){this.value.setRGBA(t.r,t.g,t.b,t.a)}generate(t,e,n,r,i,a){n=t.getUUID(n??this.getUUID()),r=r??this.getType(t);let s=t.getNodeData(n),o=this.getReadonly()&&void 0!==this.generateReadonly;if(this.alpha){let e=this.alpha.build(t,"f");t.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${e};`)}return o?this.generateReadonly(t,e,n,r,i,a):t.isShader("vertex")?(s.vertex||(s.vertex=t.createVertexUniform(r,this,i,a,this.getLabel())),t.format(s.vertex.name,r,e)):(s.fragment||(s.fragment=t.createFragmentUniform(r,this,i,a,this.getLabel())),t.format(s.fragment.name,r,e))}generateReadonly(t,e,n,r,i,a){return t.format("vec3("+this.value.r+", "+this.value.g+", "+this.value.b+")",r,e)}},zf=class extends Hp{constructor(t){super("i"),this.nodeType="Int",this.value=Math.floor(t??0)}generateReadonly(t,e,n,r,i,a){return t.format(this.value.toString(),r,e)}},Ef=class extends Hp{constructor(t){super("b"),this.nodeType="Bool",this.value=t??!1}generateReadonly(t,e,n,r){return t.format(this.value?"true":"false",r,e)}},Lf=class extends Hp{constructor(t=1,e){super("f[]"),this.nodeType="FloatArray",this.size=t,this.value=Array.isArray(e)?e:"number"==typeof e?new Array(t).fill(e):new Array(t).fill(0)}},If=class extends Hp{},Nf=class extends If{constructor(t){super("v3"),this.image=t,this._value=new o}get value(){return this._value.x=this.image.isVideo?this.image.img.videoWidth??0:this.image.img.width,this._value.y=this.image.isVideo?this.image.img.videoHeight??0:this.image.img.height,this._value}},jf=class extends If{constructor(t,e){super("t"),this.image=t,this.wrap=e}get value(){return this.image.getTexture(this.wrap)}},Bf=class extends Hp{constructor(t){super("m3"),this.nodeType="Matrix3",this.value=t??new w}generateReadonly(t,e,n,r,i,a){return t.format("mat3("+this.value.elements.join(", ")+")",r,e)}get elements(){return this.value.elements}set elements(t){this.value.fromArray(t)}},Uf=class extends Hp{constructor(t){super("m4"),this.nodeType="Matrix4",this.value=t??new s}generateReadonly(t,e,n,r,i,a){return t.format("mat4("+this.value.elements.join(", ")+")",r,e)}get elements(){return this.value.elements}set elements(t){this.value.fromArray(t)}};function kf(t,e,n){t.setUvTransform(n[0],n[1],e[0],e[1],0,0,0)}var Rf=class extends Bf{constructor(t,e){super(new w),this.repeat=t,this.offset=e,kf(this.value,t,e)}updateMatrix(){kf(this.value,this.repeat,this.offset)}},Ff=class extends Hp{constructor(t=1,e){super("v4[]"),this.nodeType="Vector4Array",this.size=t,this.value=Array.isArray(e)?e:e instanceof p?new Array(t).fill(e):new Array(t).fill(new p(0))}},Vf=class extends Gp{constructor(t,e,n,r){super("v3"),this.nodeType="Blend",this.a=t,this.b=e,this.alpha=n,this.mode=r}generate(t,e){if(t.isShader("fragment")){let n=[];return n.push(this.a.build(t,"c")),n.push(this.b.build(t,"c")),n.push(this.alpha.build(t,"f")),n.push(this.mode.build(t,"i")),t.format("spe_blend("+n.join(",")+")",this.getType(t),e)}return console.warn("BlendNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},Gf=class extends Gp{constructor(t,e){super("v3"),this.nodeType="CustomColor",this.color=t,this.alpha=e,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){if(t.isShader("fragment")){let n=t.include(Gf.Nodes.customColor);t.addFragmentVariable(this.calpha,"float");let r=[];return r.push(this.color.build(t,"v3")),r.push(this.mask?`luminance(${this.mask.build(t,"v3")})`:"1.0"),r.push(this.alpha.build(t,"f")),r.push(this.calpha),t.format(n+"("+r.join(",")+")",this.getType(t),e)}return console.warn("CustomColorNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},Hf=Gf;Hf.Nodes={customColor:new Zp("vec3 customColor(vec3 color, float mask, float alpha, out float calpha) {\n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha;\n\n\t\t\t\treturn color;\n\t\t\t}")};var Wf=class extends Gp{constructor(t,e){super("v3"),this.nodeType="CustomNormal",this.cnormal=t,this.alpha=e,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){if(t.isShader("fragment")){let n=t.include(Wf.Nodes.customNormal);t.addFragmentVariable(this.calpha,"float");let r=[];return r.push(this.cnormal.build(t,"v3")),r.push("normal"),r.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),r.push(this.alpha.build(t,"f")),r.push(this.calpha),t.format(n+"("+r.join(",")+")",this.getType(t),e)}return console.warn("CustomNormalNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},qf=Wf;qf.Nodes={customNormal:new Zp("vec3 customNormal(vec3 cnormal, vec3 norm, float mask, float alpha, out float calpha) {\n\t\t\t\tvec3 normal = packNormalToRGB( norm ).rgb;\n\t\t\t\tnormal *= step( vec3(0.5), cnormal );\n\n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * lalpha;\n\n\t\t\t\treturn normal;\n\t\t\t}")};var $f=class extends Gp{constructor(t,e,n,r,i,a,s,o,l,h,d,c){super("v3"),this.nodeType="CustomTexture",this.texture=t,this.textureSize=e,this.crop=n,this.projection=r,this.axis=i,this.side=a,this.size=s,this.blending=o,this.mat=l,this.isMask=c,this.alpha=h,this.mode=d,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){t.require("position"),t.require("normal"),t.require("uv"),t.requires.uv=[!0],t.extensions.shaderTextureLOD=!0,t.extensions.derivatives=!0;let n,r=`g${this.uuid.toString().replace(/-/g,"")}`;switch(this.projection.value){case 3:n=t.include($f.Nodes.cylindrical);break;case 2:n=t.include($f.Nodes.spherical);break;case 1:let e=["vec3(1.0, 0.0, 0.0)","vec3(0.0, 1.0, 0.0)","vec3(0.0, 0.0, 1.0)"][this.axis.value],i=["zy","xz","xy"][this.axis.value],a=new Zp(`\n\t\tvec3 ${r}_planarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {\n\t\t\t\tvec2 projected = (1. + (position.${i})) / 2.;\n\t\t\t\tvec2 uvs = ( mat * vec3( (projected * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;\n\t\t\t\twriteUv = uvs;\n\n\t\t\t\tvec4 tmp = texture2D( tex, uvs );\n\n\t\t\t\tvec3 col = tmp.rgb;\n\t\t\t\tfloat lalpha = alpha * tmp.a;\n\t\t\t\t${2===this.side.value?"":`lalpha *= step(0.0, ${1===this.side.value?"-1.0 * ":""}dot(vObjectNormal, mat * ${e}));`}\n\n\t\t\t\tif ( crop > 0.5 ) {\n\t\t\t\t\tif ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {\n\t\t\t\t\t\tlalpha = 0.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlalpha *= mask;\n\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\treturn col;\n\t\t\t}`);n=t.include(a);break;case 4:n=t.include($f.Nodes.triplanar);break;default:n=t.include($f.Nodes.uv)}t.addFragmentVariable(this.calpha,"float");let i=[];if(i.push("normal"),i.push(this.texture.generate(t,"t")),i.push(this.textureSize.build(t,"v2")),i.push(this.crop.build(t,"f")),i.push(this.mat.build(t,"mat3")),i.push(this.size.build(t,"v2")),i.push(this.blending.build(t,"f")),i.push(this.isMask.build(t,"b")),i.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),i.push(this.alpha.build(t,"f")),i.push(this.mode.build(t,"i")),i.push(this.calpha),4===this.projection.value){let e=`${r}_writeUvs`,n=e+"0",a=e+"1",s=e+"2",o=`${r}_triplanarWeights`;t.addFragmentVariable(n,"vec2"),t.addFragmentVariable(a,"vec2"),t.addFragmentVariable(s,"vec2"),t.addFragmentVariable(o,"vec3"),i.push(n),i.push(a),i.push(s),i.push(o)}else{let e=`${r}_writeUvs`;t.addFragmentVariable(e,"vec2"),i.push(e)}return t.format(n+"("+i.join(",")+")",this.getType(t),e)}},Xf=$f;Xf.Nodes={cylindrical:new Zp("\nvec3 cylindricalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {\n                vec3 posN = normalize(position);\n                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);\n                float scaledHeight = position.y / (size.y * 0.5);\n                float v =  (scaledHeight / 2.) + .5;\n\n                vec2 calculatedUv = vec2(u,v);\n\t\t\t\tvec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;\n\t\t\t\twriteUv = uvs;\n\n                vec2 df = fwidth(uvs);\n               \tif(df.x > 0.5) df.x = 0.;\n\n\t\t\t\t#ifdef GL_EXT_shader_texture_lod\n                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));\n\t\t\t\t#else\n                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));\n\t\t\t\t#endif\n\n\t\t\t\tvec3 col = tmp.rgb;\n\t\t\t\tfloat lalpha = alpha * tmp.a;\n\t\t\t\tif ( crop > 0.5 ) {\n\t\t\t\t\tif ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {\n\t\t\t\t\t\tlalpha = 0.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlalpha *= mask;\n\t\t\t\t\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\treturn col;\n\t\t\t}\n"),spherical:new Zp("\nvec3 sphericalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {\n                vec3 posN = normalize(vPosition);\n                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);\n                float v = 0.5 + asin(posN.y) / 3.1415;\n\n                vec2 calculatedUv = vec2(u,v);\n\t\t\t\tvec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;\n\t\t\t\twriteUv = uvs;\n\n                vec2 df = fwidth(uvs);\n               \tif(df.x > 0.5) df.x = 0.;\n\t\t\t\t#ifdef GL_EXT_shader_texture_lod\n                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));\n\t\t\t\t#else\n                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));\n\t\t\t\t#endif\n\n\t\t\t\tvec3 col = tmp.rgb;\n\t\t\t\tfloat lalpha = alpha * tmp.a;\n\t\t\t\tif ( crop > 0.5 ) {\n\t\t\t\t\tif ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {\n\t\t\t\t\t\tlalpha = 0.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlalpha *= mask;\n\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\treturn col;\n\t\t\t}\n"),uv:new Zp("vec3 uvTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {\n\t\t\t\tvec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;\n\t\t\t\twriteUv = uvs;\n\n\t\t\t\tvec4 tmp = texture2D( tex, uvs );\n\n\t\t\t\tvec3 col = tmp.rgb;\n\n\t\t\t\tfloat lalpha = alpha * tmp.a;\n\t\t\t\tif ( crop > 0.5 ) {\n\t\t\t\t\tif ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {\n\t\t\t\t\t\tlalpha = 0.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlalpha *= mask;\n\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\treturn col;\n\t\t\t}"),triplanar:new Zp("vec3 triplanarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUvs0, out vec2 writeUvs1, out vec2 writeUvs2, out vec3 writeWeights) {\n\t\t\t\tvec3 p = position;\n\t\t\t\tvec2 uv0 = (1.0 + p.xy) / 2.0;     \n\t\t\t\tvec2 uv1 = (1.0 + p.zy) / 2.0;\t\t\n\t\t\t\tvec2 uv2 = (1.0 + p.xz) / 2.0;\t\t\n\t\n\t\t\t\tuv0 = (mat * vec3((uv0 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;\n\t\t\t\tuv1 = (mat * vec3((uv1 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;\n\t\t\t\tuv2 = (mat * vec3((uv2 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;\n\n\t\t\t\t// Range from 3 to 128 seems to be good\n\t\t\t\tfloat exponent = (1.0 - blending) * 125.0 + 3.0;\n\n\t\t\t\tvec3 n = vObjectNormal;\n\t\t\t\tvec3 weights = abs(normalize(n));\n\t\t\t\tweights = pow(weights, vec3(exponent));\n\t\t\t\tweights /= dot(weights, vec3(1.0));\n\n\t\t\t\t// Write out all sets of UVs that we generated\n\t\t\t\twriteUvs0 = uv0;\n\t\t\t\twriteUvs1 = uv1;\n\t\t\t\twriteUvs2 = uv2;\n\t\t\t\twriteWeights = weights;\n\n\t\t\t\t// Derivatives for LOD\n\t\t\t\tvec2 df0 = fwidth(uv0);\n\t\t\t\tvec2 df1 = fwidth(uv1);\n\t\t\t\tvec2 df2 = fwidth(uv2);\n\t\t\t\tif (df0.x > 0.5) df0.x = 0.0;\n\t\t\t\tif (df1.x > 0.5) df1.x = 0.0;\n\t\t\t\tif (df2.x > 0.5) df2.x = 0.0;\n\n\t\t\t\t#ifdef GL_EXT_shader_texture_lod\n                \tvec4 tmp = \n\t\t\t\t\t\ttexture2DLodEXT(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + \n\t\t\t\t\t\ttexture2DLodEXT(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + \n\t\t\t\t\t\ttexture2DLodEXT(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;\n\t\t\t\t#else\n                \tvec4 tmp = \n\t\t\t\t\t\ttextureLod(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + \n\t\t\t\t\t\ttextureLod(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + \n\t\t\t\t\t\ttextureLod(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;\n\t\t\t\t#endif\n\n\t\t\t\tvec3 col = tmp.rgb;\n\t\t\t\tfloat lalpha = alpha * tmp.a;\n\n\t\t\t\t// Apply cropping across all 3 planes\n\t\t\t\tif ( crop > 0.5 ) {\n\t\t\t\t\tif ( uv0.x < 0.0 || uv0.x > 1.0 || uv0.y < 0.0 || uv0.y > 1.0 )  {\n\t\t\t\t\t\tlalpha = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tif ( uv1.x < 0.0 || uv1.x > 1.0 || uv1.y < 0.0 || uv1.y > 1.0 )  {\n\t\t\t\t\t\tlalpha = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tif ( uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0 )  {\n\t\t\t\t\t\tlalpha = 0.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlalpha *= mask;\n\t\t\t\tcalpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\treturn col;//n * 0.5 + 0.5;\n\t\t\t}\t\t\t\n\t\t\t")};var Yf=class extends Gp{constructor(t,e,n,r,i,a,s,o,l,h,d,c){super("v3"),this.nodeType="Depth",this.gradientType=t,this.smooth=e,this.near=n,this.far=r,this.isVector=i,this.isWorldSpace=a,this.origin=s,this.direction=o,this.colors=l,this.steps=h,this.isMask=c,this.alpha=d,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){let n=`g${this.uuid.toString().replace(/-/g,"")}`,r=new Zp(`vec3 ${n}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${n}_MAX_COLORS], float steps[${n}_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {\n               vec4 color = colors[0];\n               #ifdef ${n}_IS_VECTOR\n                   #ifdef ${n}_LINEAR\n                       #ifdef ${n}_WORLDSPACE\n                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);\n                       #else\n                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);\n                       #endif\n                   #else\n                       #ifdef ${n}_WORLDSPACE\n                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);\n                       #else\n                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);\n                       #endif\n                   #endif\n               #else\n                   float dist = length(vWPosition - cameraPosition);\n\t\t\t       float depth = ( dist - near ) / ( far - near );\n               #endif\n\n\n              float p;\n              #ifdef ${n}_SMOOTH\n\t\t\t\tfor ( int i = 1; i < ${n}_MAX_COLORS; i++ ) {\n\t\t\t\t\t\tp = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n              #else\n                for ( int i = 1; i < ${n}_MAX_COLORS; i++ ) {\n                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);\n                   color = mix(color, colors[i], p);\n                 }\n              #endif\n\n               float lalpha = alpha * color.a * mask;\n               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t   \n               return color.rgb;\n\t\t\t}`,[Yf.Nodes.vectorLinearWorldSpaceDepth,Yf.Nodes.vectorLinearObjectSpaceDepth,Yf.Nodes.vectorSphericalObjectSpaceDepth,Yf.Nodes.vectorSphericalWorldSpaceDepth]);if(t.isShader("fragment")){t.define(`${n}_MAX_COLORS`,this.colors.value.length),this.smooth.value&&t.define(`${n}_SMOOTH`),this.isVector.value>.5&&t.define(`${n}_IS_VECTOR`),0===this.gradientType.value&&t.define(`${n}_LINEAR`),this.isWorldSpace.value>.5&&t.define(`${n}_WORLDSPACE`),t.require("worldPosition"),t.addFragmentVariable(this.calpha,"float");let i=t.include(r),a=[];return a.push(this.near.build(t,"f")),a.push(this.far.build(t,"f")),a.push(this.origin.build(t,"v3")),a.push(this.direction.build(t,"v3")),a.push(this.colors.build(t,"v4[]")),a.push(this.steps.build(t,"f[]")),a.push(this.isMask.build(t,"b")),a.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),a.push(this.alpha.build(t,"f")),a.push(this.calpha),t.format(i+"("+a.join(",")+")",this.getType(t),e)}return console.warn("DepthNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},Kf=Yf;Kf.Nodes={vectorLinearWorldSpaceDepth:new Zp("float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }"),vectorLinearObjectSpaceDepth:new Zp("float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {\n               vec3 n = normalize(direction);\n               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));\n               return ( dist - near ) / ( far - near );\n            }"),vectorSphericalWorldSpaceDepth:new Zp("float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(vWPosition - origin);\n               return ( dist - near ) / ( far - near );\n            }"),vectorSphericalObjectSpaceDepth:new Zp("float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {\n               float dist = length(position - origin);\n               return ( dist - near ) / ( far - near );\n            }")};var Zf=class extends Gp{constructor(t,e,n,r,i,a,s,o){super("v3"),this.nodeType="Fresnel",this.color=t,this.bias=e,this.scale=n,this.intensity=r,this.factor=i,this.isMask=o,this.alpha=a,this.mode=s,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){if(t.require("vWorldViewDir"),t.require("worldNormal"),t.isShader("fragment")){t.addFragmentVariable(this.calpha,"float");let n=new Zp("vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tfloat fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );\n\n\t\t\t\t\tfloat lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn color;\n\t\t\t\t}"),r=t.include(n),i=[];return i.push(this.color.build(t,"c")),i.push(this.bias.build(t,"f")),i.push(this.scale.build(t,"f")),i.push(this.intensity.build(t,"f")),i.push(this.factor.build(t,"f")),i.push(this.isMask.build(t,"b")),i.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),i.push(this.alpha.build(t,"f")),i.push(this.mode.build(t,"i")),i.push(this.calpha),t.format(r+"("+i.join(",")+")",this.getType(t),e)}return console.warn("FresnelNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},Qf=class extends Gp{constructor(t,e,n,r,i,a,s,o,l){super("v3"),this.nodeType="Gradient",this.gradientType=t,this.smooth=e,this.colors=n,this.steps=r,this.offset=i,this.morph=a,this.angle=s,this.isMask=l,this.alpha=o,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){if(t.isShader("fragment")){t.define("GRAD_MAX",10),t.require("uv"),t.requires.uv=[!0],t.addFragmentVariable(this.calpha,"float");let n=t.include(Qf.Nodes.gradient),r=[];return r.push(this.gradientType.build(t,"i")),r.push(this.smooth.build(t,"b")),r.push(this.colors.build(t,"v4[]")),r.push(this.steps.build(t,"f[]")),r.push(this.offset.build(t,"v2")),r.push(this.morph.build(t,"v2")),r.push(this.angle.build(t,"f")),r.push(this.isMask.build(t,"b")),r.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),r.push(this.alpha.build(t,"f")),r.push(this.calpha),t.format(n+"("+r.join(",")+")",this.getType(t),e)}return console.warn("GradientNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},Jf=Qf;Jf.Nodes={gradient:new Zp("vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, bool isMask, float mask, float alpha, out float calpha) {\n\t\t\t\tvec4 color = colors[0];\n\t\t\t\tvec2 m = morph / vUv.xy;\n\t\t\t\tvec2 rot = vec2( 0.5 + m.x, m.y );\n\t\t\t\tvec2 dt = vec2(\n\t\t\t\t\tcos( angle ) * rot.x - sin( angle ) * rot.y,\n\t\t\t\t\tsin( angle ) * rot.x + cos( angle ) * rot.y\n\t\t\t\t);\n\t\t\t\tvec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;\n\t\t\t\tfloat t = dot( pt, dt ) / dot( dt, dt );\n\t\t\t\tif ( gradientType == 1 ) {\n\t\t\t\t\tt = distance (\n\t\t\t\t\t\t( vUv + morph ) * 3.0,\n\t\t\t\t\t\t( vUv + offset ) + 1.0\n\t\t\t\t\t) + angle;\n\t\t\t\t} else if ( gradientType == 2 ) {\n\t\t\t\t\tfloat polar = atan(\n\t\t\t\t\t\tvUv.x + morph.x - 0.5 + offset.x,\n\t\t\t\t\t\tvUv.y + morph.y - 0.5 + offset.y\n\t\t\t\t\t) * -1.0;\n\t\t\t\t\tt = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );\n\t\t\t\t}\n\n\t\t\t\tfloat p;\n\t\t\t\tif (smoothed) {\n\t\t\t\t\tfor ( int i = 1; i < GRAD_MAX; i++ ) {\n\t\t\t\t\t\tp = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tfor ( int i = 1; i < GRAD_MAX; i++ ) {\n\t\t\t\t\t\tp = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );\n\t\t\t\t\t\tcolor = mix(color, colors[i], p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfloat lalpha = alpha * color.a * mask;\n\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t\t\n\t\t\t\treturn color.xyz;\n\t\t\t}")};var tm=class extends Gp{constructor(t,e,n,r){super("v3"),this.nodeType="Matcap",this.texture=t,this.isMask=r,this.alpha=e,this.mode=n,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){if(t.isShader("fragment")){t.addFragmentVariable(this.calpha,"float");let n=t.include(tm.Nodes.matcap);t.require("normal"),t.requires.normal=!0;let r=[];return r.push(this.texture.generate(t,"t")),r.push("normal"),r.push(this.isMask.build(t,"b")),r.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),r.push(this.alpha.build(t,"f")),r.push(this.mode.build(t,"i")),r.push(this.calpha),t.format(n+"("+r.join(",")+")",this.getType(t),e)}return console.warn("MatcapNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},em=tm;em.Nodes={matcap:new Zp("vec3 matcap(sampler2D matcapTex, vec3 normal, bool isMask, float mask, float alpha, int mode, out float calpha) {\n\t\t\t\t\tvec3 viewDir = normalize( vViewPosition );\n\t\t\t\t\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\t\t\t\t\tvec3 y = cross( viewDir, x );\n\t\t\t\t\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\t\t\t\t\tvec4 matcapColor = texture2D( matcapTex, uv );\n\n\t\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\t\t\t\t\t\n\t\t\t\t\treturn matcapColor.rgb;\n            \t}")};var nm,rm=((nm=rm||{}).SIMPLEX="simplex3d",nm.SIMPLEX_FRACTAL="simplex3dFractal",nm.ASHIMA="simplexAshima",nm.FBM="fbm",nm.PERLIN="perlin",nm.VORONOI="voronoi",nm),im=function(){let t=new Zp("vec3 random3(vec3 c) {\n\t\t\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\t\t\tvec3 r;\n\t\t\tr.z = fract(512.0*j);\n\t\t\tj *= .125;\n\t\t\tr.x = fract(512.0*j);\n\t\t\tj *= .125;\n\t\t\tr.y = fract(512.0*j);\n\t\t\treturn r-0.5;\n\t\t}"),e=new Zp("float simplex3d(vec3 p) {\n\t\t\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t\t\t vec3 x = p - s + dot(s, vec3(G3));\n\t\t\t \n\t\t\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t\t\t vec3 i1 = e*(1.0 - e.zxy);\n\t\t\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t\t\t\t\n\t\t\t vec3 x1 = x - i1 + G3;\n\t\t\t vec3 x2 = x - i2 + 2.0*G3;\n\t\t\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t\t\t \n\t\t\t vec4 w, d;\n\t\t\t \n\t\t\t w.x = dot(x, x);\n\t\t\t w.y = dot(x1, x1);\n\t\t\t w.z = dot(x2, x2);\n\t\t\t w.w = dot(x3, x3);\n\t\t\t \n\t\t\t w = max(0.6 - w, 0.0);\n\t\t\t \n\t\t\t d.x = dot(random3(s), x);\n\t\t\t d.y = dot(random3(s + i1), x1);\n\t\t\t d.z = dot(random3(s + i2), x2);\n\t\t\t d.w = dot(random3(s + 1.0), x3);\n\t\t\t \n\t\t\t w *= w;\n\t\t\t w *= w;\n\t\t\t d *= w;\n\t\t\t \n\t\t\t return dot(d, vec4(52.0));\n\t\t}",[t]);e.keywords.F3=new tf("float F3 0.3333333"),e.keywords.G3=new tf("float G3 0.1666667");let n=new Zp("float simplex3dFractal(vec3 m) {\n\t\t\tmat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\n\t\t\tmat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\n\t\t\tmat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\t\t\treturn 0.5333333 * simplex3d(m * rot1)\n\t\t\t\t + 0.2666667 * simplex3d(2.0 * m * rot2)\n\t\t\t\t + 0.1333333 * simplex3d(4.0 * m * rot3)\n\t\t\t\t + 0.0666667 * simplex3d(8.0 * m);\n\t\t}",[e]),r=new Zp("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"),i=new Zp("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"),a=new Zp("float simplexAshima(vec3 v) {\n\t\t  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\t\t  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\t\t  vec3 i  = floor(v + dot(v, C.yyy) );\n\t\t  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\t\t  vec3 g = step(x0.yzx, x0.xyz);\n\t\t  vec3 l = 1.0 - g;\n\t\t  vec3 i1 = min( g.xyz, l.zxy );\n\t\t  vec3 i2 = max( g.xyz, l.zxy );\n\t\t  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n\t\t  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n\t\t  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\t\t  i = mod(i, 289.0 ); \n\t\t  vec4 p = permute( permute( permute( \n\t\t\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t\t   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\t\t\t\t   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t\t  float n_ = 1.0/7.0; // N=7\n\t\t  vec3  ns = n_ * D.wyz - D.xzx;\n\t\t  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\t\t  vec4 x_ = floor(j * ns.z);\n\t\t  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\t\t  vec4 x = x_ *ns.x + ns.yyyy;\n\t\t  vec4 y = y_ *ns.x + ns.yyyy;\n\t\t  vec4 h = 1.0 - abs(x) - abs(y);\n\t\t  vec4 b0 = vec4( x.xy, y.xy );\n\t\t  vec4 b1 = vec4( x.zw, y.zw );\n\t\t  vec4 s0 = floor(b0)*2.0 + 1.0;\n\t\t  vec4 s1 = floor(b1)*2.0 + 1.0;\n\t\t  vec4 sh = -step(h, vec4(0.0));\n\t\t  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\t\t  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\t\t  vec3 p0 = vec3(a0.xy,h.x);\n\t\t  vec3 p1 = vec3(a0.zw,h.y);\n\t\t  vec3 p2 = vec3(a1.xy,h.z);\n\t\t  vec3 p3 = vec3(a1.zw,h.w);\n\t\t  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\t\t  p0 *= norm.x;\n\t\t  p1 *= norm.y;\n\t\t  p2 *= norm.z;\n\t\t  p3 *= norm.w;\n\t\t  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\t\t  m = m * m;\n\t\t  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n\t\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n\t\t}",[r,i]),s=new Zp("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"),o=new Zp("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}",[s]),l=new Zp("float noise(vec3 p){\n\t\t\tvec3 a = floor(p);\n\t\t\tvec3 d = p - a;\n\t\t\td = d * d * (3.0 - 2.0 * d);\n\t\t\tvec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n\t\t\tvec4 k1 = perm(b.xyxy);\n\t\t\tvec4 k2 = perm(k1.xyxy + b.zzww);\n\t\t\tvec4 c = k2 + a.zzzz;\n\t\t\tvec4 k3 = perm(c);\n\t\t\tvec4 k4 = perm(c + 1.0);\n\t\t\tvec4 o1 = fract(k3 * (1.0 / 41.0));\n\t\t\tvec4 o2 = fract(k4 * (1.0 / 41.0));\n\t\t\tvec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n\t\t\tvec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\t\t\treturn o4.y * d.y + o4.x * (1.0 - d.y);\n\t\t}",[o]),h=new Zp("float fbm(vec3 x) {\n\t\t\tfloat v = 0.0;\n\t\t\tfloat a = 0.5;\n\t\t\tvec3 shift = vec3(100);\n\t\t\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\t\t\tv += a * noise(x);\n\t\t\t\tx = x * 2.0 + shift;\n\t\t\t\ta *= 0.5;\n\t\t\t}\n\t\t\treturn v;\n\t\t}",[l]);h.keywords.NUM_OCTAVES=new tf("int NUM_OCTAVES 5");let d=new Zp("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"),c=new Zp("float perlin(vec3 P){\n\t\t  vec3 Pi0 = floor(P);\n\t\t  vec3 Pi1 = Pi0 + vec3(1.0);\n\t\t  Pi0 = mod(Pi0, 289.0);\n\t\t  Pi1 = mod(Pi1, 289.0);\n\t\t  vec3 Pf0 = fract(P);\n\t\t  vec3 Pf1 = Pf0 - vec3(1.0);\n\t\t  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\t\t  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n\t\t  vec4 iz0 = Pi0.zzzz;\n\t\t  vec4 iz1 = Pi1.zzzz;\n\t\t  vec4 ixy = permute(permute(ix) + iy);\n\t\t  vec4 ixy0 = permute(ixy + iz0);\n\t\t  vec4 ixy1 = permute(ixy + iz1);\n\t\t  vec4 gx0 = ixy0 / 7.0;\n\t\t  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n\t\t  gx0 = fract(gx0);\n\t\t  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\t\t  vec4 sz0 = step(gz0, vec4(0.0));\n\t\t  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\t\t  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\t\t  vec4 gx1 = ixy1 / 7.0;\n\t\t  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n\t\t  gx1 = fract(gx1);\n\t\t  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\t\t  vec4 sz1 = step(gz1, vec4(0.0));\n\t\t  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n\t\t  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\t\t  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n\t\t  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n\t\t  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n\t\t  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n\t\t  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n\t\t  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n\t\t  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n\t\t  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\t\t  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n\t\t  g000 *= norm0.x;\n\t\t  g010 *= norm0.y;\n\t\t  g100 *= norm0.z;\n\t\t  g110 *= norm0.w;\n\t\t  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n\t\t  g001 *= norm1.x;\n\t\t  g011 *= norm1.y;\n\t\t  g101 *= norm1.z;\n\t\t  g111 *= norm1.w;\n\t\t  float n000 = dot(g000, Pf0);\n\t\t  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n\t\t  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n\t\t  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n\t\t  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n\t\t  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n\t\t  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n\t\t  float n111 = dot(g111, Pf1);\n\t\t  vec3 fade_xyz = fade(Pf0);\n\t\t  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n\t\t  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n\t\t  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n\t\t  return 2.2 * n_xyz;\n\t\t}",[r,i,d]),u=new Zp("float hashwithoutsine13(vec3 p3)\n\t\t{\n\t\t\tp3  = fract(p3 * .1031);\n\t\t\tp3 += dot(p3, p3.yzx + 33.33);\n\t\t\treturn fract((p3.x + p3.y) * p3.z);\n\t\t}"),p=new Zp("vec3 hashwithoutsine33(vec3 p3)\n\t\t{\n\t\t\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\t\t\tp3 += dot(p3, p3.yxz+33.33);\n\t\t\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n\t\t}"),f=new Zp("float metric(in vec3 p)\n\t\t{\n\t\t\t// L2 \n\t\t\treturn length(p);\n\n\t\t\t// Chebyshev \n\t\t\t// vec3 a = abs(p);\n\t\t\t// return max(a.x, max(a.y, a.z));\n\t\t}"),m=new Zp("float smin( float a, float b, float k )\n\t\t{\n\t\t\tfloat h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (b - a) / k);\n\t\t\tfloat correction = k * h * (1.0 - h);\n\t\t\treturn mix(b, a, h) - correction;\n\t\t}"),g=new Zp("float smax( float a, float b, float k )\n\t\t{\n\t\t\tfloat h = smoothstep(1.0, 0.0, 0.5 + 0.5 * (a - b) / k);\n\t\t\tfloat correction = k * h * (1.0 - h);\n\t\t\treturn mix(a, b, h) + correction;\n\t\t}"),v=new Zp("float remap(float value, float input_min, float input_max, float output_min, float output_max) {\n\t\t\t// Compute width of each interval\n\t\t\tfloat input_width = input_max - input_min;\n\t\t\tfloat output_width = output_max - output_min;\n\t\t\n\t\t\t// Convert input range into a 0-1 range \n\t\t\tfloat scaled = (value - input_min) / input_width;\n\t\t\n\t\t\t// Convert the 0-1 range into a value in output range\n\t\t\treturn output_min + (scaled * output_width);\n\t\t}");return{simplex:e,simplexFractal:n,simplexAshima:a,fbm:h,perlin:c,voronoi:new Zp('float voronoi(in vec3 x, in int style, in float smoothness, in float seed, in int quality) \n\t\t{\n\t\t\t// Integer and fractional parts of this point\'s coordinates\n\t\t\tivec3 p = ivec3(floor(x));\n\t\t\tvec3 f = fract(x);\n\n\t\t\t// Different variables that we will use to construct noise:\n\t\t\t//\n\t\t\t// f1: distance to the closest feature point\n\t\t\t// f2: distance to the second closest feature point\n\t\t\t// e: distance to the closest edge (cell boundary)\n\t\t\t//\n\t\t\t// We also compute "smooth" versions of all of the above quantites, essentially\n\t\t\t// replacing "hard" minimums with "smooth" minimums (described by IQ)\n\t\t\tfloat f1_smooth = 8.0;\n\t\t\tfloat f1 = 8.0;\n\t\t\tfloat f2_smooth = 8.0;\n\t\t\tfloat f2 = 8.0;\n\t\t\tfloat e_smooth = 8.0;\n\t\t\tfloat e = 8.0;\n\n\t\t\t// Variables stored from closest cell\n\t\t\tivec3 mb;\n\t\t\tvec3 mr; \n\n\t\t\tint steps = quality;\n\t\t\t\n\t\t\tfor (int x = -steps; x <= steps; x++) \n\t\t\tfor (int y = -steps; y <= steps; y++)\n\t\t\tfor (int z = -steps; z <= steps; z++)\n\t\t\t{\n\t\t\t\tivec3 b = ivec3(x, y, z);\n\t\t\t\tvec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;\n\t\t\t\tfloat d = length(r);\n\t\t\t\t\n\t\t\t\tf1_smooth = smin(d, f1_smooth, smoothness);\n\n\t\t\t\t// Store un-smoothed distances too \n\t\t\t\tif (d < f1) \n\t\t\t\t{\n\t\t\t\t\tf2 = f1;\n\t\t\t\t\tf1 = d;\n\n\t\t\t\t\tmb = ivec3(x, y, z);\n\t\t\t\t\tmr = r;\n\t\t\t\t} \n\t\t\t\telse if (d < f2) \n\t\t\t\t{\n\t\t\t\t\tf2 = d;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\t\n\t\t\tfloat id = hashwithoutsine13(vec3(p + mb) + seed);\n\n\t\t\t// Second pass for edge distance  \n\t\t\tfor (int x = -steps; x <= steps; x++) \n\t\t\tfor (int y = -steps; y <= steps; y++)\n\t\t\tfor (int z = -steps; z <= steps; z++)\n\t\t\t{\n\t\t\t\t// Start search at the cell that contains the closest point to "x" (found in 1st pass)\n\t\t\t\tivec3 b = mb + ivec3(x, y, z);\n\t\t\t\tvec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;\n\t\t\t\tfloat d1 = dot(0.5 * (mr + r), (r - mr)); \t\t\t\t// IQ normalizes "r - mr" but that breaks things for the smooth version?\n\t\t\t\tfloat d2 = dot(0.5 * (mr + r), normalize(r - mr));\n\n\t\t\t\te_smooth = smin(d1, e_smooth, smoothness);\n\n\t\t\t\te = min(e, d2);\n\n\t\t\t\t// Also compute a smooth version of F2 in this pass\n\t\t\t\t{\n\t\t\t\t\tivec3 b = ivec3(x, y, z);\n\t\t\t\t\tif (b != mb) \n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;\n\t\t\t\t\t\tfloat d = length(r);\n\n\t\t\t\t\t\tf2_smooth = smin(d, f2_smooth, smoothness);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Different visualization modes \n\t\t\tif (style == 0) \n\t\t\t{\n\t\t\t\treturn f1_smooth;\n\t\t\t}\n\t\t\tif (style == 1) \n\t\t\t{\n\t\t\t\treturn f2_smooth;\n\t\t\t}\n\t\t\tif (style == 2) \n\t\t\t{\n\t\t\t\treturn f2_smooth - f1_smooth;\n\t\t\t\t\n\t\t\t\t// "Pebbles" also cool\n\t\t\t\t//return step(0.2, f2_smooth - f1_smooth);\n\t\t\t}\n\t\t\tif (style == 3) \n\t\t\t{\n\t\t\t\t// This one is really good for rock / stone effects\n\t\t\t\tfloat a = f1; \n\t\t\t\tfloat b = f2;\n\t\t\t\tfloat k = 3.0;\n\t\t\t\tfloat h = max(k - abs(a - b), 0.0) / k;\n\t\t\t\tfloat final = min(a, b) - h * h * k * (1.0 / 4.0);\n\t\t\t\treturn final;\n\t\t\t}\n\t\t\tif (style == 4) \n\t\t\t{\n\t\t\t\t// Some random adjustments to make this style stand out more \n\t\t\t\treturn exp(5.0 * e_smooth);\n\t\t\t}\n\t\t\tif (style == 5) \n\t\t\t{\n\t\t\t\treturn pow(f1_smooth, 3.0);\n\t\t\t}\n\t\t\tif (style == 6) \n\t\t\t{\t\t\t\t\n\t\t\t\tconst float eps = 0.0125;\n\n\t\t\t\t// Thicker lines as the user increases the smoothness slider\n\t\t\t\tfloat thickness = smoothness * 0.25 + eps;\n\n\t\t\t\t// Blurrier lines as the user increases the smoothness slider\n\t\t\t\tfloat blur = pow(smoothness, 3.0) * 0.25 + eps;\n\n\t\t\t\treturn smoothstep(\n\t\t\t\t\tthickness - thickness * blur, \n\t\t\t\t\tthickness + thickness * blur, \n\t\t\t\t\te\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (style == 7) \n\t\t\t{\n\t\t\t\treturn hashwithoutsine13(vec3(p + mb) + seed);\n\t\t\t}\n\t\t}\n\t',[u,p,f,m,g,v])}}(),am=class extends Gp{constructor(t,e,n,r,i,a,s,o,l,h,d,c,u,p,f,m,g,v,y){super("v3"),this.nodeType="Noise",this.scale=t,this.size=e,this.move=n,this.fA=r,this.fB=i,this.distortion=a,this.colorA=s,this.colorB=o,this.colorC=l,this.colorD=h,this.noiseType=c,this.voronoiStyle=p,this.highCut=f,this.lowCut=m,this.smoothness=g,this.seed=v,this.quality=y,this.isMask=u,this.alpha=d,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e,n,r,i){t.require("uv"),t.requires.uv=[!0],t.addFragmentVariable(this.calpha,"float");let a=Object.values(rm)[this.noiseType.value],s=new Zp(`vec3 ${a}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, int voronoiStyle, float highCut, float lowCut, float smoothness, float seed, int quality, bool isMask, float mask, float alpha, out float calpha) \n\t\t\t{\n                // Prevent scale of zero \n\t\t\t\tscale = max(abs(scale), 0.001);\n\n\t\t\t\tvec3 st = position / size;\n\t\t\t\tst /= scale;\n\n\t\t\t\t${"voronoi"==a?`\n\t\tfloat v = ${a}(st + move, voronoiStyle, smoothness, seed, quality);\n\n\t\t// Apply clipping to colors\n\t\tv = remap(v, lowCut, highCut, 0.0, 1.0);\n\t\tv = smax(v, 0.0, smoothness * 0.25);\n\t\tv = smin(v, 1.0, smoothness * 0.25);\n\n\t\t// Note that the voronoi mode only uses colors "A" and "C" from the UI \n\t\tvec4 color = mix(colorA, colorC, v); \n\t\t`:`\n\t\tvec3 q = vec3(${a}(st),\n\t\t\t\t\t   ${a}(st + vec3(1.0)),\n\t\t\t\t\t   ${a}(st + vec3(1.0)));\n\t\tvec3 r = vec3(${a}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),\n\t\t\t\t\t  ${a}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), \n\t\t\t\t\t  ${a}(st * q));\n\t\tfloat f = ${a}(st + r);\n\t\tvec4 color;\n\t\tcolor = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));\n\t\tcolor = mix(color, colorC, clamp(length(q), 0.0, 1.0));\n\t\tcolor = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));\n\t\t`}\n\n\t\t\t\tfloat lalpha = alpha * color.a * mask;\n\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\treturn clamp(color, 0.0, 1.0).rgb;\n\t\t\t}`,[im.simplex,im.simplexFractal,im.simplexAshima,im.fbm,im.perlin,im.voronoi]),o=t.include(s),l=[];return l.push(this.scale.build(t,"f")),l.push(this.size.build(t,"v3")),l.push(this.move.build(t,"f")),l.push(this.fA.build(t,"v2")),l.push(this.fB.build(t,"v2")),l.push(this.distortion.build(t,"v2")),l.push(this.colorA.build(t,"v4")),l.push(this.colorB.build(t,"v4")),l.push(this.colorC.build(t,"v4")),l.push(this.colorD.build(t,"v4")),l.push(this.voronoiStyle.build(t,"i")),l.push(this.highCut.build(t,"f")),l.push(this.lowCut.build(t,"f")),l.push(this.smoothness.build(t,"f")),l.push(this.seed.build(t,"f")),l.push(this.quality.build(t,"i")),l.push(this.isMask.build(t,"b")),l.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),l.push(this.alpha.build(t,"f")),l.push(this.calpha),t.format(o+"("+l.join(",")+")",this.getType(t),e)}};am.numOctaves=5;var sm=class extends Gp{constructor(t,e,n,r,i,a,s,o,l,h,d,c,u,p,f,m){super("v3"),this.nodeType="Outline",this.firstTime=!0,this.outlineColor=t,this.contourColor=e,this.outlineWidth=n,this.contourWidth=r,this.contourThreshold=i,this.outlineThreshold=a,this.contourFrequency=s,this.outlineSmoothing=o,this.contourDirection=l,this.positionalLines=h,this.compensation=d,this.resolution=c,this.normalMap=u,this.depthMap=p,this.pixelRatio=f,this.alpha=m,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){let n=`g${this.uuid.toString().replace(/-/g,"")}`;if(t.require("vWorldViewDir"),t.require("worldNormal"),t.extensions.derivatives=!0,this.compensation.value&&t.define("OUTLINE_COMPENSATION",`${n}_offset`),this.firstTime){let e=this.outlineWidth.build(t,"f"),r=this.resolution.build(t,"v2"),i=this.compensation.build(t,"b"),a=this.pixelRatio.build(t,"f");t.addVertexParsVariable("randomColor","attribute vec3"),t.addVertexParsVariable("extrudeNormal","attribute vec3"),t.addVertexParsVariable(e,"uniform float"),t.addVertexParsVariable(r,"uniform vec2"),t.addVertexParsVariable(i,"uniform bool"),t.addVertexParsVariable(a,"uniform float"),t.addVertexParsVariable("vID","flat out float"),t.addFragmentParsVariable("vID","flat in float"),t.addVertexFinalCode(`\n                vID = randomColor.r;\n                vec2 ${n}_offset = vec2(0.0);\n                if (${i}) {\n                    vec4 ${n}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));\n                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the\n                    // normals face the camera directly. So we hackily fix this by offsetting the normal\n                    // by a tiny amount.\n                    vec3 ${n}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;\n                    ${n}_offset = normalize(${n}_clipNormal.xy) / ${r} * (${e} / 2.0) * ${n}_clipPosition.w * 2.0 * ${a};\n                    ${n}_clipPosition.xy += ${n}_offset;\n                    // TODO(MAX): To handle multiple outline layers, we only want to extrude\n                    // if this offset is the biggest of all the potential offsets\n                    gl_Position = ${n}_clipPosition;\n                }\n            `)}if(t.isShader("fragment")){t.require("uv"),t.requires.uv=[!0],t.addFragmentVariable(this.calpha,"float");let n=t.include(sm.Nodes.outline),r=[];return r.push(this.outlineColor.build(t,"c")),r.push(this.contourColor.build(t,"c")),r.push(this.outlineWidth.build(t,"f")),r.push(this.contourWidth.build(t,"f")),r.push(this.contourThreshold.build(t,"f")),r.push(this.outlineThreshold.build(t,"f")),r.push(this.contourFrequency.build(t,"f")),r.push(this.outlineSmoothing.build(t,"f")),r.push(this.contourDirection.build(t,"v3")),r.push(this.positionalLines.build(t,"b")),r.push(this.resolution.build(t,"v2")),r.push(this.normalMap.getTexture(t,"t")),r.push(this.depthMap.getTexture(t,"t")),r.push(this.pixelRatio.build(t,"f")),r.push(this.compensation.build(t,"b")),r.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),r.push(this.alpha.build(t,"f")),r.push(this.calpha),this.firstTime=!this.firstTime,t.format(n+"("+r.join(",")+")",this.getType(t),e)}return console.warn("OutlineNode is not compatible with "+t.shader+" shader."),""}},om=sm;om.Nodes=function(){let t=new Zp("\nfloat sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)\n{\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    vec2 texelSize = (vec2(1.0) / resolution);\n    vec2 offsetSize = texelSize * outlineWidth * pixelRatio;\n\n    vec2 uvSamples[9];\n    vec4 normalSamples[9];\n\n\tuvSamples[0] = uv + vec2( -offsetSize.x, -offsetSize.y) + (vogelDiskSample(0, 9, temporalAngle) * texelSize);\n\tuvSamples[1] = uv + vec2(0.0, -offsetSize.y) + (vogelDiskSample(1, 9, temporalAngle) * texelSize);\n\tuvSamples[2] = uv + vec2(  offsetSize.x, -offsetSize.y) + (vogelDiskSample(2, 9, temporalAngle) * texelSize);\n\tuvSamples[3] = uv + vec2( -offsetSize.x, 0.0) + (vogelDiskSample(3, 9, temporalAngle) * texelSize);\n\tuvSamples[4] = uv;\n\tuvSamples[5] = uv + vec2(  offsetSize.x, 0.0) + (vogelDiskSample(5, 9, temporalAngle) * texelSize);\n\tuvSamples[6] = uv + vec2( -offsetSize.x, offsetSize.y) + (vogelDiskSample(6, 9, temporalAngle) * texelSize);\n\tuvSamples[7] = uv + vec2(0.0, offsetSize.y) + (vogelDiskSample(7, 9, temporalAngle) * texelSize);\n\tuvSamples[8] = uv + vec2(  offsetSize.x, offsetSize.y) + (vogelDiskSample(8, 9, temporalAngle) * texelSize);\n\n\n    normalSamples[0] = texture2D(t, uvSamples[0]);\n    normalSamples[1] = texture2D(t, uvSamples[1]);\n    normalSamples[2] = texture2D(t, uvSamples[2]);\n    normalSamples[3] = texture2D(t, uvSamples[3]);\n    normalSamples[4] = texture2D(t, uvSamples[4]);\n    normalSamples[5] = texture2D(t, uvSamples[5]);\n    normalSamples[6] = texture2D(t, uvSamples[6]);\n    normalSamples[7] = texture2D(t, uvSamples[7]);\n    normalSamples[8] = texture2D(t, uvSamples[8]);\n\n    float depthBias = 0.0001;\n    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!\n    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {\n        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;\n        if (gl_FragCoord.z > depthAtSample) {\n           return 0.0;\n        }\n    }\n\n    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {\n        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;\n        if (gl_FragCoord.z > depthAtSample) {\n           return 0.0;\n        }\n    }\n\n    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {\n        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;\n        if (gl_FragCoord.z > depthAtSample) {\n           return 0.0;\n        }\n    }\n\n    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {\n        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;\n        if (gl_FragCoord.z > depthAtSample) {\n           return 0.0;\n        }\n    }\n\n\n    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {\n        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;\n        if (gl_FragCoord.z > depthAtSample) {\n           return 0.0;\n        }\n    }\n\n    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {\n        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;\n        if (gl_FragCoord.z > depthAtSample) {\n           return 0.0;\n        }\n    }\n\n    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {\n        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;\n        if (gl_FragCoord.z > depthAtSample) {\n           return 0.0;\n        }\n    }\n\n    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {\n        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;\n        if (gl_FragCoord.z > depthAtSample) {\n           return 0.0;\n        }\n    }\n\n    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {\n        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;\n        if (gl_FragCoord.z > depthAtSample) {\n           return 0.0;\n        }\n    }\n\n    vec3 sobel_edge_h = normalSamples[2].rgb + (2.0*normalSamples[5].rgb) + normalSamples[8].rgb - (normalSamples[0].rgb + (2.0*normalSamples[3].rgb) + normalSamples[6].rgb);\n  \tvec3 sobel_edge_v = normalSamples[0].rgb + (2.0*normalSamples[1].rgb) + normalSamples[2].rgb - (normalSamples[6].rgb + (2.0*normalSamples[7].rgb) + normalSamples[8].rgb);\n\n    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));\n    return edgeNormal;\n}\n");return{outline:new Zp("vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float mask, float alpha, out float calpha) {\n                vec3 result = outlineColor;\n                float resultAlpha = 0.0;\n\n                vec3 N = normalize(vWNormal);\n                vec2 nuv = (gl_FragCoord.xy / resolution);\n                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);\n                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);\n\n                //resultAlpha = 1.0;\n                //result = vec3(sobelSample);\n\n                float t = 1.0 - contourThreshold;\n                if(positionalLines) {\n                    vec3 NDir = position * contourDirection;\n                    float NT = NDir.x + NDir.y + NDir.z;\n                    float f  = fract(NT * contourFrequency * 0.01);\n                    float df = fwidth(NT * contourFrequency);\n\n                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);\n                    if (g < 1.0 && resultAlpha == 0.0) {\n                        result = contourColor;\n                        resultAlpha = 1.0;\n                    }\n                 }\n                 else {\n                    vec3 NDir = N * contourDirection;\n                    float NT = NDir.x + NDir.y + NDir.z;\n                    float df = fwidth(NT * contourThreshold);\n                    float f = sin(NT * 1.0 * contourFrequency);\n                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);\n\n                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {\n                        result = contourColor;\n                        resultAlpha = 1.0 - g;\n                    }\n                 }\n\n                 float lalpha = alpha * resultAlpha * mask;\n                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;\n\t\t\t\t \n                 return result;\n             }",[t])}}();var lm=class extends Gp{constructor(t,e,n,r,i,a,s,o,l,h,d,c,u,p,f,m,g,v){super("v3"),this.nodeType="Pattern",this.style=t,this.projection=e,this.axis=n,this.blending=r,this.offset=i,this.colorA=a,this.colorB=s,this.frequency=o,this.size=l,this.variation=h,this.smoothness=d,this.zigzag=c,this.rotation=u,this.vertical=p,this.horizontal=f,this.sides=m,this.isMask=v,this.alpha=g,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){if(t.isShader("fragment")){let n;switch(t.require("position"),t.require("uv"),t.requires.uv=[!0],t.require("normal"),t.requires.normal=!0,t.addFragmentVariable(this.calpha,"float"),this.style.value){case 0:default:n="circle";break;case 1:n="ring";break;case 2:n="polygon";break;case 3:n="xcross";break;case 4:n="diamond";break;case 5:n="checkerboard";break;case 6:n="line";break;case 7:n="wave"}let r=`g${this.uuid.toString().replace(/-/g,"")}`,i=new Zp("float hashwithoutsine12(vec2 p)\n\t\t\t\t{\n\t\t\t\t\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n\t\t\t\t\tp3 += dot(p3, p3.yzx + 33.33);\n\t\t\t\t\treturn fract((p3.x + p3.y) * p3.z);\n\t\t\t\t}"),a=new Zp("vec2 rotate_uv(in vec2 uv, float a, bool repeat) \n\t\t\t\t{\n\t\t\t\t\tconst float mid = 0.5;\n\t\t\t\t\tfloat radians = a * (PI / 180.0);\n\t\t\t\t\tvec2 rotated = vec2(\n\t\t\t\t\t\tcos(radians) * (uv.x - mid) + sin(radians) * (uv.y - mid) + mid,\n\t\t\t\t\t\tcos(radians) * (uv.y - mid) - sin(radians) * (uv.x - mid) + mid\n\t\t\t\t\t);\n\t\t\t\t\treturn repeat ? fract(rotated): rotated;\n\t\t\t\t}"),s="";if(4===this.projection.value){s=`\n\t\t\t\tvec3 p = position;\n\t\t\t\tfloat factor = 0.0125;\n\t\t\t\tvec2 uv0 = fract(p.xy * factor);\n\t\t\t\tvec2 uv1 = fract(p.zy * factor);\n\t\t\t\tvec2 uv2 = fract(p.xz * factor);\n\t\t\t\t\n\t\t\t\tuv0 = rotate_uv(uv0 + offset, rotation, true);\n\t\t\t\tuv1 = rotate_uv(uv1 + offset, rotation, true);\n\t\t\t\tuv2 = rotate_uv(uv2 + offset, rotation, true);\n\t\n\t\t\t\tfloat d0 = ${2===this.style.value?`${n}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`:`${n}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation)`};\n\t\t\t\tfloat d1 = ${2===this.style.value?`${n}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`:`${n}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation)`};\n\t\t\t\tfloat d2 = ${2===this.style.value?`${n}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`:`${n}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation)`};\n\t\t\t\t\n\t\t\t\t// Range from 3 to 128 seems to be good\n\t\t\t\tfloat exponent = (1.0 - blending) * 125.0 + 3.0;\n\n\t\t\t\tvec3 n = vObjectNormal;\n\t\t\t\tvec3 weights = abs(normalize(n));\n\t\t\t\tweights = pow(weights, vec3(exponent));\n\t\t\t\tweights /= dot(weights, vec3(1.0));\n\t\t\t\td0 *= weights.z;\n\t\t\t\td1 *= weights.x;\n\t\t\t\td2 *= weights.y;\n\t\t\t\tfloat draw = d0 + d1 + d2;\n\t\n\t\t\t\tvec2 custom_uv = uv0 * weights.z + uv1 * weights.x + uv2 * weights.y;\n\t\t\t\t`}else{let t=2===this.style.value?`${n}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`:`${n}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,e="";0===this.axis.value?e="float radius = length(p);\n\t\t\t\t\tfloat theta = atan(p.y, p.z);\n\t\t\t\t\tfloat phi = acos(p.x / radius);":1===this.axis.value?e="float radius = length(p);\n\t\t\t\t\tfloat theta = atan(p.x, p.z);\n\t\t\t\t\tfloat phi = acos(p.y / radius);":(this.axis.value,e="float radius = length(p);\n\t\t\t\t\tfloat theta = atan(p.y, p.x);\n\t\t\t\t\tfloat phi = acos(p.z / radius);");let r="";switch(this.projection.value){case 0:r="custom_uv = vUv.st;";break;case 1:break;case 2:r=`\n\t\t\t\t\t\t\tvec3 p = position;\n\t\t\t\t\t\t\t${e}\n\t\t\t\t\t\t\tcustom_uv = vec2(theta, phi);\n\t\t\t\t\t\t\tcustom_uv /= PI;\n\t\t\t\t\t\t\t`}s=`\n\t\t\t\tvec2 custom_uv;\n\t\t\t\t${r}\n\t\n\t\t\t\tcustom_uv += offset;\n\t\t\t\tcustom_uv = fract(custom_uv);\n\t\t\t\tcustom_uv = rotate_uv(custom_uv, rotation, true);\n\t\n\t\t\t\tfloat draw = ${t};\n\t\t\t\t`}let o=new Zp(`vec3 ${r}_pattern(vec3 normal, float blending, int style, vec2 offset, vec4 colorA, vec4 colorB, vec2 frequency, float size, float variation, float smoothness, float zigzag, float rotation, vec2 vertical, vec2 horizontal, int sides, bool isMask, float mask, float alpha, out float calpha) {\n\t\t\t\t\tconst float TWO_PI = PI * 2.0;\n\t\t\t\t\tfloat smoothness_remapped = pow(smoothness, 5.0);\t\n\n\t\t\t\t\t${s}\n\n\t\t\t\t\t// Construct final output color\n\t\t\t\t\tvec4 color = mix(colorA, colorB, draw);\n\t\t\t\t\tcolor.a = clamp(color.a, 0.0, 1.0);\n\n\t\t\t\t\t// Apply cuts\n\t\t\t\t\tcolor.a *= \n\t\t\t\t\t\tstep(vertical.x, custom_uv.y) * \n\t\t\t\t\t\tstep(custom_uv.y, vertical.y);\n\t\t\t\t\tcolor.a *= \n\t\t\t\t\t\tstep(horizontal.x, abs(custom_uv.x)) * \n\t\t\t\t\t\tstep(abs(custom_uv.x), horizontal.y);\n\n\t\t\t\t\t// Accumulate alpha \n\t\t\t\t\tfloat lalpha = alpha * clamp(color.a, 0.0, 1.0) * mask;\n\t\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\t\treturn clamp(color, 0.0, 1.0).rgb;\n\t\t\t\t}`,[a,i,lm.DrawFunctions.circle,lm.DrawFunctions.ring,lm.DrawFunctions.polygon,lm.DrawFunctions.cross,lm.DrawFunctions.diamond,lm.DrawFunctions.checkerboard,lm.DrawFunctions.line,lm.DrawFunctions.wave]),l=t.include(o),h=[];return h.push("normal"),h.push(this.blending.build(t,"f")),h.push(this.style.build(t,"i")),h.push(this.offset.build(t,"v2")),h.push(this.colorA.build(t,"v4")),h.push(this.colorB.build(t,"v4")),h.push(this.frequency.build(t,"v2")),h.push(this.size.build(t,"f")),h.push(this.variation.build(t,"f")),h.push(this.smoothness.build(t,"f")),h.push(this.zigzag.build(t,"f")),h.push(this.rotation.build(t,"f")),h.push(this.vertical.build(t,"v2")),h.push(this.horizontal.build(t,"v2")),h.push(this.sides.build(t,"i")),h.push(this.isMask.build(t,"b")),h.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),h.push(this.alpha.build(t,"f")),h.push(this.calpha),t.format(l+"("+h.join(",")+")",this.getType(t),e)}return console.warn("PatterNode is not compatible with "+t.shader+" shader."),t.format("vec3(0.0)",this.getType(t),e)}},hm=lm;hm.DrawFunctions=function(){let t=new Zp("float hashwithoutsine12(vec2 p) {\n\t\t\t\tvec3 p3 = fract(vec3(p.xyx) * 0.1031);\n\t\t\t\tp3 += dot(p3, p3.yzx + 33.33);\n\t\t\t\treturn fract((p3.x + p3.y) * p3.z);\n\t\t\t}"),e=new Zp("vec2 tile_and_center(in vec2 uv, in vec2 frequency, in float variation, in float zigzag, in float rotation) {\n                // Create tiles in UV-space\n                uv *= frequency;\n\n                // Integer coords\n                vec2 i = floor(uv);\n\n                // Offset every other row based on zigzag param, then compute fractional coords\n                float row_offset = mod(i.y, 2.0);\n                uv.x += row_offset * zigzag;\n                vec2 f = fract(uv);\n\n\t\t\t\t// Rotate the tile itself:\n\t\t\t\t// const float mid = 0.5;\n\t\t\t\t// f = vec2(\n\t\t\t\t// \tcos(rotation) * (f.x - mid) + sin(rotation) * (f.y - mid) + mid,\n\t\t\t\t// \tcos(rotation) * (f.y - mid) - sin(rotation) * (f.x - mid) + mid\n\t\t\t\t// );\n\t\t\t\t// f = fract(f);\n\n                f = f * 2.0 - 1.0;\n\n\t\t\t\t// Recompute integer coords after shifting - then, random value per tile \n\t\t\t\ti = floor(uv);\n\t\t\t\tfloat rand = (hashwithoutsine12(i) * 5.0 + 1.0);\n\t\t\t\tfloat jitter = mix(1.0, rand, variation);\n\t\t\t\tf *= jitter;\n\n                return f;\n            }",[t]);return{tileAndCenter:e,circle:new Zp("float circle(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {\n                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);\n                return smoothstep(\n                    -smoothness, \n                     smoothness, \n                     length(f) - size\n                );\n            }",[e]),ring:new Zp("float ring(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {\n                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);\n\n\t\t\t\tfloat d = length(f);\n                const float inner_width = 0.5;\n\n                float outer = smoothstep(-smoothness, smoothness, d - size);\n                float inner = smoothstep(-smoothness, smoothness, d - size * inner_width);\n\t\t\t\treturn outer + (1.0 - inner);   \n            }",[e]),polygon:new Zp("float sdf_ngon(in vec2 p, in float r, in int n) {\n                float an = (PI * 2.0) / float(n);\n                float he = r * tan(0.5 * an);\n                \n                // Rotate to first sector\n                p = -p.yx; \n                float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n                vec2  cs = vec2(cos(bn), sin(bn));\n                p = mat2(cs.x, -cs.y, cs.y, cs.x)*p;\n            \n                // Side of polygon\n                return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x - r);\n            }\n            \n            float polygon(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation, in int sides) {\n                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);\n                return smoothstep(-smoothness, smoothness, sdf_ngon(f, size, sides));\n            }",[e]),cross:new Zp("float sdf_cross(in vec2 p, in vec2 b, float r ) {\n                p = abs(p); \n\t\t\t\tp = (p.y > p.x) ? p.yx : p.xy;\n                vec2  q = p - b;\n                float k = max(q.y, q.x);\n                vec2  w = (k > 0.0) ? q : vec2(b.y - p.x, -k);\n                return sign(k) * length(max(w, 0.0)) + r;\n            }\n            \n            // Avoid namespace conflicts \n            float xcross(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {\n                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);\n                return smoothstep(-smoothness, smoothness, sdf_cross(f, vec2(size, size * 0.25), smoothness));\n            }",[e]),diamond:new Zp("float ndot(vec2 a, vec2 b) { \n                return a.x*b.x - a.y*b.y; \n            }\n            \n            float sdf_diamond(in vec2 p, in vec2 b) {\n                p = abs(p);\n                float h = clamp(ndot(b - 2.0 * p, b) / dot(b, b), -1.0, 1.0);\n                float d = length(p - 0.5 * b * vec2(1.0 - h, 1.0 + h));\n                return d * sign(p.x * b.y + p.y * b.x - b.x * b.y);\n            }\n\n            float diamond(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {\n                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);\n\t            return smoothstep(-smoothness, smoothness, sdf_diamond(f, vec2(size)));\n            }",[e]),checkerboard:new Zp("float checkerboard(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {\n                uv *= frequency;\n                vec2 i = floor(uv);\n\n                float offset = mod(i.y, 2.0);\n\n                uv.x += offset + zigzag * offset;\n                float x = floor(uv.x);\n                \n                return mod(x, 2.0);\n            }"),line:new Zp("float line(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {\n                vec2 f = tile_and_center(uv, frequency, 0.0, zigzag, rotation);\n\t\t\t\t\n\t\t\t\t// Different approach for variation param here\n\t\t\t\tfloat row = floor(uv * frequency).y;\n\t\t\t\tfloat rand = hashwithoutsine12(vec2(row));\n\t\t\t\tfloat s = mix(size, size * rand, variation);\n\n\t\t\t\treturn smoothstep(\n\t\t\t\t\ts - smoothness, \n\t\t\t\t\ts + smoothness, \n\t\t\t\t\tabs(f.y)\n\t\t\t\t);\n            }",[e]),wave:new Zp("// Uses bisection \n            float udf_cos(in vec2 p, in float a, in float b, in float c, in float d) {\n                // Convert all data to a primitive cosine wave\n                p = c * (p - vec2(d, a));\n                \n                const float TWO_PI = PI * 2.0;\n\n                // Reduce to principal half cycle\n                p.x = mod(p.x, TWO_PI); \n                if (p.x > PI) {\n                    p.x = TWO_PI - p.x;\n                }\n            \n                // Find zero of derivative (minimize distance)\n                float xa = 0.0;\n                float xb = TWO_PI;\n\n                // 24 bit precision\n                for (int i = 0; i < 24; i++) {\n                    float x = 0.5 * (xa + xb);\n                    float y = x - p.x + b * c * sin(x) * (p.y - b * c * cos(x));\n                    if (y < 0.0) xa = x; \n                    else xb = x;\n                }\n                float x = 0.5 * (xa + xb);\n                \n                // Compute distance    \n                vec2 q = vec2(x, b * c * cos(x));\n                return length(p - q) / c;\n            }\n\n            float wave(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {\n                float repeat = frequency.x;\n                uv *= repeat;\n                vec2 i = floor(uv);\n                float row_offset = mod(i.y, 2.0);\n                uv.x += row_offset * zigzag;\n                vec2 f = vec2(uv.x, fract(uv.y));\n\n                // Generalized cosine: y(x) = a + b * cos(cx + d)\n                const float amplitude = 0.125;\n                float wave_frequency = frequency.y * 0.1;\n                float distance_estimate = udf_cos(f, 0.50, amplitude, wave_frequency * (2.0 * PI), 0.0);\n\n\t\t\t\t// Different approach for variation param here\n\t\t\t\tfloat rand = hashwithoutsine12(vec2(i.y));\n\t\t\t\tfloat s = mix(size, size * rand, variation);\n\n                return smoothstep(-smoothness, smoothness, distance_estimate - s * 0.5);\n            }")}}();var dm=class extends Gp{constructor(t,e,n,r,i,a,s,o){super("v3"),this.nodeType="Rainbow",this.filmThickness=t,this.movement=e,this.wavelengths=n,this.noiseStrength=r,this.noiseScale=i,this.offset=a,this.isMask=o,this.alpha=s,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){if(t.require("vWorldViewDir"),t.require("worldNormal"),t.isShader("fragment")){t.require("uv"),t.requires.uv=[!0],t.addFragmentVariable(this.calpha,"float");let n=t.include(dm.Nodes.rainbow),r=[];return r.push(this.filmThickness.build(t,"f")),r.push(this.movement.build(t,"f")),r.push(this.wavelengths.build(t,"v3")),r.push(this.noiseStrength.build(t,"f")),r.push(this.noiseScale.build(t,"f")),r.push(this.offset.build(t,"v3")),r.push(this.isMask.build(t,"b")),r.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),r.push(this.alpha.build(t,"f")),r.push(this.calpha),t.format(n+"("+r.join(",")+")",this.getType(t),e)}return console.warn("RainbowNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},cm=dm;cm.Nodes=function(){let t=new Zp("vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {\n                 vec3 st = position / noiseScale;\n\t\t\t\t vec3 q = vec3(simplex3d(st),\n\t\t\t\t\t\t\t  simplex3d(st + vec3(1.0)),\n\t\t\t\t\t\t\t  simplex3d(st + vec3(1.0)));\n\n\t\t\t\t vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),\n\t\t\t\t\t\t\t  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),\n\t\t\t\t\t\t\t  simplex3d(st * q));\n\n                 float noise = simplex3d(st + r);\n\n                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);\n             }",[im.simplex]);return{rainbow:new Zp("vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, bool isMask, float mask, float alpha, out float calpha) {\n\t\t\t\tvec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);\n\n\t\t\t\tfloat rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);\n\n\t\t\t\tfloat lalpha = alpha * rainbowContribution * mask;\n\t\t\t\tcalpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));\n\n\t\t\t\treturn res;\n             }",[t])}}();var um=class extends Gp{constructor(t,e,n,r,i,a,s,o,l,h){super("v3"),this.nodeType="Toon",this.positioning=t,this.colors=e,this.steps=n,this.source=r,this.isWorldSpace=i,this.noiseStrength=a,this.noiseScale=s,this.shadowColor=o,this.offset=l,this.alpha=h,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){if(t.require("worldNormal"),t.require("worldPosition"),t.isShader("fragment")){t.define("COLORS_MAX",10),t.addFragmentVariable(this.calpha,"float");let n=t.include(um.Nodes.toon),r=[];return r.push(this.positioning.build(t,"i")),r.push(this.colors.build(t,"v4[]")),r.push(this.steps.build(t,"f[]")),r.push(this.source.build(t,"v3")),r.push(this.isWorldSpace.build(t,"b")),r.push(this.noiseStrength.build(t,"f")),r.push(this.noiseScale.build(t,"f")),r.push(this.shadowColor.build(t,"v4")),r.push(this.offset.build(t,"v3")),r.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),r.push(this.alpha.build(t,"f")),r.push(this.calpha),t.format(n+"("+r.join(",")+")",this.getType(t),e)}return console.warn("ToonNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},pm=um;pm.Nodes=function(){let t=new Zp("float rand(float n) {\n\t\t\t\treturn fract(sin(n) * 43758.5453123);\n\t\t\t}"),e=new Zp("float hash1(float p) { \n\t\t\t\tp = fract(p * 0.011); \n\t\t\t\tp *= p + 7.5; \n\t\t\t\tp *= p + p; \n\t\t\t\treturn fract(p); \n\t\t\t}"),n=new Zp("float valueNoise(vec3 x) {\n\t\t\t\tconst vec3 step = vec3(110, 241, 171);\n\t\t\t\n\t\t\t\tvec3 i = floor(x);\n\t\t\t\tvec3 f = fract(x);\n\t\t\t \n\t\t\t\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the \n\t\t\t\t// incremental change to the 1D based on the 3D -> 1D wrapping\n\t\t\t\tfloat n = dot(i, step);\n\t\t\t\n\t\t\t\tvec3 u = f * f * (3.0 - 2.0 * f);\n\t\t\t\treturn mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),\n\t\t\t\t\t\t\t   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n\t\t\t\t\t\t   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),\n\t\t\t\t\t\t\t   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n\t\t\t}",[e]),r=new Zp("vec3 hash3(vec3 x) {\n\t\t\t\tx = vec3(dot(x,vec3(127.1, 311.7, 74.7)),\n\t\t\t\t\t\t dot(x,vec3(269.5, 183.3, 246.1)),\n\t\t\t\t\t\t dot(x,vec3(113.5, 271.9, 124.6)));\n\t\t\t\n\t\t\t\treturn fract(sin(x)*43758.5453123);\n\t\t\t}"),i=new Zp('vec3 voronoiNoise(in vec3 x)\n\t\t\t{\n\t\t\t\tvec3 p = floor(x);\n\t\t\t\tvec3 f = fract(x);\n\n\t\t\t\tfloat id = 0.0;\n\t\t\t\tvec2 res = vec2(100.0);\n\n\t\t\t\tfor(int k=-1; k<=1; k++)\n\t\t\t\tfor(int j=-1; j<=1; j++)\n\t\t\t\tfor(int i=-1; i<=1; i++)\n\t\t\t\t{\n\t\t\t\t\tvec3 b = vec3(float(i), float(j), float(k));\n\n\t\t\t\t\t// Comment out the "+ hash(p + b);" part below to get "square" cells\n\t\t\t\t\tvec3 r = vec3(b) - f + hash3(p + b);\n\t\t\t\t\tfloat d = dot(r, r);\n\n\t\t\t\t\tif (d < res.x)\n\t\t\t\t\t{\n\t\t\t\t\t\tid = dot(p + b, vec3(1.0, 57.0, 113.0));\n\t\t\t\t\t\tres = vec2(d, res.x);\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if (d < res.y)\n\t\t\t\t\t{\n\t\t\t\t\t\tres.y = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn vec3(sqrt(res), abs(id));\n\t\t\t}\n\t\t\t',[r]);return{toon:new Zp('vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float mask, float alpha, out float calpha) {\n\t\t\t\tfloat t = 0.0;\n\t\t\t\tfloat shadow = 1.0;\n\n\t\t\t\tif (positioning == 0) {\n\n\t\t\t\t\t// Can\'t do this mode if lighting is "none"\n\t\t\t\t\t#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))\n\n\t\t\t\t\t\t// Algorithm from Chapter 10 of Graphics Shaders\n\t\t\t\t\t\tconst vec3 weights = vec3(0.2125, 0.7154, 0.0721);\n\t\t\t\t\t\tvec3 lpos;\n\t\t\t\t\t\tvec3 l;\n\t\t\t\t\t\tfloat dproduct;\n\n\t\t\t\t\t\t#if (NUM_POINT_LIGHTS > 0)\n\n\t\t\t\t\t\t\t#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)\n\t\t\t\t\t\t\t\tPointLightShadow pointLightShadow;\n\t\t\t\t\t\t\t#endif \n\n\t\t\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\t\tfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n\t\t\t\t\t\t\t\t// Light positions are in view-space for some reason?\n\t\t\t\t\t\t\t\tlpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;\n\t\t\t\t\t\t\t\tl = normalize(lpos - worldPosition);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tdproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// TODO: we want to use "intensity" but it isn\'t available in the shader code\n\t\t\t\t\t\t\t\t//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);\n\n\t\t\t\t\t\t\t\tt = max(t, dproduct);\n\n\t\t\t\t\t\t\t\t// Accumulate shadow contribution\n\t\t\t\t\t\t\t\t#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)\n\t\t\t\t\t\t\t\t\tpointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];\n\t\t\t\t\t\t\t\t\tshadow *= getPointShadow( \n\t\t\t\t\t\t\t\t\t\t\tpointShadowMap[UNROLLED_LOOP_INDEX], \n\t\t\t\t\t\t\t\t\t\t\tpointLightShadow.shadowMapSize, \n\t\t\t\t\t\t\t\t\t\t\tpointLightShadow.shadowBias, \n\t\t\t\t\t\t\t\t\t\t\tpointLightShadow.shadowRadius,\n\t\t\t\t\t\t\t\t\t\t\tvPointShadowCoord[UNROLLED_LOOP_INDEX], \n\t\t\t\t\t\t\t\t\t\t\tpointLightShadow.shadowCameraNear, \n\t\t\t\t\t\t\t\t\t\t\tpointLightShadow.shadowCameraFar);\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#if NUM_DIR_LIGHTS > 0 \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)\n\t\t\t\t\t\t\t\tDirectionalLightShadow directionalLightShadow;\n\t\t\t\t\t\t\t#endif \n\n\t\t\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\t\tfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\n\t\t\t\t\t\t\t\t// Use the direction vector for directional lights instead\n\t\t\t\t\t\t\t\tl = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;\n\t\t\n\t\t\t\t\t\t\t\tdproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;\n\t\t\t\t\t\t\t\tt = max(t, dproduct);\n\n\t\t\t\t\t\t\t\t// Accumulate shadow contribution\n\t\t\t\t\t\t\t\t#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)\n\t\t\t\t\t\t\t\t\tdirectionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];\n\t\t\t\t\t\t\t\t\tshadow *= getShadow( \n\t\t\t\t\t\t\t\t\t\tUNROLLED_LOOP_INDEX,\n\t\t\t\t\t\t\t\t\t\tdirectionalShadowMap[UNROLLED_LOOP_INDEX], \n\t\t\t\t\t\t\t\t\t\tdirectionalLightShadow.shadowMapSize, \n\t\t\t\t\t\t\t\t\t\tdirectionalLightShadow.shadowBias, \n\t\t\t\t\t\t\t\t\t\tdirectionalLightShadow.shadowRadius, \n\t\t\t\t\t\t\t\t\t\tvDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#if NUM_SPOT_LIGHTS > 0 \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)\n\t\t\t\t\t\t\t\tSpotLightShadow spotLightShadow;\n\t\t\t\t\t\t\t#endif \n\n\t\t\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\t\tfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\n\t\t\t\t\t\t\t\tlpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;\n\t\t\t\t\t\t\t\tl = normalize(lpos - worldPosition);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tdproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;\n\t\t\t\t\t\t\t\tt = max(t, dproduct);\n\n\t\t\t\t\t\t\t\t// Accumulate shadow contribution\n\t\t\t\t\t\t\t\t#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)\n\t\t\t\t\t\t\t\t\tspotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];\n\t\t\t\t\t\t\t\t\tshadow *= getShadow(\n\t\t\t\t\t\t\t\t\t\tUNROLLED_LOOP_INDEX,\n\t\t\t\t\t\t\t\t\t\tspotShadowMap[UNROLLED_LOOP_INDEX], \n\t\t\t\t\t\t\t\t\t\tspotLightShadow.shadowMapSize, \n\t\t\t\t\t\t\t\t\t\tspotLightShadow.shadowBias, \n\t\t\t\t\t\t\t\t\t\tspotLightShadow.shadowRadius, \n\t\t\t\t\t\t\t\t\t\tvSpotLightCoord[UNROLLED_LOOP_INDEX]);\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tt = clamp(t, 0.0, 1.0);\n\t\t\t\t\n\t\t\t\t\t#endif\n\n\t\t\t\t} else if (positioning == 1) {\n\t\t\t\t\t\n\t\t\t\t\tvec3 origin = mix(position, worldPosition, float(isWorldSpace));\n\t\t\t\t\tvec3 direction = normalize(source - origin);\n\t\t\t\t\tt = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;\t\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvec3 origin = worldPosition;\n\t\t\t\t\tvec3 source = cameraPosition - offset;\n\t\t\t\t\tvec3 direction = normalize(source - origin);\n\t\t\t\t\tt = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;\t\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tif (noiseStrength > 0.0) {\n\t\t\t\t\t// Distort with noise\n\t\t\t\t\tvec3 st = position / noiseScale;\n\t\t\t\t\t\n\t\t\t\t\t// Voronoi "smooth" noise\n\t\t\t\t\tfloat noise = 1.0 - voronoiNoise(st).x;\n\n\t\t\t\t\t// Voronoi cellular noise\n\t\t\t\t\t//float noise = 1.0 - rand(voronoiNoise(st).z);\n\n\t\t\t\t\t// Position warp noise\n\t\t\t\t\t// vec3 offset = vec3(\n\t\t\t\t\t// \tsimplex3d(st),\n\t\t\t\t\t// \tsimplex3d(st + vec3(111.1, 143.89, 217.19)),\n\t\t\t\t\t// \tsimplex3d(st + vec3(171.1, 247.89, 117.23))\n\t\t\t\t\t// );\n\t\t\t\t\t// st += offset;\n\t\t\t\t\t// float noise = valueNoise(st);\n\n\t\t\t\t\tt += noise * noiseStrength;\n\t\t\t\t}\n\n\t\t\t\tt = clamp(t, 0.0, 1.0);\n\n\t\t\t\t// Compute ramp color\n\t\t\t\tfloat p;\n\t\t\t\tvec4 color = colors[0];\n\t\t\t\tfor (int i = 1; i < COLORS_MAX; i++) {\n\t\t\t\t\tp = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);\n\t\t\t\t\tcolor = mix(color, colors[i], smoothstep(0.0, 1.0, p));\n\t\t\t\t}\n\n\t\t\t\t// Incorporate custom shadow color\n\t\t\t\tif (positioning == 0) {\n\n\t\t\t\t\tvec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);\n\t\t\t\t\tcolor.rgb = mix(blendedShadow, color.rgb, shadow);\n\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// Accumulate alpha as usual\n\t\t\t\tfloat lalpha = alpha * color.a * mask;\n\t\t\t\tcalpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);\n\t\t\t\taccumAlpha += (1.0 - accumAlpha) * lalpha;\n\n\t\t\t\treturn color.xyz;\n\n            }',[im.simplex,t,n,i])}}();var fm={textureBicubic:new Zp("float w0( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n        }\n    \n        float w1( float a ) {\n            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n        }\n    \n        float w2( float a ){\n            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n        }\n    \n        float w3( float a ) {\n            return ( 1.0 / 6.0 ) * ( a * a * a );\n        }\n    \n        // g0 and g1 are the two amplitude functions\n        float g0( float a ) {\n            return w0( a ) + w1( a );\n        }\n    \n        float g1( float a ) {\n            return w2( a ) + w3( a );\n        }\n    \n        // h0 and h1 are the two offset functions\n        float h0( float a ) {\n            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n        }\n    \n        float h1( float a ) {\n            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n        }\n    \n        vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n            uv = uv * texelSize.zw + 0.5;\n    \n            vec2 iuv = floor( uv );\n            vec2 fuv = fract( uv );\n    \n            float g0x = g0( fuv.x );\n            float g1x = g1( fuv.x );\n            float h0x = h0( fuv.x );\n            float h1x = h1( fuv.x );\n            float h0y = h0( fuv.y );\n            float h1y = h1( fuv.y );\n    \n            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n    \n            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + \n                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n        }\n\n        vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n            vec2 fLodSizeInv = 1.0 / fLodSize;\n            vec2 cLodSizeInv = 1.0 / cLodSize;\n            vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n            vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n            return mix( fSample, cSample, fract( lod ) );\n        }")};var mm=class extends Gp{constructor(t,e,n,r,i,a,s,o){super("v3"),this.nodeType="Transmission",this.thickness=t,this.ior=e,this.roughness=n,this.transmissionSamplerSize=r,this.transmissionSamplerMap=i,this.transmissionDepthMap=a,this.aspectRatio=s,this.alpha=o,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(t,e){if(t.extensions.shaderTextureLOD=!0,t.extensions.derivatives=!0,t.isShader("fragment")){t.define("NUM_SAMPLES",6),t.define("BLUR_SLOD",Math.pow(2,xm.transmissionLod.value)),t.require("worldPosition"),t.requires.worldNormal=!0,t.requires.modelMatrix=!0,t.requires.projectionMatrix=!0,t.addFragmentVariable(this.calpha,"float");let n=t.include(mm.Nodes.transmission),r=[];return r.push(this.thickness.build(t,"f")),r.push(this.ior.build(t,"f")),r.push(this.roughness.build(t,"f")),r.push(this.transmissionSamplerSize.build(t,"v2")),r.push(this.transmissionSamplerMap.getTexture(t,"t")),r.push(this.transmissionDepthMap.getTexture(t,"t")),r.push(this.aspectRatio.build(t,"v2")),r.push("normal"),r.push(this.mask?`luminance(${this.mask.flow(t,"v3").result})`:"1.0"),r.push(this.alpha.build(t,"f")),r.push(this.calpha),t.format(n+"("+r.join(",")+")",this.getType(t),e)}return console.warn("TransmissionNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},gm=mm;gm.Nodes=function(){let t=new Zp("vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {\n                // Slightly modified version of this:\n                // https://www.shadertoy.com/view/ltScRG\n\n\t\t\t\t// Special case for blur == 0.0\n\t\t\t\tif (lod == 0.0) {\n\t\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\t\treturn texture2DLodEXT( sp, U, 0.0).rgb;\n\t\t\t\t\t#else\n\t\t\t\t\treturn textureLod( sp, U, 0.0).rgb;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec2 texelSize = vec2(1.0) / resolution;\n                vec2 halton = haltonSequence[frameIndex];\n                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n                float temporalAngle  = temporalOffset * PI2;\n\t\t\t\tvec3 res = vec3(0.0);\n                vec2 uv = vec2(0.0);\n                vec2 offset = vec2(0.0);\n                vec2 vogelSample = vec2(0.0);\n                for (int i = 0; i < NUM_SAMPLES; i++) {\n                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;\n                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20\n                    uv = U + offset;\n                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, uv, lod));\n                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {\n                        uv = unrefractedU;\n                        lod = lod > 4.0 ? lod : lod / 2.0;\n                    }\n                    res += textureLod(sp, uv, lod).rgb;\n                }\n                return res / float(NUM_SAMPLES);\n            }"),e=new Zp("vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\t        // Direction of refracted light.\n\t\t        vec3 refractionVector = refract( -v,  n, 1.0 / ior );\n\t\t        \n\t\t\t\t// Compute rotation-independant scaling of the model matrix.\n\t\t        vec3 modelScale;\n\t\t        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\t        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\t        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t        // The thickness is specified in local space\n\t\t        return normalize( refractionVector ) * thickness * modelScale;\n\t        }"),n=new Zp("float applyIorToRoughness( float roughness, float ior ) {\n\t\t\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\t\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t\t\t}"),r=new Zp('vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {\n\t\t\t\t// Threejs exports do not pass a depth map to this shader, so we have to fallback to the "Threejs method of blurring" - see\n\t\t\t\t// also the code in convertTransmission.ts, which runs during export\n\t\t\t\t#ifdef IS_THREEJS_EXPORT\n\t\t\t\t\tfloat lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);\n\t\t\t\t\treturn textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;\n\t\t\t\t#else\n\t\t\t\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t\t\t\tfloat lod = applyIorToRoughness(roughness, ior);\n\t\t\t\t\treturn blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);\n\t\t\t\t#endif\n\t\t\t}',[fm.textureBicubic,n,t]),i=new Zp("vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\n\t\t\t\tvec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );\n\t\t\t\tvec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;\n\t\t\t\tunrefractedCoords += 1.0;\n\t\t\t\tunrefractedCoords /= 2.0;\n\n\t\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\t\treturn getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );\n    \t\t}",[r,e]);return{transmission:new Zp("vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {\n                vec3 v = vec3(0.);\n                if (isOrthographic) {\n                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n                } else {\n                    v = normalize(vWPosition - cameraPosition);\n                }\n                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );\n                \n\t\t\t\tfloat lalpha = alpha * mask;\n\t\t\t\tcalpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );\n\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * alpha;\n\n\t\t\t\treturn transmission;\n            }",[i])}}();var vm=(t=>(t.NOISE="noise",t.MAP="map",t))(vm||{}),ym=class extends Gp{constructor(t,e,n,r,i,a,s,o,l,h,d){super("v3"),this.displacementTypeIndex=new zf(0),this.nodeType="VertexDisplacement",this.intensity=t,this.movementOrTexture=e,"map"===Object.values(vm)[this.displacementTypeIndex.value]&&(this.mat=new Bf(this.movementOrTexture.value.matrix)),this.cropOrOffset=n,this.scale=h,this.noiseFunctionIndex=d,this.voronoiStyle=r,this.smoothness=i,this.seed=a,this.highCut=s,this.lowCut=o,this.quality=l}generate(t,e){if(t.isShader("vertex")){t.define("USE_LAYER_DISPLACE");let n,r=[];switch(r.push("displaced_position"),r.push("displaced_normal"),Object.values(vm)[this.displacementTypeIndex.value]){case"map":n=t.include(ym.Nodes.map),r.push(this.movementOrTexture.getTexture(t,"t")),r.push("uv"),r.push(this.cropOrOffset.build(t,"f")),this.mat&&r.push(this.mat.build(t,"mat3"));break;case"noise":{let e=Object.values(rm)[this.noiseFunctionIndex.value],i=new Zp("vec3 orthogonal(vec3 v) {\n\t\t\t\t\t\t\treturn normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));\n\t\t\t\t\t\t}"),a=new Zp(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality) {\n\t\t\t\t\t\t\t${"voronoi"==e?`\n\t\t\t\t\tfloat v = ${e}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1), voronoiStyle, smoothness, seed, quality);\n\t\t\t\t\tv = remap(v, lowCut, highCut, 0.0, 1.0);\n\t\t\t\t\tv = smax(v, 0.0, smoothness * 0.25);\n\t\t\t\t\tv = smin(v, 1.0, smoothness * 0.25);\n\n\t\t\t\t\treturn p + n * v * intensity;\n\t\t\t\t\t`:`\n\t\t\t\t\treturn p + n * ${e}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;\n\t\t\t\t\t`}\n\t\t\t\t\t\t}`,[im.simplex,im.simplexFractal,im.simplexAshima,im.fbm,im.perlin,im.voronoi]),s=new Zp("vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality, float intensity, out vec3 displaced_normal) {\n\t\t\t\t\t\t\tvec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);\n\t\t\t\t\t\t\tvec3 tangent1 = orthogonal(normal);\n\t\t\t\t\t\t\tvec3 tangent2 = normalize(cross(normal, tangent1));\n\n                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.\n                            // This caused some small oval/circular visual artifacts in the lighting.\n                            // For now, simply using neighbors further away betters the problem,\n                            // but we should figure out the underlying cause when we have some time.\n                            // Maybe its related to how we calculate the tangent and bitangent?\n\t\t\t\t\t\t\tvec3 nearby1 = position + tangent1;\n\t\t\t\t\t\t\tvec3 nearby2 = position + tangent2;\n\t\t\t\t\t\t\tvec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);\n\t\t\t\t\t\t\tvec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);\n\t\t\t\t\t\t\tdisplaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));\n\t\t\t\t\t\t\treturn displaced_position;\n\t\t\t\t\t\t}",[a,i]);n=t.include(s),r.push(this.scale.build(t,"f")),r.push(this.cropOrOffset.build(t,"v3")),r.push(this.movementOrTexture.build(t,"f")),r.push(this.voronoiStyle.build(t,"i")),r.push(this.smoothness.build(t,"f")),r.push(this.seed.build(t,"f")),r.push(this.highCut.build(t,"f")),r.push(this.lowCut.build(t,"f")),r.push(this.quality.build(t,"i"));break}}return r.push(this.intensity.build(t,"f")),r.push("displaced_normal"),t.format(n+"("+r.join(",")+")",this.getType(t),e)}return console.warn("VertexDisplacementNode is not compatible with "+t.shader+" shader."),t.format("vec3( 0.0 )",this.getType(t),e)}},bm=ym;bm.Nodes=function(){let t=new Zp("vec3 orthogonal(vec3 v) {\n\t\t\t\treturn normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));\n\t\t\t}"),e=new Zp("float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {\n\t\t\t\tvec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;\n\t\t\t\tvec4 tmp = texture2D(tex, uvs);\n\t\t\t\tvec3 col = tmp.rgb;\n\t\t\t\tif (crop > 0.5) {\n\t\t\t\t\tif ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {\n\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn col.r;\n\t\t\t}");return{map:new Zp("vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {\n\t\t\t\tvec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;\n\t\t\t\tvec3 tangent1 = normalize(orthogonal(normal));\n\t\t\t\tvec3 tangent2 = normalize(cross(normal, tangent1));\n\t\t\t\tvec3 nearby1 = position + tangent1 * 0.1;\n\t\t\t\tvec3 nearby2 = position + tangent2 * 0.1;\n\t\t\t\tvec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;\n\t\t\t\tvec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;\n\t\t\t\tdisplaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));\n\t\t\t\treturn displaced_position;\n\t\t\t}",[t,e])}}();var xm={normalRenderTarget:new hf,normalRenderTargetDepth:new hf,transmissionRenderTarget:new hf,aspectRatio:new Wp,transmissionSize:new Wp(2048,2048),transmissionRenderTargetDepth:new hf,aoRenderTarget:new hf,aoEnabled:new Ef,pixelRatioNode:new df(1),resolution:new Wp,penumbraSize:new Lf(5,.5),frameIndex:new zf(0),transmissionLod:new zf(2)};for(let Ly of Object.values(xm))Ly.isRenderGlobal=!0;var wm,_m=class extends Fp{constructor(){super("basic"),this.nodeType="Basic",this.color=new Tf(xl),this.shadingAlpha=new df(1),this.shadingBlend=new zf(0),this.previousModelViewMatrix=new Uf,this.previouseProjectionMatrix=new Uf}get category(){return"phong"}generate(t){let e;if(t.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(t,"v3",{cache:"position"}):void 0;t.mergeUniform({frameIndex:xm.frameIndex}),t.mergeUniform({resolution:xm.resolution}),t.mergeUniform({previousModelViewMatrix:this.previousModelViewMatrix}),t.mergeUniform({previousProjectionMatrix:this.previouseProjectionMatrix}),t.mergeUniform(R.merge([F.fog])),t.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>"].join("\n"));let r=["#include <beginnormal_vertex>","\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\n\t\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#if defined( USE_LAYER_DISPLACE )\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t","#include <normal_vertex>","\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t#endif /* !USE_LAYER_DISPLACE */\n\t\t\t\t"];n&&r.push(n.code,n.result?"displaced_position = "+n.result+";":""),r.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","\tvNormal = transformedNormal;","#endif"),r.push("#include <project_vertex>","#include <fog_vertex>","#include <clipping_planes_vertex>","\tvViewPosition = - mvPosition.xyz;","#include <worldpos_vertex>"),r.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),e=r.join("\n")}else{void 0===this.color&&(this.color=new Tf(xl)),this.color.analyze(t,{slot:"color"}),this.alpha&&this.alpha.analyze(t),this.afterColor&&this.afterColor.analyze(t,{slot:"afterColor"});let n=this.color.flow(t,"c",{slot:"color"}),r=this.alpha?this.alpha.flow(t,"f"):void 0,i=this.alphaOverride?this.alphaOverride.flow(t,"f"):void 0,a=this.afterColor?this.afterColor.flow(t,"c",{slot:"afterColor"}):void 0;t.requires.transparent=void 0!==r,t.addParsCode(["varying vec3 vWPosition;","#include <fog_pars_fragment>","#include <dithering_pars_fragment>","varying vec3 vViewPosition;","#include <normal_pars_fragment>"].join("\n"));let s=["#include <normal_fragment_begin>",n.code];r&&s.push(r.code,"#ifdef ALPHATEST"," if ( "+r.result+" <= ALPHATEST ) discard;","#endif"),a?s.push(a.code,`vec3 outgoingLight = ${n.result};`,`vec3 finalColor = spe_blend(outgoingLight, ${a.result}, 1.0, SPE_BLENDING_NORMAL);`):s.push(`vec3 finalColor = ${n.result};`);let o="1.0";this.mask&&(this.mask.analyze(t),o=`luminance(${this.mask.flow(t,"v3").result})`),r?s.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${r.result} * ${o} );`):s.push("gl_FragColor = vec4("+n.result+", 1.0 );"),i&&s.push(`gl_FragColor.a *= ${i.result};`),s.push("#include <fog_fragment>","#include <dithering_fragment>"),e=s.join("\n")}return e}},Sm=class extends Fp{constructor(){super("lambert"),this.nodeType="Lambert",this.color=new Tf(xl),this.emissive=new Tf(0),this.emissiveIntensity=new df(1),this.previousModelViewMatrix=new Uf,this.previouseProjectionMatrix=new Uf,this.shadingAlpha=new df(1),this.shadingBlend=new zf(0),this.occlusion=new Ef(!0)}get category(){return"lambert"}build(t){let e;if(t.define("LAMBERT"),t.requires.lights=!0,t.extensions.derivatives=!0,t.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(t,"v3",{cache:"position"}):void 0;t.mergeUniform({frameIndex:xm.frameIndex}),t.mergeUniform({resolution:xm.resolution}),t.mergeUniform({previousModelViewMatrix:this.previousModelViewMatrix}),t.mergeUniform({previousProjectionMatrix:this.previouseProjectionMatrix}),t.mergeUniform(R.merge([F.fog,F.lights])),t.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","varying vec3 vLightFront;","varying vec3 vIndirectFront;","#ifndef DOUBLE_SIDED","   #define DOUBLE_SIDED","#endif","#ifdef DOUBLE_SIDED","\tvarying vec3 vLightBack;","\tvarying vec3 vIndirectBack;","#endif","#include <bsdfs>","#include <lights_pars_begin>","#include <color_pars_vertex>","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join("\n"));let r=["#include <beginnormal_vertex>","\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\n\t\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#ifdef USE_LAYER_DISPLACE\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t","#include <normal_vertex>","\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t#endif\n\t\t\t\t"];n&&r.push(n.code,n.result?"displaced_position = "+n.result+";":""),r.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),r.push("\t#include <project_vertex>","\t#include <clipping_planes_vertex>","\tvViewPosition = - mvPosition.xyz;","\t#include <worldpos_vertex>","\n\t\t\t\t\tvec3 diffuse = vec3( 1.0 );\n\t\t\t\t\tGeometricContext geometry;\n\t\t\t\t\tgeometry.position = mvPosition.xyz;\n\t\t\t\t\tgeometry.normal = normalize( transformedNormal );\n\t\t\t\t\tgeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\t\t\t\t"),r.push("\n\t\t\t\t\tGeometricContext backGeometry;\n\t\t\t\t\tbackGeometry.position = geometry.position;\n\t\t\t\t\tbackGeometry.normal = -geometry.normal;\n\t\t\t\t\tbackGeometry.viewDir = geometry.viewDir;\n\t\t\t\t\tvLightFront = vec3( 0.0 );\n\t\t\t\t\tvIndirectFront = vec3( 0.0 );\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\tvLightBack = vec3( 0.0 );\n\t\t\t\t\t\tvIndirectBack = vec3( 0.0 );\n\t\t\t\t\t#endif\n\t\t\t\t\tIncidentLight directLight;\n\t\t\t\t\tfloat dotNL;\n\t\t\t\t\tvec3 directLightColor_Diffuse;\n\t\t\t\t\tvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\t\t\t\t\tvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\t\t\t\t\t\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n\t\t\t\t\t#endif\n\t\t\t\t\t#if NUM_POINT_LIGHTS > 0\n\t\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\t\t\t\t\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\t\t\t\t\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\t\t\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#pragma unroll_loop_end\n\t\t\t\t\t#endif\n\t\t\t\t\t#if NUM_SPOT_LIGHTS > 0\n\t\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\t\t\t\t\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\t\t\t\t\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\t\t\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#pragma unroll_loop_end\n\t\t\t\t\t#endif\n\t\t\t\t\t#if NUM_DIR_LIGHTS > 0\n\t\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\t\t\t\t\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\t\t\t\t\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\t\t\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#pragma unroll_loop_end\n\t\t\t\t\t#endif\n\t\t\t\t\t#if NUM_HEMI_LIGHTS > 0\n\t\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\t\t\t\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t\t\t\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\t\t\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#pragma unroll_loop_end\n\t\t\t\t\t#endif\n\t\t\t\t","\t#include <shadowmap_vertex>","\t#include <fog_vertex>"),r.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),e=r.join("\n")}else{t.mergeUniform({penumbraSize:xm.penumbraSize}),t.mergeUniform({frameIndex:xm.frameIndex}),t.mergeUniform({aoMap:xm.aoRenderTarget}),t.mergeUniform({aoEnabled:xm.aoEnabled}),void 0===this.color&&(this.color=new Tf(xl)),this.color.analyze(t,{slot:"color"}),this.shadingAlpha.analyze(t),this.shadingBlend.analyze(t),this.afterColor&&this.afterColor.analyze(t,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(t);let n=this.color.flow(t,"c",{slot:"color"}),r=this.emissive.flow(t,"c",{slot:"emissive"}),i=this.emissiveIntensity.flow(t,"f",{slot:"emissive"}),a=this.occlusion.flow(t,"b",{slot:"occlusion"}),s=this.shadingAlpha.flow(t,"f"),o=this.shadingBlend.flow(t,"i"),l=this.afterColor?this.afterColor.flow(t,"c",{slot:"afterColor"}):void 0,h=this.alpha?this.alpha.flow(t,"f"):void 0,d=this.alphaOverride?this.alphaOverride.flow(t,"f"):void 0;t.requires.transparent=void 0!==h,t.addParsCode(["uniform float penumbraSize[5];","uniform sampler2D aoMap;","uniform bool aoEnabled;","varying vec3 vViewPosition;","varying vec3 vWPosition;","varying vec3 vLightFront;","varying vec3 vIndirectFront;","#ifndef DOUBLE_SIDED","   #define DOUBLE_SIDED","#endif","#include <normal_pars_fragment>","#ifdef DOUBLE_SIDED","\tvarying vec3 vLightBack;","\tvarying vec3 vIndirectBack;","#endif","#include <bsdfs>","#include <lights_pars_begin>","#include <fog_pars_fragment>","#include <shadowmap_pars_fragment>","#include <shadowmask_pars_fragment>","#include <clipping_planes_pars_fragment>","#include <dithering_pars_fragment>"].join("\n"));let c=["#include <normal_fragment_begin>","\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx, viewdy));\n\t\t\t\tbool isFrontFacing = (dot(normal, faceNormal) >= 0.0);\n\t\t\t\t","#include <clipping_planes_fragment>"];c.push(n.code,"vec3 diffuseColor = "+n.result+";","ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"),h&&c.push(h.code,"#ifdef ALPHATEST","if ( "+h.result+" <= ALPHATEST ) discard;","#endif"),c.push("#ifdef DOUBLE_SIDED","\treflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;","#else","\treflectedLight.indirectDiffuse += vIndirectFront;","#endif","#include <lightmap_fragment>","reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );","#ifdef DOUBLE_SIDED","\treflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;","#else","\treflectedLight.directDiffuse = vLightFront;","#endif","reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"),r&&c.push(r.code,"reflectedLight.directDiffuse += "+r.result+" * "+i.result+";"),c.push("vec3 ao = aoEnabled && "+a.result+" ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);","vec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;");let u="1.0";this.mask&&(this.mask.analyze(t),u=`luminance(${this.mask.flow(t,"v3").result})`),c.push(`\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * ${s.result} * ${u} * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, ${s.result} * ${u}, ${o.result} );\n\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t`),l&&c.push(l.code,`outgoingLight = spe_blend(outgoingLight, ${l.result}, 1.0, SPE_BLENDING_NORMAL);`),h?c.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${h.result} );`):c.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),d&&c.push(`gl_FragColor.a *= ${d.result};`),c.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),e=c.join("\n")}return e}},Am={dHdxy:new Zp("vec2 dHdxy(sampler2D bumpMap, vec2 bumpMapUv, float bumpScale) {\n\n            // Gradient of UVs w.r.t. X coordinate (in screen-space)\n            vec2 dSTdx = dFdx(bumpMapUv);\n\n            // Gradient of UVs w.r.t. Y coordinate (in screen-space)\n            vec2 dSTdy = dFdy(bumpMapUv);\n            \n            // Forward differencing\n            float Hll = bumpScale * luminance(texture(bumpMap, bumpMapUv).rgb);\n            float dBx = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdx).rgb) - Hll;\n            float dBy = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdy).rgb) - Hll;\n            \n            return vec2( dBx, dBy );\n        }"),perturbNormalArb:new Zp("vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n            vec3 vSigmaX = dFdx( surf_pos.xyz );\n            vec3 vSigmaY = dFdy( surf_pos.xyz );\n            vec3 vN = surf_norm; // normalized\n            \n            vN = normalize(vN);\n\n            vec3 R1 = cross( vSigmaY, vN );\n            vec3 R2 = cross( vN, vSigmaX );\n\n            R1 = normalize(R1);\n            R2 = normalize(R2);\n    \n            float fDet = dot( vSigmaX, R1 ) * faceDirection;\n    \n            vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n            return normalize( abs( fDet ) * vN - vGrad );\n        }")},Om=class extends Fp{constructor(){super("phong"),this.nodeType="Phong",this.color=new Tf(xl),this.specular=new Tf(1118481),this.shininess=new df(30),this.previousModelViewMatrix=new Uf,this.previouseProjectionMatrix=new Uf,this.shadingAlpha=new df(1),this.shadingBlend=new zf(0),this.occlusion=new Ef(!0)}get category(){return"phong"}build(t){let e;if(t.define("PHONG"),t.requires.lights=!0,t.extensions.derivatives=!0,t.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(t,"v3",{cache:"position"}):void 0;t.mergeUniform({frameIndex:xm.frameIndex}),t.mergeUniform({resolution:xm.resolution}),t.mergeUniform({previousModelViewMatrix:this.previousModelViewMatrix}),t.mergeUniform({previousProjectionMatrix:this.previouseProjectionMatrix}),t.mergeUniform(R.merge([F.fog,F.lights])),t.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <skinning_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join("\n"));let r=["#include <beginnormal_vertex>","\n\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t#include <skinnormal_vertex>\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\n\t\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#endif\n\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = objectNormal;\n\n\t\t\t\t#ifdef USE_LAYER_DISPLACE\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t","#include <normal_vertex>","\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t#endif\n\t\t\t\t"];n&&r.push(n.code,n.result?"displaced_position = "+n.result+";":""),r.push("transformed = displaced_position;","#include <skinning_vertex>","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),r.push("\t#include <project_vertex>","\t#include <clipping_planes_vertex>","\tvViewPosition = - mvPosition.xyz;","\t#include <worldpos_vertex>","\t#include <shadowmap_vertex>","\t#include <fog_vertex>"),r.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),e=r.join("\n")}else{t.mergeUniform({penumbraSize:xm.penumbraSize}),t.mergeUniform({frameIndex:xm.frameIndex}),t.mergeUniform({aoMap:xm.aoRenderTarget}),t.mergeUniform({aoEnabled:xm.aoEnabled}),void 0===this.color&&(this.color=new Tf(xl)),this.color.analyze(t,{slot:"color"}),this.specular.analyze(t),this.shininess.analyze(t);let n=this.occlusion.flow(t,"b",{slot:"occlusion"});this.shadingAlpha.analyze(t),this.shadingBlend.analyze(t),this.afterColor&&this.afterColor.analyze(t,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(t);let r=this.color.flow(t,"c",{slot:"color"}),i=this.specular.flow(t,"c"),a=this.shininess.flow(t,"f"),s=this.shadingAlpha.flow(t,"f"),o=this.shadingBlend.flow(t,"i"),l=this.afterColor?this.afterColor.flow(t,"c",{slot:"afterColor"}):void 0,h=this.alpha?this.alpha.flow(t,"f"):void 0,d=this.alphaOverride?this.alphaOverride.flow(t,"f"):void 0;t.requires.transparent=void 0!==h,t.addParsCode(["varying vec3 vWPosition;","uniform vec3 emissive;","uniform float penumbraSize[5];","uniform sampler2D aoMap;","uniform bool aoEnabled;","#include <normal_pars_fragment>","#include <fog_pars_fragment>","#include <bsdfs>","#include <lights_pars_begin>","#include <lights_phong_pars_fragment>","#include <shadowmap_pars_fragment>","#include <dithering_pars_fragment>"].join("\n"));let c=["#include <normal_fragment_begin>","\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx,viewdy));\n\t\t\t\tif (dot(normal, faceNormal) < 0.0) {\n\t\t\t\t\tnormal *= -1.0;\n\t\t\t\t}\n\t\t\t\t","\tBlinnPhongMaterial material;"];if(this.bumpMap){t.include(Am.dHdxy),t.include(Am.perturbNormalArb);let e=this.bumpMap.texture.flow(t,"t"),n=this.bumpMap.flow(t,"v3"),r=this.bumpMapIntensity?this.bumpMapIntensity.flow(t,"f").result:"1.0",i="";i=4===this.bumpMap.projection.value?`\n\t\t\t\t\tvec3 bumpNormal = vec3(0.0);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs0;\n\t\t\t\t\t\tvec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs1;\n\t\t\t\t\t\tvec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs2;\n\t\t\t\t\t\tvec3 weights = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_triplanarWeights;\n\n\t\t\t\t\t\tvec2 grad0 = dHdxy(${e.result}, uv0, ${r});\n\t\t\t\t\t\tvec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);\n\n\t\t\t\t\t\tvec2 grad1 = dHdxy(${e.result}, uv1, ${r});\n\t\t\t\t\t\tvec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);\n\n\t\t\t\t\t\tvec2 grad2 = dHdxy(${e.result}, uv2, ${r});\n\t\t\t\t\t\tvec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);\n\t\t\t\t\t\t\n\t\t\t\t\t\tbumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;\n\t\t\t\t\t\tbumpNormal = normalize(bumpNormal);\n\t\t\t\t\t}\n\n\t\t\t\t\tnormal = bumpNormal;\n\t\t\t\t\t`:`\n\t\t\t\t\tvec2 bumpMapCachedUv = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs;\n\t\t\t\t\tvec2 grad = dHdxy(${e.result}, bumpMapCachedUv, ${r});\n\t\t\t\t\tnormal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );\n\t\t\t\t\t`,c.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates\n\t\t\t\t\t${n.result};\n\t\t\t\t\t${i}\n\t\t\t\t\t`)}c.push(r.code,"\tvec3 diffuseColor = "+r.result+";","\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","\tvec3 totalEmissiveRadiance = emissive;",i.code,"\tvec3 specular = "+i.result+";",a.code,"\tfloat shininess = max( 0.0001, "+a.result+" );","\tfloat specularStrength = 1.0;"),h&&c.push(h.code,"#ifdef ALPHATEST","if ( "+h.result+" <= ALPHATEST ) discard;","#endif"),c.push("material.diffuseColor = diffuseColor;"),c.push("material.specularColor = specular;","material.specularShininess = shininess;","material.specularStrength = specularStrength;","#include <lights_fragment_begin>","#include <lights_fragment_end>"),c.push("vec3 ao = aoEnabled && "+n.result+" ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);","vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;");let u="1.0";this.mask&&(this.mask.analyze(t),u=`luminance(${this.mask.flow(t,"v3").result})`),c.push(`\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * ${s.result} * ${u} * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, ${s.result} * ${u}, ${o.result} );\n\t\t\t\t\t\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t`),l&&c.push(l.code,`outgoingLight = spe_blend(outgoingLight, ${l.result}, 1.0, SPE_BLENDING_NORMAL);`),h?c.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${h.result});`):c.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),d&&c.push(`gl_FragColor.a *= ${d.result};`),c.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),e=c.join("\n")}return e}},Mm=class extends Fp{constructor(){super("standard"),this.nodeType="Standard",this.color=new Tf(xl),this.roughness=new df(.3),this.metalness=new df(0),this.reflectivity=new df(.5),this.previousModelViewMatrix=new Uf,this.previouseProjectionMatrix=new Uf,this.shadingAlpha=new df(1),this.shadingBlend=new zf(0),this.occlusion=new Ef(!0)}get category(){return"physical"}build(t){let e;if(t.define("STANDARD"),t.requires.lights=!0,t.extensions.derivatives=!0,t.extensions.shaderTextureLOD=!0,t.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(t,"v3",{cache:"position"}):void 0;t.mergeUniform({frameIndex:xm.frameIndex}),t.mergeUniform({resolution:xm.resolution}),t.mergeUniform({previousModelViewMatrix:this.previousModelViewMatrix}),t.mergeUniform({previousProjectionMatrix:this.previouseProjectionMatrix}),t.mergeUniform(R.merge([F.fog,F.lights])),F.LTC_1&&(t.uniforms.ltc_1={value:void 0},t.uniforms.ltc_2={value:void 0}),t.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join("\n"));let r=["#include <beginnormal_vertex>","\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\n\t\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#if defined( USE_LAYER_DISPLACE )\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t","#include <normal_vertex>","\n\t\t\t\t#if !defined( USE_LAYER_DISPLACE )\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t#endif /* !USE_LAYER_DISPLACE */\n\t\t\t\t"];n&&r.push(n.code,n.result?"displaced_position = "+n.result+";":""),r.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),r.push("#include <project_vertex>","#include <fog_vertex>","#include <clipping_planes_vertex>","\tvViewPosition = - mvPosition.xyz;","#include <worldpos_vertex>","#include <shadowmap_vertex>"),r.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),e=r.join("\n")}else{t.mergeUniform({penumbraSize:xm.penumbraSize}),t.mergeUniform({frameIndex:xm.frameIndex}),t.mergeUniform({aoMap:xm.aoRenderTarget}),t.mergeUniform({aoEnabled:xm.aoEnabled});let n={gamma:!0};void 0===this.color&&(this.color=new Tf(xl)),this.color.analyze(t,{slot:"color",context:n}),this.roughness.analyze(t),this.metalness.analyze(t);let r=this.occlusion.flow(t,"b",{slot:"occlusion"});this.shadingAlpha.analyze(t),this.shadingBlend.analyze(t),this.afterColor&&this.afterColor.analyze(t,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(t),this.reflectivity&&this.reflectivity.analyze(t);let i=this.color.flow(t,"c",{slot:"color",context:n}),a=this.roughness.flow(t,"f"),s=this.metalness.flow(t,"f"),o=this.shadingAlpha.flow(t,"f"),l=this.shadingBlend.flow(t,"i"),h=this.afterColor?this.afterColor.flow(t,"c",{slot:"afterColor"}):void 0,d=this.alpha?this.alpha.flow(t,"f"):void 0,c=this.alphaOverride?this.alphaOverride.flow(t,"f"):void 0,u=this.reflectivity?this.reflectivity.flow(t,"f"):void 0;t.requires.transparent=void 0!==d,t.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","uniform float penumbraSize[5];","uniform sampler2D aoMap;","uniform bool aoEnabled;","#include <normal_pars_fragment>","#include <dithering_pars_fragment>","#include <fog_pars_fragment>","#include <bsdfs>","#include <lights_pars_begin>","#include <lights_physical_pars_fragment>","#include <shadowmap_pars_fragment>"].join("\n"));let p=["#include <clipping_planes_fragment>","\t#include <normal_fragment_begin>","\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx,viewdy));\n\t\t\t\tif (dot(normal, faceNormal) < 0.0) {\n\t\t\t\t\tnormal *= -1.0;\n\t\t\t\t}\n\t\t\t\t","\tPhysicalMaterial material;","\tmaterial.diffuseColor = vec3( 1.0 );"];if(this.bumpMap){t.include(Am.dHdxy),t.include(Am.perturbNormalArb);let e=this.bumpMap.texture.flow(t,"t"),n=this.bumpMap.flow(t,"v3"),r=this.bumpMapIntensity?this.bumpMapIntensity.flow(t,"f").result:"1.0",i="";i=4===this.bumpMap.projection.value?`\n\t\t\t\t\tvec3 bumpNormal = vec3(0.0);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs0;\n\t\t\t\t\t\tvec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs1;\n\t\t\t\t\t\tvec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs2;\n\t\t\t\t\t\tvec3 weights = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_triplanarWeights;\n\n\t\t\t\t\t\tvec2 grad0 = dHdxy(${e.result}, uv0, ${r});\n\t\t\t\t\t\tvec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);\n\n\t\t\t\t\t\tvec2 grad1 = dHdxy(${e.result}, uv1, ${r});\n\t\t\t\t\t\tvec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);\n\n\t\t\t\t\t\tvec2 grad2 = dHdxy(${e.result}, uv2, ${r});\n\t\t\t\t\t\tvec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);\n\t\t\t\t\t\t\n\t\t\t\t\t\tbumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;\n\t\t\t\t\t\tbumpNormal = normalize(bumpNormal);\n\t\t\t\t\t}\n\n\t\t\t\t\tnormal = bumpNormal;\n\t\t\t\t\t`:`\n\t\t\t\t\tvec2 bumpMapCachedUv = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs;\n\t\t\t\t\tvec2 grad = dHdxy(${e.result}, bumpMapCachedUv, ${r});\n\t\t\t\t\tnormal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );\n\t\t\t\t\t`,p.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates\n\t\t\t\t\t${n.result};\n\t\t\t\t\t${i}\n\t\t\t\t\t`)}if(p.push(i.code,"\tvec3 diffuseColor = "+i.result+";","\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",s.code,"\tfloat metalnessFactor = "+s.result+";"),this.roughnessMap){let e=this.roughnessMap.texture.flow(t,"t"),n=this.roughnessMap.flow(t,"v3"),r="";r=4===this.roughnessMap.projection.value?`\n\t\t\t\t\tfloat roughnessChange = 1.0;\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 uv0 = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_writeUvs0;\n\t\t\t\t\t\tvec2 uv1 = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_writeUvs1;\n\t\t\t\t\t\tvec2 uv2 = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_writeUvs2;\n\t\t\t\t\t\tvec3 weights = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_triplanarWeights;\n\n\t\t\t\t\t\tfloat r0 = luminance(texture(${e.result}, uv0).rgb) * roughnessScale;\n\t\t\t\t\t\tfloat r1 = luminance(texture(${e.result}, uv1).rgb) * roughnessScale;\n\t\t\t\t\t\tfloat r2 = luminance(texture(${e.result}, uv2).rgb) * roughnessScale;\n\n\t\t\t\t\t\troughnessChange = (r0 * weights.z + r1 * weights.x + r2 * weights.y);\n\t\t\t\t\t}\n\t\t\t\t\tfloat roughnessFactor = roughnessChange * ${a.result};\n\t\t\t\t\t`:`\n\t\t\t\t\tvec2 roughnessMapCachedUv = g${this.roughnessMap.uuid.toString().replace(/-/g,"")}_writeUvs;\n\n\t\t\t\t\tvec4 vals = texture(${e.result},  roughnessMapCachedUv);\n\t\t\t\t\tfloat roughnessFactor = luminance(vals.rgb) * ${a.result};\n\t\t\t\t\t`,p.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates\n\t\t\t\t\t${n.result};\n\n\t\t\t\t\tconst float roughnessScale = 1.0;\n\n\t\t\t\t\t${r}\n\t\t\t\t`)}else p.push(a.code,"\tfloat roughnessFactor = "+a.result+";");d&&p.push(d.code,"#ifdef ALPHATEST","\tif ( "+d.result+" <= ALPHATEST ) discard;","#endif"),p.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"),p.push("material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );","material.roughness = max( roughnessFactor, 0.0525 );","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"),u?p.push(u.code,"material.specularColor = mix( vec3( 0.16 * pow2( "+u.result+" ) ), diffuseColor, metalnessFactor );"):p.push("material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"),p.push("#include <lights_fragment_begin>"),p.push("#include <lights_fragment_end>"),p.push("vec3 ao = aoEnabled && "+r.result+" ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);","vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;");let f="1.0";this.mask&&(this.mask.analyze(t),f=`luminance(${this.mask.flow(t,"v3").result})`),p.push(`\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * ${o.result} * ${f} * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, ${o.result} * ${f}, ${l.result} );\n\t\t\t\t\t\n\t\t\t\t\toutgoingLight *= ao;\n\t\t\t\t}\n\t\t\t\t`),h&&p.push(h.code,`outgoingLight = spe_blend(outgoingLight, ${h.result}, 1.0, SPE_BLENDING_NORMAL);`),d?p.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${d.result} );`):p.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),c&&p.push(`gl_FragColor.a *= ${c.result};`),p.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),e=p.join("\n")}return e}},Cm=class extends Fp{constructor(){super("toon"),this.nodeType="Toon",this.color=new Tf(xl),this.specular=new Tf(1118481),this.shininess=new df(30),this.previousModelViewMatrix=new Uf,this.previouseProjectionMatrix=new Uf,this.shadingAlpha=new df(1),this.shadingBlend=new zf(0)}get category(){return"toon"}build(t){let e;if(t.define("TOON"),t.requires.lights=!0,t.extensions.derivatives=!0,t.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(t,"v3",{cache:"position"}):void 0;t.mergeUniform({frameIndex:xm.frameIndex}),t.mergeUniform({resolution:xm.resolution}),t.mergeUniform({previousModelViewMatrix:this.previousModelViewMatrix}),t.mergeUniform({previousProjectionMatrix:this.previouseProjectionMatrix}),t.mergeUniform(R.merge([F.fog,F.lights])),t.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join("\n"));let r=["#include <beginnormal_vertex>","\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\n\t\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#endif\n\n\t\t\t\tvec3 displaced_position = position;\n\t\t\t\tvec3 displaced_normal = normal;\n\n\t\t\t\t#ifdef USE_LAYER_DISPLACE\n\t\t\t\t\tvec3 transformed;\n\t\t\t\t\tvec3 transformedNormal;\n\t\t\t\t#endif\n\t\t\t\t","#include <normal_vertex>","\n\t\t\t\t#ifndef USE_LAYER_DISPLACE\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t#endif\n\t\t\t\t"];n&&r.push(n.code,n.result?"displaced_position = "+n.result+";":""),r.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),r.push("\t#include <project_vertex>","\t#include <fog_vertex>","\t#include <clipping_planes_vertex>","\tvViewPosition = - mvPosition.xyz;","\t#include <worldpos_vertex>","\t#include <shadowmap_vertex>","\t#include <fog_vertex>"),r.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),e=r.join("\n")}else{t.mergeUniform({penumbraSize:xm.penumbraSize}),t.mergeUniform({frameIndex:xm.frameIndex}),t.mergeUniform({aoMap:xm.aoRenderTarget}),t.mergeUniform({aoEnabled:xm.aoEnabled}),void 0===this.color&&(this.color=new Tf(xl)),this.color.analyze(t,{slot:"color"}),this.specular.analyze(t),this.shininess.analyze(t),this.shadingAlpha.analyze(t),this.shadingBlend.analyze(t),this.afterColor&&this.afterColor.analyze(t,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(t);let n=this.color.flow(t,"c",{slot:"color"}),r=this.specular.flow(t,"c"),i=this.shininess.flow(t,"f"),a=this.shadingAlpha.flow(t,"f"),s=this.shadingBlend.flow(t,"i"),o=this.afterColor?this.afterColor.flow(t,"c",{slot:"afterColor"}):void 0,l=this.alpha?this.alpha.flow(t,"f"):void 0,h=this.alphaOverride?this.alphaOverride.flow(t,"f"):void 0;t.requires.transparent=void 0!==l,t.addParsCode(["uniform float penumbraSize[5];","uniform sampler2D aoMap;","uniform bool aoEnabled;","varying vec3 vWPosition;","#include <normal_pars_fragment>","#include <gradientmap_pars_fragment>","#include <fog_pars_fragment>","#include <bsdfs>","#include <lights_pars_begin>","#include <dithering_pars_fragment>","\n\t\t\t\t\tvarying vec3 vViewPosition;\n\t\t\t\t\tstruct ToonMaterial {\n\t\t\t\t\t\tvec3\tdiffuseColor;\n\t\t\t\t\t\tvec3\tspecularColor;\n\t\t\t\t\t\tfloat\tspecularShininess;\n\t\t\t\t\t\tfloat\tspecularStrength;\n\t\t\t\t\t};\n\t\t\t\t\tvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\t\t\t\t\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t\t\t\n\t\t\t\t\t\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\t\t\t\t\t\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n\t\t\t\t\t}\n\t\t\t\t\tvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\t\t\t\t\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\t\t\t\t\t}\n\t\t\t\t\t#define RE_Direct\t\t\t\tRE_Direct_Toon\n\t\t\t\t\t#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n\t\t\t\t\t#define Material_LightProbeLOD( material )\t(0)\n\t\t\t\t\t","#include <shadowmap_pars_fragment>","#include <bumpmap_pars_fragment>","#include <normalmap_pars_fragment>"].join("\n"));let d=["#include <normal_fragment_begin>","\n\t\t\t\t// NOTE: gl_FrontFacing alternative using face normal estimation.\n\t\t\t\tvec3 viewdx = dFdx(vViewPosition);\n\t\t\t\tvec3 viewdy = dFdy(vViewPosition);\n\t\t\t\tvec3 faceNormal = normalize(cross(viewdx,viewdy));\n\t\t\t\tif (dot(normal, faceNormal) < 0.0) {\n\t\t\t\t\tnormal *= -1.0;\n\t\t\t\t}\n\t\t\t\t","\tToonMaterial material;"];if(this.bumpMap){t.include(Am.dHdxy),t.include(Am.perturbNormalArb);let e=this.bumpMap.texture.flow(t,"t"),n=this.bumpMap.flow(t,"v3"),r=this.bumpMapIntensity?this.bumpMapIntensity.flow(t,"f").result:"1.0",i="";i=4===this.bumpMap.projection.value?`\n\t\t\t\t\tvec3 bumpNormal = vec3(0.0);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs0;\n\t\t\t\t\t\tvec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs1;\n\t\t\t\t\t\tvec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs2;\n\t\t\t\t\t\tvec3 weights = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_triplanarWeights;\n\n\t\t\t\t\t\tvec2 grad0 = dHdxy(${e.result}, uv0, ${r});\n\t\t\t\t\t\tvec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);\n\n\t\t\t\t\t\tvec2 grad1 = dHdxy(${e.result}, uv1, ${r});\n\t\t\t\t\t\tvec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);\n\n\t\t\t\t\t\tvec2 grad2 = dHdxy(${e.result}, uv2, ${r});\n\t\t\t\t\t\tvec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);\n\t\t\t\t\t\t\n\t\t\t\t\t\tbumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;\n\t\t\t\t\t\tbumpNormal = normalize(bumpNormal);\n\t\t\t\t\t}\n\n\t\t\t\t\tnormal = bumpNormal;\n\t\t\t\t\t`:`\n\t\t\t\t\tvec2 bumpMapCachedUv = g${this.bumpMap.uuid.toString().replace(/-/g,"")}_writeUvs;\n\t\t\t\t\tvec2 grad = dHdxy(${e.result}, bumpMapCachedUv, ${r});\n\t\t\t\t\tnormal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );\n\t\t\t\t\t`,d.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates\n\t\t\t\t\t${n.result};\n\t\t\t\t\t${i}\n\t\t\t\t\t`)}d.push(n.code,"\tvec3 diffuseColor = "+n.result+";","\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",r.code,"\tvec3 specular = "+r.result+";",i.code,"\tfloat shininess = max( 0.0001, "+i.result+" );","\tfloat specularStrength = 1.0;"),l&&d.push(l.code,"#ifdef ALPHATEST","if ( "+l.result+" <= ALPHATEST ) discard;","#endif"),d.push("material.diffuseColor = diffuseColor;"),d.push("material.specularColor = specular;","material.specularShininess = shininess;","material.specularStrength = specularStrength;","#include <lights_fragment_begin>","#include <lights_fragment_end>"),d.push("vec3 ao = aoEnabled ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);","vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * ao) + reflectedLight.directSpecular;");let c="1.0";this.mask&&(this.mask.analyze(t),c=`luminance(${this.mask.flow(t,"v3").result})`),d.push(`\n\t\t\t\tif (outgoingLight != diffuseColor) {\n\t\t\t\t\tfloat lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n\t\t\t\t\taccumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * ${c} * lightAccu;\n\t\t\t\t\toutgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result} * ${c}, ${s.result} );\n\t\t\t\t}\n\t\t\t\t`),o&&d.push(o.code,`outgoingLight = spe_blend(outgoingLight, ${o.result}, 1.0, SPE_BLENDING_NORMAL);`),l?d.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${l.result} );`):d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),h&&d.push(`gl_FragColor.a *= ${h.result};`),d.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),e=d.join("\n")}return e}},Pm=class{constructor(t=1e4){this.timeout=t,this.cache=new Map,this.head={data:null,time:0,src:null,next:null,prev:null},this.tail={data:null,time:1/0,src:null,next:null,prev:null},this.hasClean=!1,this.head.next=this.tail,this.tail.prev=this.head}log(...t){}remove(t){let e=this.cache.get(t);e&&(this.dispose(t,e.data),this.cache.delete(t),e.prev.next=e.next,e.next.prev=e.prev)}scheduleCleanup(){this.hasClean||(this.log("scheduled cleanup"),this.hasClean=!0,setTimeout((()=>{this.hasClean=!1,this.log("cleaning");let t=Date.now(),e=this.head.next;for(;e.time<t-this.timeout;)this.dispose(e.src,e.data),this.cache.delete(e.src),e=e.next,e.prev=this.head,this.head.next=e;this.head.next!==this.tail?this.scheduleCleanup():this.log("no more cleanup")}),this.timeout+1e3))}has(t){var e;return null==(e=this.cache.get(t))?void 0:e.data}load(t){let e=Date.now(),n=this.cache.get(t);return void 0===n?(n={data:this.create(t),src:t,time:e,next:null,prev:null},this.cache.set(t,n)):(n.time=e,n.prev.next=n.next,n.next.prev=n.prev),n.prev=this.tail.prev,n.next=this.tail,this.tail.prev.next=n,this.tail.prev=n,this.scheduleCleanup(),n.data}},Dm=class extends Pm{create(t){return URL.createObjectURL(new Blob([t]))}dispose(t,e){URL.revokeObjectURL(e)}};var Tm=class{constructor(t,e){this.data=t,this.cache=e,this.refCount=0}deref(){this.refCount,this.refCount-=1,0===this.refCount&&(this.cache.remove(this),this.dispose())}dispose(){this.refCount,0}},zm=class{constructor(){this.cache=new Map}remove(t){this.cache.delete(t.data),0}load(t){let e=this.cache.get(t);return void 0===e&&(e=this.create(t),this.cache.set(t,e)),e.refCount+=1,e}},Em=class extends Tm{constructor(t,e){super(t,e.imageHolderCache),this.data=t,this.shared=e,this.loaded=!1,this.isVideo=!1,this.isVideo="video"===t.type,this.updateSrc(t.data)}async updateSrc(t){if(typeof document>"u")return;this.disposeTextures(),this.loaded=!1;let e=()=>{this.loaded=!0;let t=[1e3,1001,1002];for(let e of t){let t=this[e];t&&(t.image=this.img,t.needsUpdate=!0)}this.shared.requestRender()};if(this.isVideo){if(this.img=document.createElement("video"),this.img.preload="auto",this.img.playsInline=!0,this.img.currentTime=.01,"string"!=typeof t){var n=new FileReader;let e;n.readAsDataURL(new Blob([t],{type:"video/mp4"})),await new Promise((t=>{n.onloadend=n=>{var r;e=null==(r=n.target)?void 0:r.result,t(null)}})),this.img.src=e}else this.img.src=t;this.img.onloadeddata=()=>{e()}}else this.img=new Image,this.img.src=function(t){return"string"==typeof t?t:(wm||(wm=new Dm),wm.load(t))}(t),this.img.onload=e}getTexture(t){let e=this[t];if(e)return e;{let e;return e=this.isVideo?new V(this.img,void 0,t,t):new A(this.img,void 0,t,t),this.loaded&&(e.needsUpdate=!0),this[t]=e,e}}disposeTextures(){var t,e,n;null==(t=this[1e3])||t.dispose(),this[1e3]=void 0,null==(e=this[1001])||e.dispose(),this[1001]=void 0,null==(n=this[1002])||n.dispose(),this[1002]=void 0}dispose(){super.dispose(),this.disposeTextures()}},Lm=class extends Em{};function Im(t,e){return e.color(t)}function Nm(t,e){switch(t.type){case"fresnel":return function(t,e){let{bias:n,scale:r,intensity:i,factor:a,color:s}=t;return{...Bm(t,e),color:Im(s,e),bias:n,scale:r,intensity:i,factor:a}}(t,e);case"gradient":return function(t,e){let{gradientType:n,smooth:r,colors:i,steps:a,angle:s,offset:o,morph:h}=t;return{...Bm(t,e),gradientType:n,smooth:r,colors:i.map((t=>new p(t[0],t[1],t[2],t[3]))),num:i.length,steps:a,offset:new l(...o),morph:new l(...h),angle:s}}(t,e);case"depth":return function(t,e){let{gradientType:n,near:r,far:i,isVector:a,isWorldSpace:s,origin:l,direction:h,colors:d,steps:c,smooth:u}=t;return{...Bm(t,e),gradientType:n,near:r,far:i,isVector:a,isWorldSpace:s,origin:new o(...l),direction:h?new o(...h):new o(1,0,0),colors:d.map((t=>void 0!==t?new p(t[0],t[1],t[2],t[3]):new p(0,0,0,0))),steps:c.slice(0,d.length),smooth:u}}(t,e);case"normal":return function(t,e){let{cnormal:n}=t;return{...Bm(t,e),cnormal:new o(n[0],n[1],n[2])}}(t,e);case"noise":return function(t,e){return{...Bm(t,e),scale:t.scale,move:t.move,fA:new l(...t.fA),fB:new l(...t.fB),size:new o(...t.size),distortion:new l(...t.distortion),colorA:Im(t.colorA,e),colorB:Im(t.colorB,e),colorC:Im(t.colorC,e),colorD:Im(t.colorD,e),noiseType:t.noiseType,voronoiStyle:t.voronoiStyle,highCut:t.highCut,lowCut:t.lowCut,smoothness:t.smoothness,seed:t.seed,quality:t.quality}}(t,e);case"rainbow":return function(t,e){return{...Bm(t,e),filmThickness:t.filmThickness,movement:t.movement,wavelengths:new o(...t.wavelengths),noiseStrength:t.noiseStrength,noiseScale:t.noiseScale,offset:new o(...t.offset)}}(t,e);case"toon":return function(t,e){return{...Bm(t,e),positioning:t.positioning,colors:t.colors.map((t=>new p(t[0],t[1],t[2],t[3]))),num:t.colors.length,steps:t.steps,source:new o(...t.source),isWorldSpace:t.isWorldSpace,noiseStrength:t.noiseStrength,noiseScale:t.noiseScale,shadowColor:Im(t.shadowColor,e),offset:new o(...t.offset)}}(t,e);case"outline":return function(t,e){return{...Bm(t,e),outlineColor:Im(t.outlineColor,e),contourColor:Im(t.contourColor,e),outlineWidth:t.outlineWidth,contourWidth:t.contourWidth,outlineThreshold:t.outlineThreshold,contourThreshold:t.contourThreshold,outlineSmoothing:t.outlineSmoothing,contourFrequency:t.contourFrequency,contourDirection:new o(...t.contourDirection),positionalLines:t.positionalLines,compensation:t.compensation}}(t,e);case"transmission":return function(t,e){return{...Bm(t,e),thickness:t.thickness,ior:t.ior,roughness:t.roughness}}(t,e);case"color":return function(t,e){return{...Bm(t,e),color:Im(t.color,e)}}(t,e);case"pattern":return function(t,e){return{...Bm(t,e),style:t.style,projection:t.projection,axis:t.axis,blending:t.blending,offset:new l(...t.offset),colorA:Im(t.colorA,e),colorB:Im(t.colorB,e),frequency:new l(...t.frequency),size:t.size,variation:t.variation,smoothness:t.smoothness,zigzag:t.zigzag,rotation:t.rotation,vertical:new l(...t.vertical),horizontal:new l(...t.horizontal),sides:t.sides}}(t,e)}}function jm(t){return{type:t.type}}function Bm(t,e){let{alpha:n,mode:r,isMask:i}=t,a="string"==typeof n?(Number(e.getVariable(n))??100)/100:n;return{...jm(t),alpha:a,mode:r,isMask:i}}var Um=class extends $p{},km={noise:["noiseType"],texture:["projection","axis","side"],video:["projection","axis","side"],displace:["noiseType"],light:["roughnessMap","bumpMap"],depth:["smooth","isWorldSpace","gradientType","isVector"],pattern:["style","projection","axis"]},Rm={depth:["colors"]};function Fm(t,e,n){var r,i;if("isMask"===e)return!0;let a=km[t.type],s=Rm[t.type];if(void 0!==s){let a=t.color;if(s.includes(e)){let t=null==(i=null==(r=a[e])?void 0:r.value)?void 0:i.length;if(void 0!==t&&t!==n.length)return!0}}return void 0!==a&&a.includes(e)}function Vm(t,e,n){let r=n.uniforms[`f${n.id}_texture`];if(!r)return!1;let i=t;if("image"in i){let t=i.image,n=e.image(t),a=r;a.image instanceof Lm||a.image.deref(),a.image=n}if("video"in i){let t=i.video,n=e.video(t),a=r;a.image instanceof Lm||a.image.deref(),a.image=n}if("wrapping"in i){r.wrap=i.wrapping}if("repeat"in i||"offset"in i){let t="mat",e=n.uniforms[`f${n.id}_${t}`];"repeat"in i&&(e.repeat=i.repeat),"offset"in i&&(e.offset=i.offset),e.updateMatrix()}return!1}var Gm=(t,e,n)=>("string"==typeof t?Math.max(0,Math.min(1,Number(e.getVariable(t,n)??100)/100)):t)??1,Hm=class{constructor(t,e,n,r,i){this.id=t,this.uuid=e,this.data=n,this.uniforms={};for(let a in r)this.uniforms[`f${this.id}_${a}`]=r[a];for(let a in n)Ym(a,this,n,i)}get type(){return this.data.type}static create(t,e,n,r){if("light"===n.type)return $m.createLigherLayer(t,e,n,r);if("texture"===n.type||"video"===n.type){let i="texture"===n.type?r.image(n.texture.image):r.video(n.texture.video),a=new jf(i,n.texture.wrapping),s=new Nf(i),o=new Rf(n.texture.repeat,n.texture.offset),h=new df(n.crop?1:0),d=new zf(n.projection??0),c=new zf(["x","y","z"].indexOf(n.axis)??0),u=new zf(n.side??0),p=new Wp(n.size?new l(n.size[0],n.size[1]):new l(100,100)),f=new df(n.blending??0),m=new df(Gm(n.alpha,r)),g=new zf(n.mode??0),v=new Ef(n.isMask??!1),y=new Xf(a,s,h,d,c,u,p,f,o,m,g,v),b=new lf(y.calpha,"f");return new Wm(t,e,n,{texture:a,textureSize:s,crop:h,projection:d,axis:c,side:u,size:p,blending:f,mat:o,alpha:m,mode:g,isMask:v},y,g,b,v,r)}if("matcap"===n.type){let i=r.image(n.texture.image),a=new jf(i,n.texture.wrapping),s=new df(Gm(n.alpha,r)),o=new zf(n.mode??0),l=new Ef(n.isMask??!1),h=new em(a,s,o,l),d=new lf(h.calpha,"f");return new Wm(t,e,n,{texture:a,alpha:s,mode:o,isMask:l},h,o,d,l,r)}if("displace"===n.type){if("noise"===n.displacementType){let i=new qp(new o(...n.offset)),a=new df(n.scale??10),s=new df(n.intensity??8),l=new df(n.movement??1),h=new zf(n.noiseType??0),d=new zf(n.voronoiStyle??0),c=new df(n.smoothness??.5),u=new df(n.seed??0),p=new df(n.highCut??1),f=new df(n.lowCut??0),m=new zf(n.quality??1),g=new bm(s,l,i,d,c,u,p,f,m,a,h);return new qm(t,e,n,{offset:i,scale:a,intensity:s,movement:l,noiseType:h,voronoiStyle:d,smoothness:c,seed:u,highCut:p,lowCut:f,quality:m},g,r)}throw new Error}return function(t,e,n,r){let i=Nm(n,r);return function(t,e,n,r,i){switch(t.type){case"color":{let a=new Tf(r.color??xl),s=Xm(r),o=new Hf(a,s.alpha),l=new lf(o.calpha,"f");return new Wm(e,n,t,{color:a,...s},o,s.mode,l,s.isMask,i)}case"fresnel":{let a=new Tf(r.color??16777215),s=new df(r.bias??.1),o=new df(r.scale??1),l=new df(r.intensity??2),h=new df(r.factor??1),d=Xm(r),c=new Zf(a,s,o,l,h,d.alpha,d.mode,d.isMask),u=new lf(c.calpha,"f");return new Wm(e,n,t,{color:a,bias:s,scale:o,intensity:l,factor:h,...d},c,d.mode,u,d.isMask,i)}case"rainbow":{let a=new df(r.filmThickness??30),s=new df(r.movement??0),l=new qp(r.wavelengths??new o(0,0,0)),h=new df(r.noiseStrength??0),d=new df(r.noiseScale??1),c=new qp(r.offset??new o(0,0,0)),u=Xm(r),p=new cm(a,s,l,h,d,c,u.alpha,u.isMask),f=new lf(p.calpha,"f");return new Wm(e,n,t,{filmThickness:a,movement:s,wavelengths:l,noiseStrength:h,noiseScale:d,offset:c,...u},p,u.mode,f,u.isMask,i)}case"transmission":{let a=new df(r.thickness??10),s=new df(r.ior??1.5),o=new df(r.roughness??.5),l=xm.transmissionSize,h=xm.transmissionRenderTarget,d=xm.transmissionRenderTargetDepth,c=window.innerWidth,u=window.innerHeight,p=c>=u?new Wp(u/c,1):new Wp(1,c/u),f=Xm(r),m=new gm(a,s,o,l,h,d,p,f.alpha),g=new lf(m.calpha,"f");return new Wm(e,n,t,{thickness:a,ior:s,roughness:o,aspectRatio:p,...f},m,f.mode,g,f.isMask,i)}case"toon":{let a,s,l=new zf(r.positioning??0);r.colors?a=new Ff(r.colors.length,r.colors):(a=new Ff(10,new p(0,0,0,1)),a.value[1]=new p(1,1,1,1)),r.steps?s=new Lf(r.steps.length,r.steps):(s=new Lf(10,1),s.value[0]=0);let h=new qp(r.source??new o(0,0,0)),d=new Ef(r.isWorldSpace??!0),c=new df(r.noiseStrength??0),u=new df(r.noiseScale??1),f=new Xp(r.shadowColor),m=new qp(r.offset??new o(0,0,0)),g=Xm(r),v=new pm(l,a,s,h,d,c,u,f,m,g.alpha),y=new lf(v.calpha,"f");return new Wm(e,n,t,{positioning:l,colors:a,steps:s,source:h,isWorldSpace:d,noiseStrength:c,noiseScale:u,shadowColor:f,offset:m,...g},v,g.mode,y,g.isMask,i)}case"outline":{let a=new Tf(r.outlineColor??16777215),s=new Tf(r.contourColor??16777215),l=new df(r.outlineWidth??.1),h=new df(r.contourWidth??.1),d=new df(r.outlineThreshold??.1),c=new df(r.contourThreshold??.1),u=new df(r.outlineSmoothing??.1),p=new df(r.contourFrequency??.1),f=new qp(r.contourDirection??new o(0,1,0)),m=new Ef(r.positionalLines??!1),g=new Ef(r.compensation??!0),v=xm.normalRenderTarget,y=xm.normalRenderTargetDepth,b=xm.pixelRatioNode,x=xm.resolution,w=Xm(r),_=new om(a,s,l,h,d,c,u,p,f,m,g,x,v,y,b,w.alpha),S=new lf(_.calpha,"f");return new Wm(e,n,t,{outlineColor:a,contourColor:s,outlineWidth:l,contourWidth:h,outlineThreshold:d,contourThreshold:c,outlineSmoothing:u,contourFrequency:p,contourDirection:f,positionalLines:m,compensation:g,...w},_,w.mode,S,w.isMask,i)}case"depth":{let a,s,l=new zf(r.gradientType??0),h=new Ef(r.smooth??!1),d=new df(r.near??50),c=new df(r.far??200),u=new df(r.isVector??1),f=new df(r.isWorldSpace??0),m=new qp(r.origin??new o),g=new qp(r.direction??new o);r.colors?a=new Ff(r.colors.length,r.colors):(a=new Ff(2,new p(0,0,0,1)),a.value[1]=new p(1,1,1,1)),r.steps?s=new Lf(r.steps.length,r.steps):(s=new Lf(2,1),s.value[0]=0);let v=Xm(r),y=new Kf(l,h,d,c,u,f,m,g,a,s,v.alpha,v.isMask),b=new lf(y.calpha,"f");return new Wm(e,n,t,{gradientType:l,smooth:h,near:d,far:c,isVector:u,isWorldSpace:f,origin:m,direction:g,colors:a,steps:s,...v},y,v.mode,b,v.isMask,i)}case"noise":{let a=new df(r.scale??1),s=new qp(r.size??new o(100,100,100)),h=new df(r.move??1),d=new Wp(r.fA??new l(1.7,9.2)),c=new Wp(r.fB??new l(8.3,2.8)),u=new Wp(r.distortion??new l(1,1)),p=new Xp(r.colorA),f=new Xp(r.colorB),m=new Xp(r.colorC),g=new Xp(r.colorD),v=new zf(r.noiseType??0),y=new zf(r.voronoiStyle??0),b=new df(r.highCut??1),x=new df(r.lowCut??0),w=new df(r.smoothness??.5),_=new df(r.seed??.5),S=new zf(r.quality??1),A=Xm(r),O=new am(a,s,h,d,c,u,p,f,m,g,A.alpha,v,A.isMask,y,b,x,w,_,S),M=new lf(O.calpha,"f");return new Wm(e,n,t,{scale:a,size:s,move:h,fA:d,fB:c,distortion:u,colorA:p,colorB:f,colorC:m,colorD:g,noiseType:v,...A,voronoiStyle:y,highCut:b,lowCut:x,smoothness:w,seed:_,quality:S},O,A.mode,M,A.isMask,i)}case"normal":{let a=new qp(r.cnormal??new o(1,1,1)),s=Xm(r),l=new qf(a,s.alpha),h=new lf(l.calpha,"f");return new Wm(e,n,t,{cnormal:a,...s},l,s.mode,h,s.isMask,i)}case"gradient":{let a,s,o=new zf(r.gradientType??0),h=new Ef(r.smooth??!1);r.colors?a=new Ff(r.colors.length,r.colors):(a=new Ff(10,new p(0,0,0,1)),a.value[1]=new p(1,1,1,1)),r.steps?s=new Lf(r.steps.length,r.steps):(s=new Lf(10,1),s.value[0]=0);let d=new Wp(r.offset??new l(0,0)),c=new Wp(r.morph??new l(0,0)),u=new df(r.angle??0),f=Xm(r),m=new Jf(o,h,a,s,d,c,u,f.alpha,f.isMask),g=new lf(m.calpha,"f");return new Wm(e,n,t,{gradientType:o,smooth:h,colors:a,steps:s,offset:d,morph:c,angle:u,...f},m,f.mode,g,f.isMask,i)}case"pattern":{let a=new zf(r.style??0),s=new zf(r.projection??0),o=new zf(["x","y","z"].indexOf(r.axis)??0),h=new df(r.blending??0),d=new Wp(r.offset??new l(0,0)),c=new Xp(r.colorA),u=new Xp(r.colorB),p=new Wp(r.frequency??new l(10,10)),f=new df(r.size??.5),m=new df(r.variation??0),g=new df(r.smoothness??.5),v=new df(r.zigzag??0),y=new df(r.rotation??0),b=new Wp(r.vertical??new l(0,1)),x=new Wp(r.horizontal??new l(0,1)),w=new zf(r.sides??6),_=Xm(r),S=new hm(a,s,o,h,d,c,u,p,f,m,g,v,y,b,x,w,_.alpha,_.isMask),A=new lf(S.calpha,"f");return new Wm(e,n,t,{style:a,projection:s,axis:o,blending:h,offset:d,colorA:c,colorB:u,frequency:p,size:f,variation:m,smoothness:g,zigzag:v,rotation:y,vertical:b,horizontal:x,sides:w,..._},S,_.mode,A,_.isMask,i)}default:{let a=new Tf(1,0,0,1),s=Xm(r),o=new Hf(a,s.alpha),l=new lf(o.calpha,"f");return new Wm(e,n,t,{color:a,...s},o,s.mode,l,s.isMask,i)}}}(n,t,e,i,r)}(t,e,n,r)}updateByOp(t,e,n){let r=t;if(void 0===r.path[0]){if(0===r.type)return"type"in r.props||"category"in r.props||"visible"in r.props?(n.scene.markNeedsUpdateRendererDirty(),!0):function(t,e,n,r){let i=!1;for(let[a,s]of Object.entries(t)){if("bumpMap"===a||"roughnessMap"===a){i=!0;continue}if(!a||void 0===s)continue;if(Ym(a,n,r,e)){"visible"===a&&"light"===n.type&&(i=!0);continue}n.visible=r.visible;let t=n.uniforms[`f${n.id}_${a}`];if(t&&!(t instanceof If))switch(i=i||Fm(n,a,s),t.constructor){case Tf:if("string"==typeof s){let n=e.getColor(s);n&&(t.value=n);break}{let e=s;t.value instanceof Um?t.value=new $p(e.r,e.g,e.b,e.a):t.setRGBA(e);break}case Xp:if("string"==typeof s){let n=e.getColor(s);n&&(t.value=n);break}{let e=s;t.value instanceof Um?t.value=new $p(e.r,e.g,e.b,e.a):t.value.setRGBA(e.r,e.g,e.b,e.a);break}case Wp:{let e=s;t.value.setX(e[0]),t.value.setY(e[1]);break}case qp:{let e=s;t.value.setX(e[0]),t.value.setY(e[1]),t.value.setZ(e[2]);break}case hf:Vm(s,e,n);break;case Ff:t.value=s.map((t=>new p(...t)));break;default:t.value=s}}return i}(r.props,n.shared,this,e)}else if("texture"===r.path[0])return!("texture"in e)&&!("video"in e)||Vm(r.props,n.shared,this);return!1}dispose(){if(function(t){let e=t instanceof Hm?t.type:t;return"texture"===e||"video"===e||"displace_map"===e||"matcap"===e}(this)){let t=this.uniforms[`f${this.id}_texture`];if(!t)return!1;let e=t;e.image instanceof Lm||e.image.deref()}}hasValueByKey(t){return void 0!==this.uniforms[t]}hasValue(t){return this.hasValueByKey(`f${this.id}_${t}`)}setValue(t,e){let n=`f${this.id}_${t}`;this.hasValueByKey(n)&&void 0!==e&&(this.uniforms[n].value=e)}getNode(t){let e=`f${this.id}_${t}`;if(this.hasValueByKey(e))return this.uniforms[e]}getValue(t){let e=`f${this.id}_${t}`;if(this.hasValueByKey(e))return this.uniforms[e].value}getName(t){let e=/f\d+_(.*)/.exec(t);if(e&&e.length>1)return e[1];console.log(`Layer.getName: error ${t}`)}getNames(){let t=[];for(let e in this.uniforms){let n=this.getName(e);n&&t.push(n)}return t}},Wm=class extends Hm{constructor(t,e,n,r,i,a,s,o,l){super(t,e,n,r,l),this.params=r,this.color=i,this.mode=a,this.alpha=s,this.isMask=o}},qm=class extends Hm{constructor(t,e,n,r,i,a){super(t,e,n,r,a),this.position=i}},$m=class extends Hm{constructor(t,e,n,r,i,a){super(t,e,n,i,a),this.node=r}static createLigherLayer(t,e,n,r){let i,a,s=new df(Gm(n.alpha,r)),o=new zf(n.mode),l=new df(n.bumpMapIntensity),h=new df(Gm(n.alphaOverride,r));if(n.visible)if("lambert"===n.category){i=new Sm;let t=new Tf(r.color(n.emissive)??0),e=new Ef(n.occlusion??!0);a={emissive:t,occlusion:e},i.emissive=t,i.occlusion=e}else if("toon"===n.category){i=new Cm;let t=new df(n.shininess??30),e=new Tf(r.color(n.specular)??1118481);a={shininess:t,specular:e},i.shininess=t,i.specular=e}else if("physical"===n.category){i=new Mm;let t=new df(n.roughness??.3),e=new df(n.metalness??0),r=new df(n.reflectivity??.5),s=new Ef(n.occlusion??!0);a={roughness:t,metalness:e,reflectivity:r,occlusion:s},i.roughness=t,i.metalness=e,i.reflectivity=r,i.occlusion=s}else{i=new Om;let t=new df(n.shininess??30),e=new Tf(void 0!==n.specular?r.color(n.specular)??1118481:1118481),s=new Ef(n.occlusion??!0);a={shininess:t,specular:e,occlusion:s},i.shininess=t,i.specular=e,i.occlusion=s}else i=new _m,a={};return i.alpha=new df(1),i.shadingAlpha=s,i.shadingBlend=o,i.bumpMapIntensity=l,i.alphaOverride=h,a.alpha=i.shadingAlpha,a.mode=i.shadingBlend,a.bumpMapIntensity=i.bumpMapIntensity,a.alphaOverride=i.alphaOverride,new $m(t,e,n,i,a,r)}get category(){return this.node.category}};function Xm(t){return{alpha:new df(t.alpha??1),mode:new zf(t.mode??0),isMask:new Ef(t.isMask??!1)}}function Ym(t,e,n,r){if("displace"===n.type&&("intensity"===t||"visible"===t)){let t=e.uniforms[`f${e.id}_intensity`];return t?(t.value=n.intensity*(n.visible?1:0),t):void 0}if("displace"!==n.type&&("alpha"===t||"visible"===t)){let i=e.uniforms[`f${e.id}_alpha`];if(!i)return;if(i.value=Gm(n.alpha,r)*(n.visible?1:0),"outline"===n.type&&"visible"===t){let t=e.uniforms[`f${e.id}_compensation`];t&&(t.value=n.compensation&&n.visible)}return i}}function Km(t,e){let n=0,r=t.layers.find((t=>"light"===t.data.type));if(r){let t=r.data,n=Number(e.getVariable(t.alphaOverride));if(("string"==typeof t.alphaOverride?n/100:t.alphaOverride)<1)return!0}for(let i of t.layers){if("displace"!==i.data.type&&i.data.isMask)return!0;if("displace"!==i.data.type&&"alpha"in i.data&&"light"!==i.data.type&&"fresnel"!==i.data.type&&"texture"!==i.data.type&&"matcap"!==i.data.type&&"rainbow"!==i.data.type&&"outline"!==i.data.type&&"pattern"!==i.data.type){let t=i.data.visible?i.data.alpha:0;if("string"==typeof t&&(t=Math.max(0,Math.min(1,Number(e.getVariable(t)??100)/100))),1===t&&"depth"===i.data.type||"gradient"===i.data.type){for(let e of i.data.colors)if(e[3]<1){t=e[3];break}}else if(1===t&&"noise"===i.data.type){let n=e.color(i.data.colorA).a,r=e.color(i.data.colorB).a,a=e.color(i.data.colorC).a,s=e.color(i.data.colorD).a,o=Math.min(n,Math.min(r,Math.min(a,s)));o<1&&(t=o)}n+=(1-n)*t}}return n<1}var Zm=class extends G{constructor(){super(void 0),this.flatShading=!1,this.needsJitter=!0,this.cacheKey="",this.fog=!0,this.dithering=!0,this.vertexColors=!0,this.transparent=!0}customProgramCacheKey(){return this.cacheKey}},Qm=class extends Zm{constructor(t,e,n,r){super(),this.flatShading=t,this.side=e,this.wireframe=n,this.root=r}updateAfterBuild(){let t=this.root;this.lights=t.lights,this.vertexShader=t.vertexShader,this.fragmentShader=t.fragmentShader,this.defines=t.defines,this.uniforms=t.uniforms,this.extensions=t.extensions,this.transparent=t.transparent,this.cacheKey=t.customProgramCacheKey()+"flat"+this.flatShading+this.side}onBeforeCompile(t,e){this.root.onBeforeCompile(t)}get data(){return this.root.data}get category(){return this.root.category}get hasAO(){return this.root.hasAO}getFlavor(t,e,n){return this.root.getFlavor(t,e,n)}get layers(){return this.root.layers}get fragment(){return this.root.fragment}getLayersOfType(t){return this.root.getLayersOfType(t)}getLayerByUuid(t){return this.root.getLayerByUuid(t)}updateByOp(t,e,n){this.root.updateByOp(t,e,n)}nodeMaterialDispose(){this.root.nodeMaterialDispose()}},Jm=class extends Zm{constructor(t,e,n=!0){super(),this.data=t,this.allowVariableSaves=n,this.layerIdGen=0,this.flavors=[],this.masks={},this.type="NodeMaterial",this.updaters=[],this.reset0(t,e)}get nodeMaterial(){return this}getFlavor(t,e,n){let r=n?6:(t?3:0)+e;if(0===r)return this;void 0===this.flavors&&(this.flavors=[]),r-=1;let i=this.flavors[r];return void 0===i&&(i=new Qm(t,e,n,this),this.flavors[r]=i,i.flatShading=t,i.side=e,i.updateAfterBuild()),i}get fragment(){return this.lightLayer.node}get category(){return this.lightLayer.category}get hasAO(){var t;return(null==(t=this.lightLayer.getNode("occlusion"))?void 0:t.value)??!1}reset(t,e){this.data!==t&&this.reset0(t,e)}reset0(t,e){this.data=t;let n=t.layers??kl.defaultTwoLayerData("phong").layers;try{this.layers=n.map((t=>Hm.create(this.layerIdGen++,t.id,t.data,e.shared)))}catch{this.layers=[]}this.layers.reverse(),this.name=t.name??"Untitled Material",this.onUpdate(e.shared),this.transparent=Km(t,e.shared),this.saveVariableLocations(e)}onVariableUpdate(t,e,n){if("alphaOverride"===t[0])this.transparent=Km(this.data,n.shared),this.lightLayer.setValue("alphaOverride",Math.max(0,Math.min(Number(e)/100,1)));else if("layer"===t[0]){let r=t[1],i=t[2];if(r&&i){let t=this.layers.find((t=>t.uuid===r));(null==t?void 0:t.hasValue(i))&&("alpha"===i?(this.transparent=Km(this.data,n.shared),t.setValue(i,Math.max(0,Math.min(Number(e)/100,1)))):t.setValue(i,e))}}}saveVariableLocations(t){if(!this.allowVariableSaves)return;let e=this.data.layers.find((t=>"light"===t.data.type));e&&t.shared.getVariable(e.data.alphaOverride,["material",this.uuid,"alphaOverride"]),this.data.layers.forEach((e=>{"alpha"in e.data&&"string"==typeof e.data.alpha&&t.shared.getVariable(e.data.alpha,["material",this.uuid,"layer",e.id,"alpha"])}))}getLayersOfType(t){return this.layers.filter((e=>e.type===t))}getLayerByUuid(t){return this.layers.find((e=>e.uuid===t))}onUpdate(t){this.cacheKey=this.computeCacheKey(),this.lightLayer=this.layers.find((t=>t instanceof $m)),void 0===this.lightLayer&&(this.lightLayer=new $m(0,"",{...Ul.defaultData("light","phong"),visible:!1},new _m,{},t)),this.dispose();for(let e of this.flavors)e&&e.dispose();this.applyTextureMaps(),this.applyMasks(),this.blendColors(),this.blendAfterColors(),this.blendPositions()}applyTextureMaps(){let t=this.layers.find((t=>t instanceof $m));if(!t)return;let e=t.data,n=e.bumpMap,r=e.roughnessMap;t.node.bumpMap=void 0,t.node.roughnessMap=void 0;for(let i=0;i<this.layers.length;++i){let e=this.layers[i];e instanceof Wm&&e.color instanceof Xf&&(e.uuid===n&&(t.node.bumpMap=e.color),e.uuid===r&&(t.node.roughnessMap=e.color))}}updateByOp(t,e,n){if(void 0!==e?this.data=e:e=this.data,this.transparent=Km(e,n.shared),"layers"===t.path[0]){this.data=e;let r=n.shared,i=t.path[1];if(void 0===i){if(this.layers.reverse(),4===t.type){let e=Hm.create(this.layerIdGen++,t.id,t.data,n.shared);this.layers.splice(t.localIndex,0,e),n.scene.markNeedsUpdateRendererDirty()}else if(5===t.type)this.layers.splice(t.localIndex,1)[0].dispose(),n.scene.markNeedsUpdateRendererDirty();else if(6===t.type){let e=this.layers.findIndex((e=>e.uuid===t.id)),r=this.layers[e];this.layers.splice(e,1),this.layers.splice(t.localIndex,0,r),n.scene.markNeedsUpdateRendererDirty()}this.layers.reverse(),this.onUpdate(n.shared)}else{0===t.type&&void 0!==t.props.occlusion&&n.scene.markNeedsUpdateRendererDirty();let a=this.layers.find((t=>t.uuid===i));if(a){let s,o=e.layers.data(i);if(0===t.type&&("alpha"in t.props||"alphaOverride"in t.props)&&(s="alpha"in t.props?{...t.props,alpha:Gm(t.props.alpha,r,["material",this.uuid,"layer",i,"alpha"])}:{...t.props,alphaOverride:Gm(t.props.alphaOverride,r,["material",this.uuid,"alphaOverride"])}),a.updateByOp({...t,...s?{props:s}:{},path:t.path.slice(2)},o,n)){let t=Hm.create(this.layerIdGen++,i,o,r);this.layers.splice(this.layers.findIndex((t=>t.uuid===i)),1,t),this.onUpdate(n.shared)}}}}else this.reset(e,n)}applyMasks(){for(let t=0;t<this.layers.length;++t){let e=this.layers[t];e instanceof Wm?e.color.mask=void 0:e instanceof $m&&(e.node.mask=void 0)}for(let t=0;t<this.layers.length;++t){let e=this.layers[t];if(e instanceof Wm&&e.isMask.value&&e.data.visible&&t>0){let n=t-1,r=this.layers[n];r instanceof $m?r.node.mask=new pf(e.color,e.alpha,pf.MUL):r instanceof Wm&&(r.isMask.value||(r.color.mask=new pf(e.color,e.alpha,pf.MUL)))}}}blendColors(){let t=this.layers.findIndex((t=>t instanceof Wm)),e=this.layers.findIndex((t=>t instanceof $m));if(-1!==t&&t<e){let n=this.layers[t].color;for(let r=t+1;r<e;++r){let t=this.layers[r];if(t instanceof Wm){if(t.isMask.value)continue;n=new Vf(n,t.color,t.alpha,t.mode)}}this.fragment.color=n}else this.fragment.color=void 0}blendAfterColors(){let t=new lf("outgoingLight","f"),e=this.layers.findIndex((t=>t instanceof $m));if(this.layers.length>e+1){for(let n=e+1;n<this.layers.length;++n){let e=this.layers[n];if(e instanceof Wm){if(e.isMask.value)continue;t=new Vf(t,e.color,e.alpha,e.mode)}}this.fragment.afterColor=t}else this.fragment.afterColor=void 0}blendPositions(){let t=this.layers.filter((t=>t instanceof qm));if(t.length>0){let e=t[0].position;for(let n=1;n<t.length;++n)t[n]&&(e=new pf(e,t[n].position,pf.ADD),e=new pf(e,new df(.5).setReadonly(!0),pf.MUL));this.fragment.position=e}else this.fragment.position=void 0}getDefines(){return this.defines}getUniforms(){return this.uniforms}getVertexShader(){return this.vertexShader}getFragmentShader(){return this.fragmentShader}onBeforeCompile(t){this.build(),t.defines=this.defines,t.uniforms=this.uniforms,t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.extensionDerivatives=!0===this.extensions.derivatives,t.extensionFragDepth=!0===this.extensions.fragDepth,t.extensionDrawBuffers=!0===this.extensions.drawBuffers,t.extensionShaderTextureLOD=!0===this.extensions.shaderTextureLOD}clampUniformsForPreview(t,e){let n=(t,e,n)=>Math.min(Math.max(t,e),n);for(let r of this.layers)if("displace"===r.type){let i=n(r.uniforms[`f${r.id}_intensity`].value,t,e);r.uniforms[`f${r.id}_intensity`].value=i}}computeCacheKey(){let t="[";for(let{data:e}of this.data.layers)if("light"===e.type)t+=`"${e.visible?e.category.toUpperCase():"Basic"}"`;else{let n=[...(km[e.type]??[]).map((t=>e[t])),...(Rm[e.type]??[]).map((t=>{var n;return(null==(n=e[t])?void 0:n.length)??0}))],r="isMask"in e&&e.isMask,i=`"${e.type}-${e.visible}-${r}"`;n.length?t+=`[${i}, "${n.join('","')}"],`:t+=i}return t=t.slice(0,-1)+"]",t}updateFrame(t){for(let e=0;e<this.updaters.length;++e)t.updateNode(this.updaters[e])}build(){let t=new class{constructor(){this.includes={consts:{},functions:{},structs:{}},this.cache="",this.slot="",this.shader="",this.context={},this.needsJitter=!0,this.getIncludesCode=function(){function t(t,e){return t.deps.length-e.deps.length}return function(e,n){let r=this.getIncludes(e,n);if(!r)return"";let i="";r=r.sort(t);for(let t=0;t<r.length;t++)r[t].src&&(i+=r[t].src+"\n");return i}}(),this.slots=[],this.caches=[],this.contexts=[],this.keywords={},this.nodeData={},this.fragmentVariables={},this.fragmentParsVariables={},this.vertexParsVariables={},this.requires={uv:[],color:[],transparent:!1,irradiance:!1,position:!1,worldPosition:!1,normal:!1,worldNormal:!1,vWorldViewDir:!1,modelMatrix:!1,viewMatrix:!1,projectionMatrix:!1},this.includes={consts:[],functions:[],structs:[]},this.attributes={},this.prefixCode=["#ifdef TEXTURE_LOD_EXT","\t#define texCube(a, b) textureCube(a, b)","\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)","\t#define tex2D(a, b) texture2D(a, b)","\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)","#else","\t#define texCube(a, b) textureCube(a, b)","\t#define texCubeBias(a, b, c) textureCube(a, b, c)","\t#define tex2D(a, b) texture2D(a, b)","\t#define tex2DBias(a, b, c) texture2D(a, b, c)","#endif","\n\t\t\t// NOTE: Include Spline's blending modes. This could be part of BlendNode\n\t\t\t#define SPE_BLENDING_NORMAL 0\n\t\t\t#define SPE_BLENDING_MULTIPLY 1\n\t\t\t#define SPE_BLENDING_SCREEN 2\n\t\t\t#define SPE_BLENDING_OVERLAY 3\n\n\t\t\tvec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\treturn mix( a, a * b, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n\t\t\t\treturn mix( a, tmp, alpha );\n\t\t\t}\n\n\t\t\tvec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n\t\t\t\tvec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n\t\t\t\treturn clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n\t\t\t}\n\n\t\t\tvec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n\t\t\t\tif ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n\t\t\t\telse if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n\t\t\t\treturn vec3( 1.0 );\n\t\t\t}\n\t\t\t","#include <packing>","#include <common>"].join("\n"),this.parsCode={vertex:["float neighbor_offset = 0.0001;",""].join("\n"),fragment:["float accumAlpha = 0.0;","void accumulateAlpha(float alpha) {\n\t\t\t\t\taccumAlpha += (1.0 - accumAlpha) * alpha;\n\t\t\t\t}",""].join("\n")},this.code={vertex:"",fragment:""},this.nodeCode={vertex:"",fragment:""},this.resultCode={vertex:"",fragment:""},this.finalCode={vertex:"",fragment:""},this.inputs={uniforms:{list:[],vertex:[],fragment:[]},arrayUniforms:{list:[],vertex:[],fragment:[]},vars:{varying:[],vertex:[],fragment:[]}},this.defines={},this.uniforms={},this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.updaters=[],this.nodes=[],this.analyzing=!1}build(t,e){this.addVertexParsCode("\nuniform int frameIndex;\nuniform vec2 resolution;\nuniform mat4 previousModelViewMatrix;\nuniform mat4 previousProjectionMatrix;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n"),this.addFragmentParsCode("\nlayout(location = 1) out vec4 gVelocity;\n\nuniform int frameIndex;\nuniform vec2 resolution;\n\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\n\n// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso\nfloat getNoiseInterleavedGradient(vec2 screenPos) {\n    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);\n    return fract(magic.z * fract(dot(screenPos, magic.xy)));\n}\n\n"),this.buildShader("vertex",t),this.buildShader("fragment",e);for(let n=0;n<this.requires.uv.length;n++)if(this.requires.uv[n]){let t=n>0?n+1:"";this.addVaryCode("varying vec2 vUv"+t+";"),n>0&&this.addVertexParsCode("attribute vec2 uv"+t+";"),this.addVertexFinalCode("vUv"+t+" = uv"+t+";")}return this.requires.color[0]&&(this.addVaryCode("varying vec4 vColor;"),this.addVertexParsCode("attribute vec4 color;"),this.addVertexFinalCode("vColor = color;")),this.requires.color[1]&&(this.addVaryCode("varying vec4 vColor2;"),this.addVertexParsCode("attribute vec4 color2;"),this.addVertexFinalCode("vColor2 = color2;")),this.requires.position&&(this.addVaryCode("varying vec3 vPosition;"),this.addVertexFinalCode("vPosition = transformed;")),this.requires.worldPosition,this.requires.normal&&(this.addVaryCode("varying vec3 vObjectNormal;"),this.addVertexFinalCode("vObjectNormal = normal;")),this.requires.modelMatrix&&this.addFragmentParsCode("uniform mat4 modelMatrix;"),this.requires.viewMatrix&&this.addFragmentParsCode("uniform mat4 viewMatrix;"),this.requires.projectionMatrix&&this.addFragmentParsCode("uniform mat4 projectionMatrix;"),this.requires.worldNormal&&(this.addVaryCode("varying vec3 vWNormal;"),this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")),this.requires.vWorldViewDir&&(this.addVaryCode("varying vec3 vWorldViewDir;"),this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")),this.needsJitter&&(this.addVertexFinalCode("\n// TODO: This could be generated CPU side and passed to the shader every frame\nconst vec2 haltonSequence[16] = vec2[16](\nvec2( 0.000000,-0.333334),\nvec2(-0.500000, 0.333334),\nvec2( 0.500000,-0.777778),\nvec2(-0.750000,-0.111112),\nvec2( 0.250000, 0.555556),\nvec2(-0.250000,-0.555556),\nvec2( 0.750000, 0.111112),\nvec2(-0.875000, 0.777778),\nvec2(0.125000, -0.925926),\nvec2(-0.375000, -0.259260),\nvec2(0.625000, 0.407408),\nvec2(-0.625000, -0.703704),\nvec2(0.375000, -0.037038),\nvec2(-0.125000, 0.629630),\nvec2(0.875000, -0.481482),\nvec2(-0.937500, 0.185186));\n\n// TODO: Pass correct view size\nvec2 offset = haltonSequence[frameIndex];\noffset.x /= resolution.x;\noffset.y /= resolution.y;\n\nvec4 currentPosition = gl_Position;\nvec4 currentPositionJittered = currentPosition + (vec4(offset.x, offset.y, 0.0, 0.0) * currentPosition.w);\n\n// We want to calculate the velocity with unjittered positions\n// so that things that are not moving get a velocity = 0\nvCurrentPosition = currentPosition;\nvPreviousPosition = previousProjectionMatrix * previousModelViewMatrix * vec4(transformed, 1.0);\n#ifdef OUTLINE_COMPENSATION\nvPreviousPosition.xy += OUTLINE_COMPENSATION;\n#endif\ngl_Position = currentPositionJittered;\n\n"),this.addFragmentFinalCode("\nvec2 oldPos = vPreviousPosition.xy;\n    oldPos /= vPreviousPosition.w;\n    oldPos.xy = (oldPos.xy+1.)/2.0;\n\nvec2 newPos = vCurrentPosition.xy;\n    newPos /= vCurrentPosition.w;\n    newPos.xy = (newPos.xy+1.)/2.0;\n\nvec2 velocity = (newPos - oldPos);\n\n// Discard fully transparent pixels \nif (gl_FragColor.a <= 0.0) discard;\n\ngVelocity = vec4(velocity, 0.0, 1.0);\n")),this}buildShader(t,e){this.resultCode[t]=e.build(this.setShader(t),"v4")}setMaterial(t,e){return this.defines={},this}addFlow(t,e,n){return this.addSlot(t).addCache(e).addContext(n)}removeFlow(){return this.removeSlot().removeCache().removeContext()}addCache(t){return this.cache=t??"",this.caches.push(this.cache),this}removeCache(){return this.caches.pop(),this.cache=this.caches[this.caches.length-1]||"",this}addContext(t){return this.context=Object.assign({},this.context,t),this.context.extra=this.context.extra||{},this.contexts.push(this.context),this}removeContext(){return this.contexts.pop(),this.context=this.contexts[this.contexts.length-1]||{},this}addSlot(t){return this.slot=t||"",this.slots.push(this.slot),this}removeSlot(){return this.slots.pop(),this.slot=this.slots[this.slots.length-1]||"",this}addFragmentVariable(t,e){void 0===this.fragmentVariables[t]&&(this.addFragmentCode(`${e} ${t};`),this.fragmentVariables[t]="")}addFragmentParsVariable(t,e){void 0===this.fragmentParsVariables[t]&&(this.addFragmentParsCode(`${e} ${t};`),this.fragmentParsVariables[t]="")}addVertexParsVariable(t,e){void 0===this.vertexParsVariables[t]&&(this.addVertexParsCode(`${e} ${t};`),this.vertexParsVariables[t]="")}addVertexCode(t){this.addCode(t,"vertex")}addFragmentCode(t){this.addCode(t,"fragment")}addCode(t,e){this.code[e??this.shader]+=t+"\n"}addVertexNodeCode(t){this.addNodeCode(t,"vertex")}addFragmentNodeCode(t){this.addNodeCode(t,"fragment")}addNodeCode(t,e){this.nodeCode[e??this.shader]+=t+"\n"}clearNodeCode(t){t=t??this.shader;let e=this.nodeCode[t];return this.nodeCode[t]="",e}clearVertexNodeCode(){return this.clearNodeCode("vertex")}clearFragmentNodeCode(){return this.clearNodeCode("fragment")}addVertexFinalCode(t){this.addFinalCode(t,"vertex")}addFragmentFinalCode(t){this.addFinalCode(t,"fragment")}addFinalCode(t,e){this.finalCode[e??this.shader]+=t+"\n"}addVertexParsCode(t){this.addParsCode(t,"vertex")}addFragmentParsCode(t){this.addParsCode(t,"fragment")}addParsCode(t,e){this.parsCode[e??this.shader]+=t+"\n"}addVaryCode(t){this.addVertexParsCode(t),this.addFragmentParsCode(t)}isCache(t){return-1!==this.caches.indexOf(t)}isSlot(t){return-1!==this.slots.indexOf(t)}define(t,e){this.defines[t]=void 0===e?1:e}require(t){this.requires[t]=!0}isDefined(t){return void 0!==this.defines[t]}getVar(t,e,n,r="varying",i="V",a=""){let s=this.getVars(r),o=s[t];if(!o){let r=s.length;o={name:n||"node"+i+r+(a?"_"+a:""),type:e},s.push(o),s[t]=o}return o}getTempVar(t,e,n,r){return this.getVar(t,e,n,this.shader,"T",r)}getAttribute(t,e){if(!this.attributes[t]){let n=this.getVar(t,e);this.addVertexParsCode("attribute "+e+" "+t+";"),this.addVertexFinalCode(n.name+" = "+t+";"),this.attributes[t]={varying:n,name:t,type:e}}return this.attributes[t]}getCode(t){return[this.prefixCode,this.parsCode[t],this.getVarListCode(this.getVars("varying"),"varying"),this.getVarListCode(this.inputs.uniforms[t],"uniform"),this.getVarListCode(this.inputs.arrayUniforms[t],"uniform"),this.getIncludesCode("consts",t),this.getIncludesCode("structs",t),this.getIncludesCode("functions",t),"void main() {",this.getVarListCode(this.getVars(t)),this.code[t],this.resultCode[t],this.finalCode[t],"}"].join("\n")}getVarListCode(t,e){e=e??"";let n="";for(let r=0,i=t.length;r<i;++r){let i=t[r],a=i.type,s=i.name,o=i.size,l=this.getFormatByType(a);if(void 0===l)throw new Error("Node pars "+l+" not found.");l.includes("[]")?n+=e+" "+l.substring(0,l.length-2)+" "+s+`[${o}];\n`:n+=e+" "+l+" "+s+";\n"}return n}getVars(t){return this.inputs.vars[t??this.shader]}getNodeData(t){let e=t instanceof Fp?t.uuid:t;return this.nodeData[e]=this.nodeData[e]||{}}createUniform(t,e,n,r,i,a){if(e.includes("[]")){let s=this.inputs.arrayUniforms,o=s.list.length,l=new Rp({type:e,size:n.size,name:r||"nodeUA"+o+(a?"_"+a:""),node:n,needsUpdate:i});return s.list.push(l),s[t].push(l),s[t][l.name]=l,this.uniforms[l.name]=l,l}{let s=this.inputs.uniforms,o=s.list.length,l=new Rp({type:e,name:r||"nodeU"+o+(a?"_"+a:""),node:n,needsUpdate:i});return s.list.push(l),s[t].push(l),s[t][l.name]=l,this.uniforms[l.name]=l,l}}createVertexUniform(t,e,n,r,i){return this.createUniform("vertex",t,e,n,r,i)}createFragmentUniform(t,e,n,r,i){return this.createUniform("fragment",t,e,n,r,i)}include(t,e,n){var r;let i;if(t="string"==typeof t?Vp.get(t):t,!1===this.context.include)return t.name;t instanceof Zp?i=this.includes.functions:t instanceof tf?i=this.includes.consts:t instanceof rf&&(i=this.includes.structs);let a=i[this.shader]=i[this.shader]||[];if(t){let i=a[t.name];if(i||(i=a[t.name]={node:t,deps:[]},a.push(i),i.src=t.build(this,"source")),t instanceof Zp&&e&&a[e.name]&&-1===a[e.name].deps.indexOf(t)&&(a[e.name].deps.push(t),null==(r=t.includes)?void 0:r.length)){let n=0;do{this.include(t.includes[n++],e)}while(n<t.includes.length)}return n&&(i.src=n),t.name}throw new Error("Include not found.")}colorToVectorProperties(t){return t.replace("r","x").replace("g","y").replace("b","z").replace("a","w")}colorToVector(t){return t.replace(/c/g,"v3")}getIncludes(t,e){return this.includes[t][e||this.shader]}getConstructorFromLength(t){return Cf[t-1]}isTypeMatrix(t){return/^m/.test(t)}getTypeLength(t){return"f"===t?1:parseInt(this.colorToVector(t).substr(1))}getTypeFromLength(t){return 1===t?"f":"v"+t}findNode(...t){for(let e=0;e<arguments.length;e++){let n=t[e];if(null==n?void 0:n.isNode)return n}}resolve(...t){for(let e=0;e<arguments.length;e++){let n=t[e];if(void 0!==n){if(n.isNode)return n;if(n.isTexture)switch(n.mapping){case k:case U:return new Of(n);case B:return new Af(new hf(n));default:return new hf(n)}else{if(n.isVector2)return new Wp(n);if(n.isVector3)return new qp(n);if(n.isVector4)return new Xp(n)}}}}format(t,e,n){switch(this.colorToVector(n+" <- "+e)){case"f <- v2":case"f <- v3":case"f <- v4":return t+".x";case"f <- i":case"f <- b":return"float( "+t+" )";case"v2 <- f":return"vec2( "+t+" )";case"v2 <- v3":case"v2 <- v4":return t+".xy";case"v2 <- i":case"v2 <- b":case"v3 <- i":case"v3 <- b":return"vec2( float( "+t+" ) )";case"v3 <- f":return"vec3( "+t+" )";case"v3 <- v2":return"vec3( "+t+", 0.0 )";case"v3 <- v4":return t+".xyz";case"v4 <- f":return"vec4( "+t+" )";case"v4 <- v2":return"vec4( "+t+", 0.0, 1.0 )";case"v4 <- v3":return"vec4( "+t+", 1.0 )";case"v4 <- i":case"v4 <- b":return"vec4( float( "+t+" ) )";case"i <- f":case"i <- b":return"int( "+t+" )";case"i <- v2":case"i <- v3":case"i <- v4":return"int( "+t+".x )";case"b <- f":return"( "+t+" != 0.0 )";case"b <- v2":return"( "+t+" != vec2( 0.0 ) )";case"b <- v3":return"( "+t+" != vec3( 0.0 ) )";case"b <- v4":return"( "+t+" != vec4( 0.0 ) )";case"b <- i":return"( "+t+" != 0 )"}return t}getTypeByFormat(t){return Pf[t]||t}getFormatByType(t){return Df[t]||t}getUUID(t,e){return(e=void 0===e||e)&&this.cache&&(t=this.cache+"-"+t),t}getElementByIndex(t){return Mf[t]}getIndexByElement(t){return Mf.indexOf(t)}isShader(t){return this.shader===t}setShader(t){return this.shader=t,this}mergeDefines(t){for(let e in t)this.defines[e]=t[e];return this.defines}mergeUniform(t){for(let e in t)this.uniforms[e]=t[e];return this.uniforms}getTextureEncodingFromMap(t){let e;return t?t.isTexture&&(e=t.encoding):e=j,e===j&&this.context.gamma&&(e=N),e}};t.needsJitter=this.needsJitter,this.lights=this.lightLayer.data.visible,t.build(this.fragment,this.fragment),this.vertexShader=t.getCode("vertex"),this.fragmentShader=t.getCode("fragment"),this.defines=t.defines,this.uniforms=t.uniforms,this.extensions=t.extensions,this.updaters=t.updaters;for(let e of this.flavors)e&&e.updateAfterBuild();return this}nodeMaterialDispose(){this.layers.forEach((t=>t.dispose())),super.dispose();for(let t of this.flavors)t&&t.dispose()}assetsLoaded(){for(let t of this.layers)if(t instanceof Wm){let e=t.params.texture;if(e instanceof jf&&!e.image.loaded)return!1}return!0}getHash(){let t="{";return t+='"fragment":'+this.fragment.getHash(),t+="}",t}};Object.defineProperties(Zm.prototype,{properties:{get:function(){return this.fragment.properties}}});var tg=class extends Jm{constructor(t,e,n){super(t,e,!1),this.uuid=n,this.allowVariableSaves=!0,this.saveVariableLocations(e)}},eg=Ht(Yt()),ng=new Map;function rg(t){if("string"==typeof t)return t;let e=ng.get(t);return e||(e={url:URL.createObjectURL(new Blob([t]))},ng.set(t,e)),e.url}var ig,ag,sg=class{constructor({src:t,volume:e,delay:n,loop:r}){let i;this._volume=1,this.delay=0,this._loop=1,this.loopsRemaining=0,this._status="stopped",this.onEnd=()=>{this.loopsRemaining===1/0?this.replay():this.loopsRemaining>1?(this.replay(),this.loopsRemaining--):(this._status="stopped",this.loopsRemaining=this._loop)},i="string"==typeof t?{src:t}:{src:rg(t),format:"wav"},this.sound=new eg.Howl(i),this.sound.on("end",this.onEnd),this.src=t,void 0!==e&&(this.volume=e),void 0!==n&&(this.delay=n),void 0!==r&&(this.loop=r)}get status(){return this._status}get volume(){return this._volume}set volume(t){this._volume=t,this.sound.volume(t)}get loop(){return this._loop}set loop(t){this._loop=t,this.loopsRemaining=t}replay(){this.clearDelay(),this.delayTimerId=window.setTimeout((()=>{this.sound.play(),this.clearDelay()}),this.delay)}fade(t,e=1e3){t?(this.sound.volume(this._volume),this.clearFade(),this.fadeTimerId=window.setTimeout((()=>{this.sound.fade(this._volume,0,e),this.clearFade()}),t)):this.sound.fade(this._volume,0,e)}on(t,e,n){this.sound.on(t,e,n)}off(t,e,n){this.sound.off(t,e,n)}play(){"playing"===this._status||this.sound.playing()||("paused"===this._status?(0===this.sound.seek()?this.replay():this.sound.play(),this._status="playing"):"stopped"===this._status&&(this.replay(),this._status="playing"))}pause(){"playing"===this._status&&(this.sound.pause(),this.clearFade(),this.clearDelay(),this._status="paused")}stop(){this.sound.stop(),this.loopsRemaining=this._loop,this.clearFade(),this.clearDelay(),this._status="stopped"}clearFade(){this.fadeTimerId&&(clearTimeout(this.fadeTimerId),delete this.fadeTimerId)}clearDelay(){this.delayTimerId&&(clearTimeout(this.delayTimerId),delete this.delayTimerId)}dispose(t=!1){this.off(),this.stop(),this.clearFade(),this.clearDelay()}},og=new Promise((t=>{ig=t})),lg=!1;function hg(){if(!lg)return ag||(ag=async function(){let e=await t((()=>import("./opentype-b44197b7.js")),[]);ig(e),lg=!0}(),ag)}var dg=new class{async load(t,e,n=(()=>{})){let{load:r}=await og;r(t,((t,r)=>{t||!r?n(t??"Something went wrong"):e(r)}))}async parse(t){let{parse:e,Bidi:n}=await og;try{let r=e(t),i=new n,a=t=>r.charToGlyphIndex(t.char);return i.registerModifier("glyphIndex",null,a),i.applyFeatures(r,r.defaultRenderOptions.features),{font:r,bidi:i}}catch(al){console.error(al)}}};async function cg(t){let e,n,r=!1;if(t.url?(e=await async function(t){return await(await fetch(t)).arrayBuffer()}(t.url),n=t.url,r=t.url.startsWith("/")):t.data&&(e=t.data.buffer.slice(t.data.byteOffset,t.data.byteOffset+t.data.byteLength)),e){let t=await dg.parse(e);if(t)return{font:t.font,url:n,intercepted:r,arr:e,bidi:t.bidi}}}function ug(t,e){return e.state.glyphIndex===t||e.state.fina===t||e.state.medi===t||e.state.init===t}var pg=class{constructor(){this.objects=new Map,this.unreachable=new Set}getCached(t){return this.objects.get(t)}get size(){return this.objects.size}get(t,e,n){let r=this.objects.get(t);return void 0===r?(r=this.createObject(t,e,n),this.objects.set(t,r)):r.isShared=!0,r}forceDelete(t){let e=this.objects.get(t);e&&(this.disposeObject(e),this.objects.delete(t))}mutateIfUnique(t,e){let n=this.objects.get(t);if(n&&!0!==n.isShared)return this.objects.delete(t),this.objects.set(e,n),n}startGc(){this.unreachable=new Set(this.objects.keys())}markAsReachable(t,e){e===this.objects.get(t)&&this.unreachable.delete(t)}endGc(){this.unreachable.forEach((t=>{this.disposeObject(this.objects.get(t)),this.objects.delete(t)})),this.unreachable.clear()}dispose(){this.objects.forEach((t=>{this.disposeObject(t)})),this.objects.clear()}},fg=class extends pg{constructor(t){super(),this.flatShading=t}disposeObject(t){t.dispose()}createObject(t,e,n){let r=rp(t,e,this.flatShading,n);return r.computeBoundingSphere(),r}},mg={markNeedsUpdateRendererDirty:()=>{}},gg=class extends zm{constructor(t){super(),this.shared=t}create(t){return new Em(t,this.shared)}},vg=class{constructor(t,e={}){if(this.data=t,this.geometryCache=new fg(!0),this.geometryCache2=new fg(!1),this.imageHolderCache=new gg(this),this.thisContext={scene:mg,shared:this},this.deletedMaterial=new tg(kl.defaultTwoLayerData("phong"),this.thisContext,""),this.deletedImage=new Lm(Ah.emptyImage,this),this.deletedVideo=new Lm(Dl.defaultVideo,this),this.materials={},this.images={},this.videos={},this.colors={},this.audios={},this.fonts={},this.variables={},this.mouseProperty=null,this.raycastProperty=null,this.requestRender=()=>{this._requestRender&&this._requestRender()},e.images)for(let[n,r]of Object.entries(e.images))this.addImage(n,r);if(e.videos)for(let[n,r]of Object.entries(e.videos))this.addVideo(n,r);if(e.audios)for(let[n,r]of Object.entries(e.audios))this.addAudio(n,r);this.reset(t)}setRequestRender(t){this._requestRender=t}setEntityOpContext(t){this.entityOpContext=t}reset(t,e=!1){this.resetLib(t.lib);for(let{id:n,data:r}of t.variables)this.addVariableHolder(n,r),e&&this.updateVariableHolder(n,r);for(let[n,r]of Object.entries(t.images))this.addImage(n,r);for(let[n,r]of Object.entries(t.videos))this.addVideo(n,r);for(let[n,r]of Object.entries(t.colors))this.addColor(n,r);for(let[n,r]of Object.entries(t.materials))this.addMaterial(n,r);for(let[n,r]of Object.entries(t.audios))this.addAudio(n,r);for(let[n,r]of Object.entries(t.fonts))this.addFont(n,r)}addMaterial(t,e){if(this.materials[t]){let n=this.materials[t];n.reset(e,this.thisContext),n.dispose()}else{let n=new tg(e,this.thisContext,t);this.materials[t]=n}}deleteMaterial(t){this.materials[t]&&(this.materials[t].nodeMaterialDispose(),delete this.materials[t])}getMaterial(t){return this.materials[t]}getMaterialOrDeletedPlaceholder(t){return this.materials[t]??this.deletedMaterial}material(t){return"string"==typeof t?this.getMaterialOrDeletedPlaceholder(t):null==t?(console.error("material is undefined or null"),this.deletedMaterial):new Jm(t,this.thisContext)}getMaterials(){return this.materials}addImage(t,e){return this.images[t]?(this.onColorOrImageUpdate&&this.onColorOrImageUpdate(),this.images[t].updateSrc(e.data),!0):(this.images[t]=new Lm(e,this),!1)}deleteImage(t){let e=this.images[t];e&&(e.dispose(),delete this.images[t])}getDefaultImage(){return this.images.image_0}getImage(t){return this.images[t]??this.deletedImage}image(t){return"string"==typeof t?this.getImage(t):this.imageHolderCache.load(t)}addVideo(t,e){return this.videos[t]?(this.videos[t].updateSrc(e.data),!0):(this.videos[t]=new Lm(e,this),!1)}deleteVideo(t){let e=this.videos[t];e&&(e.dispose(),delete this.videos[t])}getVideo(t){return this.videos[t]??this.deletedVideo}video(t){return"string"==typeof t?this.getVideo(t):this.imageHolderCache.load(t)}addColor(t,e){return this.colors[t]?(this.onColorOrImageUpdate&&this.onColorOrImageUpdate(),"a"in e?this.colors[t].setRGBA(e.r,e.g,e.b,e.a):this.colors[t].setRGBA(e.r,e.g,e.b,1),!0):(this.colors[t]=new Um(e.r,e.g,e.b,"a"in e?e.a:1),!1)}updateColor(t,e){if(this.colors[t]){this.onColorOrImageUpdate&&this.onColorOrImageUpdate();let n=this.colors[t];return this.colors[t].r=e.r??n.r,this.colors[t].g=e.g??n.g,this.colors[t].b=e.b??n.b,this.colors[t].a=e.a??n.a,!0}return!1}deleteColor(t){this.colors[t]&&delete this.colors[t]}getColor(t){return this.colors[t]}color(t){let e;if("string"!=typeof t)return new $p(t.r,t.g,t.b,"a"in t?t.a:1);{let n=this.getColor(t);n?e=n:(console.warn("Tried to create color layer params with a color key that does not exist in the assets manager"),e=new $p(0,0,0,0))}return e}addAudio(t,e){this.audios[t]=e}getAudio(t){let e=this.audios[t];if(e instanceof sg)return e;{let n=new sg({src:e.data});return this.audios[t]=n,n}}deleteAudio(t){let e=this.audios[t];e&&(e instanceof sg&&e.dispose(),delete this.audios[t])}addFont(t,e){this.fonts[t]=new class{constructor(t){this._arrayBuffer=new ArrayBuffer(1),this._isLoaded=!1,this._intercepted=!1,this._isUserFont=t.isUserFont??!1,this._loadingPromise=cg(t).then((t=>{t&&(this._arrayBuffer=t.arr,this._url=t.url,this.font=t.font,this._intercepted=t.intercepted,this._isLoaded=!0,this._bidi=t.bidi)}))}update(t){this._isLoaded=!1,this._isUserFont=t.isUserFont??!1,this._loadingPromise=cg(t).then((t=>{t&&(this._arrayBuffer=t.arr,this._url=t.url,this.font=t.font,this._intercepted=t.intercepted,this._isLoaded=!0,this._bidi=t.bidi)}))}get url(){return this._url}get intercepted(){return this._intercepted}get isLoaded(){return this._isLoaded}get loadingPromise(){return this._loadingPromise}reverseLigaturesTable(t,e,n){if(!this._bidi)return[];let r=this._bidi;r.getTextGlyphs(e);let i=r.tokenizer.tokens,a=[],s=0,o=n.length===i.length;for(let l=0;l<n.length;l++){let r=n[l].index,h=String.fromCharCode(n[l].unicode),d=i[s];if(ug(r,d)||o)a.push({char:h,index:r,replacements:[d.state.glyphIndex],replacementChars:[d.char]}),s++;else{let n=d.char,i="",o=[d.state.glyphIndex],l=[],c=!1;for(;!c;)s++,i=e.charAt(s),n+=i,o.push(t.charToGlyphIndex(i)),l=t.stringToGlyphs(n),1===l.length&&l[0].index===r&&(c=!0),s>e.length&&(c=!0);a.push({char:h,index:r,replacements:o,replacementChars:Array.from(n)}),s++}}return a}generateShapes(t,e){if(!this._isLoaded)return;let n,r=this.font,i=e.fontSize/this.unitsPerEm,a=e.fontSize*e.lineHeight,s=t.map((t=>this.getTextWidth(t,e))),o=e.width,l=this.getCharWidth("\n",e),h=1===e.horizontalAlign?l:0,d=this.computeSpaceWidthForLine(t,0,e),c=this.getLineInitialOffsetX(s[0],o,e.horizontalAlign,t[0],l),u=this.getLineInitialOffsetY(a,t.length,e.height,i,e.verticalAlign),p=[],f=t.map((t=>[])),m=t.map((t=>[]));for(let y=0;y<t.length;y++){let g=t[y],b={features:{liga:!0}},x=[];try{x=r.stringToGlyphs(g,b)}catch(v){console.warn(v)}c=this.getLineInitialOffsetX(s[y],o,e.horizontalAlign,g,l);let w=[];try{w=this.reverseLigaturesTable(r,g,x)}catch(v){console.warn(v)}d=this.computeSpaceWidthForLine(t,y,e);for(let t=0;t<x.length;t++){let a=x[t],s=0===a.index?"\n":a.unicode?String.fromCharCode(a.unicode):void 0,o=w[t],l=0,g=0;0===t&&2===e.horizontalAlign&&void 0!==a.leftSideBearing&&(g=-a.leftSideBearing*i),n&&(l=r.getKerningValue(a,n)*i),c+=g+l;let v=0;if("\n"===s)v=h;else if(" "===s)v=d;else{let t=this.createPath(a,i,c,u,e);t&&(v=t.offsetX-(l+g),p.push(t.path))}if(1===o.replacements.length)m[y].push([c,u]),f[y].push(v);else{let t=o.replacements.map((t=>(r.glyphs.get(t).advanceWidth??0)*i)),e=t.reduce(((t,e)=>t+e),0),n=t.map((t=>t/e)),a=c;for(let r=0;r<n.length;r++){let t=v*n[r];m[y].push([a,u]),f[y].push(t),a+=t}}c+=v,n=a}u-=a}let g=[];for(let y=0,b=p.length;y<b;y++)g.push(...p[y].toShapes());return{shapes:g,charWidths:f,lineWidths:s,charCoords:m}}get isUserFont(){return this._isUserFont}get arrayBuffer(){return this._arrayBuffer}get ascender(){var t;return(null==(t=this.font)?void 0:t.ascender)??0}get descender(){var t;return(null==(t=this.font)?void 0:t.descender)??0}get familyName(){var t;return(null==(t=this.font)?void 0:t.names.fontFamily)??""}get subfamilyName(){var t;return(null==(t=this.font)?void 0:t.names.fontSubfamily)??""}get unitsPerEm(){var t;return(null==(t=this.font)?void 0:t.unitsPerEm)??1}getLineInitialOffsetX(t,e,n,r,i){return(3===n||2===n)&&r.indexOf("\n")>=0&&(t-=i),3===n?.5*e-.5*t:2===n?e-t:0}getLineInitialOffsetY(t,e,n,r,i){let a=e*t,s=t-Math.abs(this.ascender-this.descender)*r,o=-this.ascender*r-s/2;return 3===i?-(n-a-o):2===i?-(.5*n-.5*a-o):o}createPath(t,e,n,r,i){var a;let s=t.getPath(n,-r,i.fontSize,{kerning:!1,letterSpacing:i.letterSpacing});if(!s)return void console.error('THREE.Font: character "'+t+'" does not exists in font family '+this.familyName+".");let o=new class{constructor(){this.type="ShapePath",this.color=new _,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new H,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){var n;return null==(n=this.currentPath)||n.lineTo(t,e),this}quadraticCurveTo(t,e,n,r){var i;return null==(i=this.currentPath)||i.quadraticCurveTo(t,e,n,r),this}bezierCurveTo(t,e,n,r,i,a){var s;return null==(s=this.currentPath)||s.bezierCurveTo(t,e,n,r,i,a),this}splineThru(t){var e;return null==(e=this.currentPath)||e.splineThru(t),this}toShapes(){let t=0,e=1,n=2,r=3,i=4,a=5,s=6,o={loc:t,t:0};function h(e,r,i,a){let s=e.x,l=r.x,h=i.x,c=a.x,u=e.y,p=r.y,f=i.y,m=a.y,g=(c-h)*(u-f)-(m-f)*(s-h),v=(m-f)*(l-s)-(c-h)*(p-u),y=g/v,b=((l-s)*(u-f)-(p-u)*(s-h))/v;if(0===v&&0!==g||y<=0||y>=1||b<0||b>1)return null;if(0===g&&0===v){for(let h=0;h<2;h++){if(d(0===h?i:a,e,r),o.loc===t){let t=0===h?i:a;return{x:t.x,y:t.y,t:o.t}}if(o.loc===n)return{x:+(s+o.t*(l-s)).toPrecision(10),y:+(u+o.t*(p-u)).toPrecision(10),t:o.t}}return null}for(let n=0;n<2;n++)if(d(0===n?i:a,e,r),o.loc===t){let t=0===n?i:a;return{x:t.x,y:t.y,t:o.t}}return{x:+(s+y*(l-s)).toPrecision(10),y:+(u+y*(p-u)).toPrecision(10),t:y}}function d(l,h,d){let c,u=d.x-h.x,p=d.y-h.y,f=l.x-h.x,m=l.y-h.y,g=u*m-f*p;return l.x===h.x&&l.y===h.y?(o.loc=t,void(o.t=0)):l.x===d.x&&l.y===d.y?(o.loc=e,void(o.t=1)):void(g<-Number.EPSILON?o.loc=r:g>Number.EPSILON?o.loc=i:u*f<0||p*m<0?o.loc=a:Math.sqrt(u*u+p*p)<Math.sqrt(f*f+m*m)?o.loc=s:(c=0!==u?f/u:m/p,o.loc=n,o.t=c))}function c(t,e,n){let r=new l;e.getCenter(r);let i=[];return n.forEach((e=>{e.boundingBox.containsPoint(r)&&function(t,e){let n=[],r=[];for(let i=1;i<t.length;i++){let a=t[i-1],s=t[i];for(let t=1;t<e.length;t++){let i=h(a,s,e[t-1],e[t]);null!==i&&void 0===n.find((t=>t.t<=i.t+Number.EPSILON&&t.t>=i.t-Number.EPSILON))&&(n.push(i),r.push(new l(i.x,i.y)))}}return r}(t,e.points).forEach((t=>{i.push({identifier:e.identifier,isCW:e.isCW,point:t})}))})),i.sort(((t,e)=>t.point.x-e.point.x)),i}let u=0,p=999999999,f=-999999999,m=[];this.subPaths.forEach((t=>{let e=t.getPoints(),n=-999999999,r=999999999,i=-999999999,a=999999999;for(let s=0;s<e.length;s++){let t=e[s];t.y>n&&(n=t.y),t.y<r&&(r=t.y),t.x>i&&(i=t.x),t.x<a&&(a=t.x)}f<=i&&(f=i+1),p>=a&&(p=a-1),e.length&&m.push({curves:t.curves,points:e,isCW:W.isClockWise(e),identifier:u++,boundingBox:new q(new l(a,r),new l(i,n))})}));let g=m.map((t=>{var e;return function(t,e,n,r,i){(null==i||""===i)&&(i="nonzero");let a=new l;t.boundingBox.getCenter(a);let s=c([new l(n,a.y),new l(r,a.y)],t.boundingBox,e);s.sort(((t,e)=>t.point.x-e.point.x));let o=[],h=[];s.forEach((e=>{e.identifier===t.identifier?o.push(e):h.push(e)}));let d=o[0].point.x,u=[],p=0;for(;p<h.length&&h[p].point.x<d;)u.length>0&&u[u.length-1]===h[p].identifier?u.pop():u.push(h[p].identifier),p++;if(u.push(t.identifier),"evenodd"===i){let e=u.length%2==0,n=u[u.length-2];return{identifier:t.identifier,isHole:e,for:n}}if("nonzero"===i){let n=!0,r=null,i=null;for(let t=0;t<u.length;t++){let a=u[t];e[a]&&(n?(i=e[a].isCW,n=!1,r=a):i!==e[a].isCW&&(i=e[a].isCW,n=!0))}return{identifier:t.identifier,isHole:n,for:r}}console.warn('fill-rule: "'+i+'" is currently not implemented.')}(t,m,p,f,null==(e=this.userData)?void 0:e.style.fillRule)})),v=[];return m.forEach((t=>{let e=g[t.identifier];if(e&&!e.isHole){let e=new $;e.curves=t.curves,g.filter((e=>(null==e?void 0:e.isHole)&&e.for===t.identifier)).forEach((t=>{if(t){let n=m[t.identifier],r=new H;r.curves=n.curves,e.holes.push(r)}})),v.push(e)}})),v}},h=(t.advanceWidth??1)*e;if(t)for(let l of s.commands){let t=null==(a=o.currentPath)?void 0:a.currentPoint;if(!t||"Z"===l.type||t.x!==l.x||-t.y!==l.y)switch(l.type){case"M":o.moveTo(l.x,-l.y);break;case"L":o.lineTo(l.x,-l.y);break;case"Q":o.quadraticCurveTo(l.x1,-l.y1,l.x,-l.y);break;case"C":o.bezierCurveTo(l.x1,-l.y1,l.x2,-l.y2,l.x,-l.y)}}return o.subPaths.forEach((t=>{let e=function(t){if(t.length){let e=t[0];if(e instanceof C)return e.v1;if(e instanceof P||e instanceof D)return e.v0}}(t.curves);void 0!==e&&t.currentPoint.distanceTo(e)>0&&t.lineTo(e.x,e.y)})),{offsetX:h+i.fontSize*i.letterSpacing,path:o}}getCharWidth(t,e){var n;return(null==(n=this.font)?void 0:n.getAdvanceWidth(t,e.fontSize,{kerning:!0,letterSpacing:e.letterSpacing}))??0}getTextWidth(t,e){var n;return(null==(n=this.font)?void 0:n.getAdvanceWidth(t,e.fontSize,{kerning:!0,letterSpacing:e.letterSpacing}))??0}computeSpaceWidthForLine(t,e,n){let r=this.getCharWidth(" ",n),i=t[e];if(i){let a=this.countSpaces(i.trimEnd());if(4===n.horizontalAlign&&e<t.length-1&&a)return(n.width-(this.getTextWidth(i,n)-a*r))/a}return r}countSpaces(t){return(t.match(/ /g)||[]).length}}(e),this.fonts[t].loadingPromise.then((()=>this.requestRender()))}getFont(t){return this.fonts[t]}deleteFont(t){this.fonts[t]&&delete this.fonts[t]}dispose(){Object.keys(this.materials).forEach((t=>this.deleteMaterial(t))),this._requestRender=void 0,Object.values(this.audios).forEach((t=>{t instanceof sg&&t.dispose()})),this.audios={},this.geometryCache.dispose(),this.geometryCache2.dispose()}addVariableHolder(t,e){return void 0===this.variables[t]?(this.variables[t]={value:e.value,locations:[]},"dynamicVariableType"in e&&(this.variables[t].dynamicVariablePlayState="Playing",this.variables[t].dynamicVariableToggleIsForward=void 0),!0):(this.variables[t].value=e.value,!1)}resetDynamicVariablePlayState(){for(let t in this.variables)void 0!==this.variables[t].dynamicVariablePlayState&&(this.variables[t].dynamicVariablePlayState="Playing",this.variables[t].dynamicVariableToggleIsForward=void 0)}updateVariableHolder(t,e){this.updateVariable(t,e.value)}updateVariable(t,e){if(void 0===this.variables[t])return!1;this.variables[t].value=e;let n=e;for(;"string"==typeof n;)n=this.variables[n].value;let r=this.entityOpContext.scene;for(let i=this.variables[t].locations.length-1;i>=0;i--){let e=this.variables[t].locations[i];if("material"===e[0]){let t=e[1],i=n,a={scene:r,shared:this},s=e.slice(2);r.traverseMaterial((e=>{let n=e.root??e;n.uuid===t&&n.onVariableUpdate(s,i,a)}));let o=this.materials[t];o&&o.onVariableUpdate(s,i,a)}else{let a=r.find(e[0]);if(void 0===a){this.variables[t].locations.splice(i,1);continue}if("geometry"!==e[1]){for(let t=1;t<e.length-1;t++)a=a[e[t]];"rotation"===e[1]&&(n=x.DEG2RAD*n),a[e[e.length-1]]=n}if(a=r.find(e[0]),yd.is(a))if("position"===e[1]||"rotation"===e[1]||"scale"===e[1])a.onVariableUpdate();else if("geometry"===e[1]){let t=a;a.component&&(t=a.component);let e=t.dataPatched;t.chooseGeoemtryCache(this).forceDelete(e.geometry),t.createGeometryDelayed(this.entityOpContext),t.onVariableUpdate(!0),t.instances.forEach((t=>{let e=t.dataPatched;t.chooseGeoemtryCache(this).forceDelete(e.geometry),t.createGeometryDelayed(this.entityOpContext),t.onVariableUpdate(!0)}))}}}return!0}deleteVariable(t){this.variables[t]&&delete this.variables[t]}getVariable(t,e){var n,r,i;if(Array.isArray(t)){if("mouse"===t[0])return(null==(n=this.mouseProperty)?void 0:n[t[1]])??0;if("raycast"===t[0])return(null==(r=this.raycastProperty)?void 0:r[t[1]])??0;let e=this.entityOpContext.scene.find(t[0]);if("width"===t[1]||"height"===t[1]||"depth"===t[1])return e.geometry.userData.parameters[t[1]];for(let n=1;n<t.length;n++)e=e[t[n]];return e}for(let a in this.variables){if(void 0===e)break;let t=this.variables[a],n=null==(i=t.locations)?void 0:i.findIndex((t=>As.equal(t,e)));void 0!==n&&-1!==n&&t.locations.splice(n,1)}if("string"==typeof t){let n=t,r=t;do{if(r=n,void 0===this.variables[n])break;n=this.variables[n].value}while("string"==typeof n);return e&&void 0!==this.variables[r]&&this.variables[r].locations.push(e),n}return t}getVariables(){return this.variables}getDynamicVariablePlayState(t){var e;return null==(e=this.variables[t])?void 0:e.dynamicVariablePlayState}setDynamicVariablePlayState(t,e){void 0!==this.variables[t]&&(this.variables[t].dynamicVariablePlayState=e)}getDynamicVariableToggleIsForward(t){var e;return null==(e=this.variables[t])?void 0:e.dynamicVariableToggleIsForward}setDynamicVariableToggleIsForward(t,e){void 0!==this.variables[t]&&(this.variables[t].dynamicVariableToggleIsForward=e)}resetLib(t){for(let[e,n]of Object.entries(t.images))this.addImage(e,n.asset);for(let[e,n]of Object.entries(t.audios))this.addAudio(e,n.asset);for(let[e,n]of Object.entries(t.colors))this.addColor(e,n.asset);for(let[e,n]of Object.entries(t.fonts))this.addFont(e,n.asset);for(let[e,n]of Object.entries(t.materials))this.addMaterial(e,n.asset);for(let[e,n]of Object.entries(t.videos))this.addVideo(e,n.asset);for(let[e,n]of Object.entries(t.variables))this.addVariableHolder(e,n.asset)}updateLibByOp(t,e){"images"===t.path[0]?1===t.path.length&&1===t.type?this.addImage(t.id,t.data.asset):1===t.path.length&&2===t.type&&this.deleteImage(t.id):"videos"===t.path[0]?1===t.path.length&&1===t.type?this.addVideo(t.id,t.data.asset):1===t.path.length&&2===t.type&&this.deleteVideo(t.id):"audios"===t.path[0]?1===t.path.length&&1===t.type?this.addAudio(t.id,t.data.asset):1===t.path.length&&2===t.type&&this.deleteAudio(t.id):"colors"===t.path[0]?1===t.path.length&&1===t.type?this.addColor(t.id,t.data.asset):1===t.path.length&&2===t.type&&this.deleteColor(t.id):"materials"===t.path[0]?1===t.path.length&&1===t.type?this.addMaterial(t.id,t.data.asset):1===t.path.length&&2===t.type&&this.deleteMaterial(t.id):"fonts"===t.path[0]?1===t.path.length&&1===t.type?this.addFont(t.id,t.data.asset):1===t.path.length&&2===t.type&&this.deleteFont(t.id):"variables"===t.path[0]?1===t.path.length&&1===t.type?this.addVariableHolder(t.id,t.data.asset):1===t.path.length&&2===t.type&&this.deleteVariable(t.id):"components"===t.path[0]&&e.updateByLibOp(t,this)}updateByOp(t,e,n){this.data=e,"images"===t.path[0]?2===t.path.length&&0===t.type?t.props.data&&this.getImage(t.path[1]).updateSrc(t.props.data):1===t.path.length&&1===t.type?this.addImage(t.id,t.data):1===t.path.length&&2===t.type&&this.deleteImage(t.id):"videos"===t.path[0]?2===t.path.length&&0===t.type?t.props.data&&this.getVideo(t.path[1]).updateSrc(t.props.data):1===t.path.length&&1===t.type?this.addVideo(t.id,t.data):1===t.path.length&&2===t.type&&this.deleteVideo(t.id):"audios"===t.path[0]?2===t.path.length&&0===t.type?t.props.data&&this.addAudio(t.path[1],e.audios[t.path[1]]):1===t.path.length&&1===t.type?this.addAudio(t.id,t.data):1===t.path.length&&2===t.type&&this.deleteAudio(t.id):"colors"===t.path[0]?2===t.path.length&&0===t.type?this.updateColor(t.path[1],t.props):1===t.path.length&&1===t.type?this.addColor(t.id,t.data):1===t.path.length&&2===t.type&&this.deleteColor(t.id):"materials"===t.path[0]?1===t.path.length&&1===t.type?this.addMaterial(t.id,t.data):1===t.path.length&&2===t.type?this.deleteMaterial(t.id):t.path.length>1&&this.getMaterial(t.path[1]).updateByOp(es.drop(t,2),e.materials[t.path[1]],{shared:this,scene:n}):"fonts"===t.path[0]?2===t.path.length&&0===t.type?this.updateFont(t.path[1],t,n):1===t.path.length&&1===t.type?this.addFont(t.id,t.data):1===t.path.length&&2===t.type&&this.deleteFont(t.id):"variables"===t.path[0]?2===t.path.length&&0===t.type&&"value"in t.props?this.updateVariable(t.path[1],t.props.value):1===t.path.length&&4===t.type?this.addVariableHolder(t.id,t.data):1===t.path.length&&5===t.type&&this.deleteVariable(t.id):"lib"===t.path[0]&&this.updateLibByOp(es.drop(t,1),n)}updateFont(t,e,n){if(e.props.url){let r=this.getFont(t),i={...this.data.fonts[t],url:e.props.url};r.update(i),r.loadingPromise.then((()=>this.requestRender())),n.updateFont(t,this)}}},yg=new vg(Th.emptyData()),bg=class extends kp{updateByPatchedOp(t,e,n){if(super.updateByPatchedOp(t,e,n),null!==function(t,e){let n=[];if(e.length!==t.length)return null;for(var r=0;r<t.length;){if("*"===e[r])n.push(t[r]);else if(t[r]!==e[r])return null;r+=1}return n}(t.path,["materials"])&&0===t.type&&Array.isArray(this.material))for(let[r,i]of Object.entries(t.props)){let t=n.shared.material(i);this.material[Number(r)]=t}else if(Ts(t.path,["material"])&&this.material instanceof Zm)"material"in e&&"string"!=typeof e.material&&this.material.updateByOp(es.drop(t,1),e.material,n);else if(Ts(t.path,["materials","*"])&&Array.isArray(this.material)){let r=t.path[1];if("materials"in e&&r<this.material.length){let i=e.materials[r];"string"!=typeof i&&this.material[r].updateByOp(es.drop(t,2),i,n)}}}get needsAO(){return void 0!==this.material&&(Array.isArray(this.material)?this.material[0]:this.material).hasAO}updateState(t,e){var n,r;super.updateState(t,e),void 0!==t.castShadow&&(this.castShadow=t.castShadow),void 0!==t.receiveShadow&&(this.receiveShadow=t.receiveShadow);let i=this.dataPatched;if("NonParametricGeometry"!==(null==(n=t.geometry)?void 0:n.type)&&"material"in t&&void 0!==t.material&&(this.disposeMaterial(),this.material=e.shared.material(t.material).getFlavor(i.flatShading,i.side,i.wireframe),e.scene.markNeedsUpdateRendererDirty()),"NonParametricGeometry"===(null==(r=t.geometry)?void 0:r.type)&&("materials"in t&&void 0!==t.materials?(this.disposeMaterial(),this.material=t.materials.map((t=>e.shared.material(t).getFlavor(i.flatShading,i.side,i.wireframe))),e.scene.markNeedsUpdateRendererDirty()):"material"in t&&void 0!==t.material&&(this.disposeMaterial(),this.material=[e.shared.material(t.material).getFlavor(i.flatShading,i.side,i.wireframe)],e.scene.markNeedsUpdateRendererDirty())),void 0!==t.flatShading||void 0!==t.wireframe||void 0!==t.side)if(Array.isArray(this.material))for(let a=0;a<this.material.length;a++)this.material[a]=this.material[a].getFlavor(i.flatShading,i.side,i.wireframe);else this.material=this.material.getFlavor(i.flatShading,i.side,i.wireframe)}disposeMaterial(){this.material&&Qt(this.material).forEach((t=>{t instanceof Zm&&(t instanceof tg||t.nodeMaterialDispose())}))}dispose(){this.disposeMaterial(),super.dispose()}},xg=new o,wg=new p,_g=new p,Sg=new o,Ag=new s,Og=class extends bg{constructor(t,e,n){super(t,e),this.data=e,this.localGeometry=void 0,e.bindMode&&e.bindMatrix&&(this.isSkinnedMesh=!0,this.bindMode=e.bindMode,this.bindMatrix=(new s).fromArray(e.bindMatrix),this.bindMatrixInverse=new s)}chooseGeoemtryCache(t){return t.geometryCache}markGeometryAsReachable(t){this.geometryCreateDeleyed instanceof e&&this.chooseGeoemtryCache(t).markAsReachable(this.dataPatched.geometry,this.geometryCreateDeleyed)}get geometry(){if(void 0!==this.localGeometry)return this.localGeometry;if(this.geometryCreateDeleyed instanceof vg){let t=this.geometryCreateDeleyed,e=this.chooseGeoemtryCache(t);this.geometryCreateDeleyed=e.get(this.dataPatched.geometry,t,this)}return this.geometryCreateDeleyed}set geometry(t){this.localGeometry=t}get is2DAndNoDepth(){let t=this.dataPatched.geometry;return ql.is2DParametricMesh(t.type)&&0===t.depth}get is2DType(){return ql.is2DParametricMesh(this.geometry.userData.type)}get isNonParametric(){return"NonParametricGeometry"===this.geometry.userData.type}updateByPatchedOp(t,e,n){super.updateByPatchedOp(t,e,n),Ts(t.path,["geometry"])&&this.updateByPatchedOpGeometry(es.drop(t,1),e.geometry,n)}removeInteractionGeometry(){var t;null==(t=this.localGeometry)||t.dispose(),this.localGeometry=void 0}updateGeometryInteractions(t,e){var n;this.invalidateDownstreamBooleanData();let r=this.data.geometry.type;if("NonParametricGeometry"===r||"SubdivGeometry"===r){let n,r,i,a=t;if(void 0===this.localGeometry){let t={...this.data.geometry,...a};this.localGeometry=rp(t,e,this.data.flatShading,this)}a.scaleBaked?[n,r,i]=a.scaleBaked:({width:n,height:r,depth:i}=a);let s=this.localGeometry.userData;void 0!==s.sxPrev&&ap(this.localGeometry.attributes,n/s.sxPrev,r/s.syPrev,i/s.szPrev),s.sxPrev=n,s.syPrev=r,s.szPrev=i}else{let r={...this.data.geometry,...t};null==(n=this.localGeometry)||n.dispose(),this.localGeometry=rp(r,e,this.data.flatShading,this)}}refreshAttachedCloners(t){for(let e of this.attachedSurfaceCloners)t.scene.addPendingUpdateCloner(e.object)}refreshAttachedPaths(t){for(let e of this.attachedPaths)t.scene.addPendingCommand((()=>e.updateShape()))}createGeometryDelayed(t){this.geometryCreateDeleyed=t.shared,this.refreshAttachedCloners(t),this.refreshAttachedPaths(t)}updateByPatchedOpGeometry(t,e,n){var r;let i=!1;0===t.type&&0===t.path.length&&Object.keys(t.props).includes("scaleBaked")&&this.geometryCreateDeleyed instanceof up&&this.chooseGeoemtryCache(n.shared).mutateIfUnique(this.geometryCreateDeleyed.data,e)===this.geometryCreateDeleyed&&(i=!0,this.geometryCreateDeleyed.mutateDirectlyScaleBaked(e,t.props.scaleBaked),this.refreshAttachedCloners(n),this.refreshAttachedPaths(n)),i||(null==(r=n.scene)||r.markGeometryCacheDirty(),this.createGeometryDelayed(n)),this.resetBBoxNeedsUpdate(),this.invalidateDownstreamBooleanData()}updateGeometryOnStateUpdate(t,e){this.createGeometryDelayed(e)}updateState(t,e){void 0!==t.geometry&&this.updateGeometryOnStateUpdate(t.geometry,e),super.updateState(t,e)}updateGeometryGroupsIfNeeded(){var t;Array.isArray(this.material)&&0===this.geometry.groups.length&&this.geometry.addGroup(0,Math.max((null==(t=this.geometry.getIndex())?void 0:t.count)??0,this.geometry.getAttribute("position").count),0)}updateEntityBoxSize(t,e){let n=this.geometry.userData.parameters;this.is2DType?t.set(0,0,.5*n.depth):this.isNonParametric?(t.setScalar(0),this.geometry.boundingSphere&&t.copy(this.geometry.boundingSphere.center),e.set(n.width,n.height,n.depth??0).multiplyScalar(.5)):t.setScalar(0),e.set(n.width,n.height,n.depth??0).multiplyScalar(.5)}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode&&this.bindMatrixInverse.copy(this.bindMatrix).invert()}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(t){let e=new p,n=this.geometry.attributes.skinWeight;for(let r=0,i=n.count;r<i;r++){e.fromBufferAttribute(n,r);let t=1/e.manhattanLength();t!==1/0?e.multiplyScalar(t):e.set(1,0,0,0),n.setXYZW(r,e.x,e.y,e.z,e.w)}}boneTransform(t,e){let n=this.skeleton;if(void 0===n)return;let r=this.geometry;wg.fromBufferAttribute(r.attributes.skinIndex,t),_g.fromBufferAttribute(r.attributes.skinWeight,t),xg.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let i=0;i<4;i++){let t=_g.getComponent(i);if(0!==t){let r=wg.getComponent(i);Ag.multiplyMatrices(n.bones[r].matrixWorld,n.boneInverses[r]),e.addScaledVector(Sg.copy(xg).applyMatrix4(Ag),t)}}return e.applyMatrix4(this.bindMatrixInverse)}};function Mg(t){if(Array.isArray(t.material)){for(let e of t.material)if(0===e.getLayersOfType("outline").length)return}else if(!(t.material instanceof Zm)||0===t.material.getLayersOfType("outline").length)return;t instanceof Og&&t.is2DAndNoDepth?function(t){if(t.geometry.attributes.extrudeNormals||!t.geometry.attributes.position)return;let e=t.geometry.attributes.position.array,n=new Float32Array(e.length),r=new o;for(let i=0;i<e.length;i+=3)r.set(e[i],e[i+1],e[i+2]).normalize(),n[i]=r.x,n[i+1]=r.y,n[i+2]=r.z;t.geometry.setAttribute("extrudeNormal",new S(n,3))}(t):function(t){var e,n;if(t.geometry.attributes.extrudeNormal||!t.geometry.attributes.position||!t.geometry.attributes.normal)return;let r=new Map,i=t.geometry.attributes,a=i.position.array,s=i.normal.array,l=new Float32Array(a.length);for(let h=0;h<a.length;h+=3){let t=`${a[h]}_${a[h+1]}_${a[h+2]}`,n=new o(s[h],s[h+1],s[h+2]);r.has(t)?null==(e=r.get(t))||e.normals.push(n):r.set(t,{normals:[n],result:new o})}r.forEach(((t,e)=>{for(let n of t.normals)t.result.add(n);t.result.divideScalar(t.normals.length)}));for(let o=0;o<a.length;o+=3){let t=`${a[o]}_${a[o+1]}_${a[o+2]}`,e=null==(n=r.get(t))?void 0:n.result;e&&(l[o]=e.x,l[o+1]=e.y,l[o+2]=e.z)}t.geometry.setAttribute("extrudeNormal",new S(l,3))}(t)}function Cg(t){if(!t.geometry.attributes.position)return;let e=t.geometry.attributes.position.array,r=new Float32Array(e.length),i=parseInt(t.uuid.replace(/\D/g,"")),a=[x.seededRandom(i),x.seededRandom(i+1e4),x.seededRandom(i+2e4)];for(let n=0;n<e.length;n++)r[n]=a[n%3];t.geometry.setAttribute("randomColor",new n(r,3))}tp.then((t=>{}));var Pg=new c,Dg=new o;function Tg(t){let e=!1;return t.scene.objects.traverse(((t,n)=>{"Mesh"===n.type&&"SubdivGeometry"===n.geometry.type&&(e=!0)})),e}var zg=class extends Og{constructor(t,e,n){super(t,e,n),this.data=e,this.hiddenMatrixOld=new s,this.smoothShading=!0,this.skipReactionUpdate=!1}chooseGeoemtryCache(t){return this.dataPatched.flatShading?t.geometryCache:t.geometryCache2}get subdivPointerNew(){return void 0!==this.localGeometry?this.subdivPointer:this.geometry.ensureSubdivPointer()}get originalGeometryNew(){return void 0!==this.localGeometry?this.originalGeometry:this.geometry.originalGeometry}get phongAngle(){return this.data.geometry.phongAngle??45}updateEntityBoxSize(t,e){let n=this.geometry.userData.parameters;t.copy(this.originalGeometryNew.boundingSphere.center),e.set(n.width,n.height,n.depth??0).multiplyScalar(.5)}createGeometryByControls(t){var e,n,r;if(!0===this.skipReactionUpdate)return;let i=null==(e=this.localGeometry)?void 0:e.uuid,{originalGeometry:a,subdividedGeometry:s,subdivPointer:o}=up.build(t,this.subdivPointer,this.smoothShading,this.hasNonUniformScale?this.shearScale:void 0);this.subdivPointer=o,void 0!==a&&(null==(n=this.originalGeometry)||n.dispose(),this.originalGeometry=a),void 0!==s&&(null==(r=this.subdividedGeometry)||r.dispose(),this.subdividedGeometry=s??void 0),this.localGeometry=this.subdividedGeometry??this.originalGeometry,Mg(this),Cg(this),this.calcBoundingBox(),i&&(this.localGeometry.uuid=i)}updateState(t,e){if(super.updateState(t,e),void 0!==t.flatShading){let n=this.material;this.material=n.getFlavor(!1,n.side,n.wireframe),this.smoothShading=!t.flatShading,this.createGeometryDelayed(e)}}updateMesh(t=!1){up.buildLevel(this.subdivPointer,!0,this.smoothShading?this.phongAngle:-1,this.originalGeometry,t&&this.hasNonUniformScale?this.shearScaleInv:void 0),this.subdividedGeometry&&up.buildLevel(this.subdivPointer,!1,this.smoothShading?this.phongAngle:-1,this.subdividedGeometry,t&&this.hasNonUniformScale?this.shearScaleInv:void 0)}updateTopology(){this.originalGeometry.dispose(),this.originalGeometry=up.buildLevel(this.subdivPointer,!0,this.smoothShading?this.phongAngle:-1),this.subdividedGeometry&&(this.subdividedGeometry.dispose(),this.subdividedGeometry=up.buildLevel(this.subdivPointer,!1,this.smoothShading?this.phongAngle:-1)),this.localGeometry=this.subdividedGeometry??this.originalGeometry}raycast(t,e){let n=this.localGeometry;this.localGeometry=this.originalGeometryNew,kp.prototype.raycast.call(this,t,e),this.localGeometry=n}activateSVDCompensation(){!this.hasNonUniformScale||(this.matrix.copy(this.matrixWorldRigid),this.hiddenMatrixOld.copy(this.hiddenMatrix),this.hiddenMatrix.copy(this.parent.matrixWorld).invert())}deactivateSVDCompensation(){!this.hasNonUniformScale||(this.updateMatrix(),this.hasNonUniformScale=void 0,this.hiddenMatrix.copy(this.hiddenMatrixOld))}calcBoundingBox(){let t=this.originalGeometry;null===t.boundingSphere&&(t.boundingSphere=new m,this.subdividedGeometry&&(this.subdividedGeometry.boundingSphere=t.boundingSphere));let e=t.attributes.position,n=t.boundingSphere.center;Pg.setFromBufferAttribute(e),Pg.getCenter(n),t.boundingSphere.radius=n.distanceTo(Pg.max),isNaN(t.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this),Pg.getSize(Dg),this.hasNonUniformScale&&Dg.divide(this.scale);let r={width:Dg.x,height:Dg.y,depth:Dg.z};return this.geometry.userData.parameters=r,r}updateBoundingSphere(t){let e=this.originalGeometry;Pg.min.set(t[0],t[2],t[4]),Pg.max.set(t[1],t[3],t[5]),this.hasNonUniformScale&&(Pg.min.applyMatrix4(this.shearScaleInv),Pg.max.applyMatrix4(this.shearScaleInv)),null===e.boundingSphere&&(e.boundingSphere=new m);let n=e.boundingSphere.center;Pg.getCenter(n),e.boundingSphere.radius=n.distanceTo(Pg.max)}freeSubdivPointer(){var t,e;this.subdivPointer&&(up.freeSubdivPointer(this.subdivPointer),this.subdivPointer=0),this.localGeometry=void 0,null==(t=this.originalGeometry)||t.dispose(),null==(e=this.subdividedGeometry)||e.dispose()}dispose(){super.dispose(),this.freeSubdivPointer()}updateByPatchedOpGeometry(t,e,n){super.updateByPatchedOpGeometry(t,e,n),this.localGeometry&&this.createGeometryByControls(e)}},Eg={x:[1,0,0],"-x":[-1,0,0],y:[0,1,0],"-y":[0,-1,0],z:[0,0,1],"-z":[0,0,-1]},Lg={polygon_center:0,edge:1,vertex:2},Ig=(t,e)=>(n,r)=>e&&0!==n&&0!==t?t*r/100:0,Ng=(t,e)=>{let n=Math.abs(e),r=-1*n;return(t- -1)*(n-r)/2+r};var jg=new o,Bg=new o,Ug=new o,kg=new o;function Rg(t,e){let n=Ug.fromArray(t),r=kg.fromArray(e);Bg.copy(r).sub(n);let i=Bg.length();return Bg.normalize().multiplyScalar(.5*i),jg.copy(n).add(Bg).toArray()}var Fg=new a,Vg=new o,Gg=new o,Hg=new o;var Wg=t=>.5*(1-Math.cos(t*Math.PI)),qg=class{constructor(){this.perlin=new Array(4096)}noise(t,e=0,n=0){if(null==this.perlin){this.perlin=new Array(4096);for(let t=0;t<4096;t++)this.perlin[t]=Math.random()}t<0&&(t=-t),e<0&&(e=-e),n<0&&(n=-n);let r,i,a,s,o,l=Math.floor(t),h=Math.floor(e),d=Math.floor(n),c=t-l,u=e-h,p=n-d,f=0,m=.5;for(let g=0;g<4;g++){let t=l+(h<<4)+(d<<8);r=Wg(c),i=Wg(u),a=this.perlin[4095&t],a+=r*(this.perlin[t+1&4095]-a),s=this.perlin[t+16&4095],s+=r*(this.perlin[t+16+1&4095]-s),a+=i*(s-a),t+=256,s=this.perlin[4095&t],s+=r*(this.perlin[t+1&4095]-s),o=this.perlin[t+16&4095],o+=r*(this.perlin[t+16+1&4095]-o),s+=i*(o-s),a+=Wg(p)*(s-a),f+=a*m,m*=.5,l<<=1,c*=2,h<<=1,u*=2,d<<=1,p*=2,c>=1&&(l++,c--),u>=1&&(h++,u--),p>=1&&(d++,p--)}return f}noiseSeed(t){let e=(()=>{let t,e;return{setSeed(n){e=t=(n??4294967296*Math.random())>>>0},getSeed:()=>t,rand:()=>(e=(1664525*e+1013904223)%4294967296,e/4294967296)}})();e.setSeed(t),this.perlin=new Array(4096);for(let n=0;n<4096;n++)this.perlin[n]=e.rand()}},$g=new o,Xg=new s,Yg=new f;function Kg(t){let e=!1;return t.scene.objects.traverse(((t,n)=>{"Mesh"===n.type&&"TextGeometry"===n.geometry.type&&(e=!0)})),e}var Zg,Qg,Jg,tv,ev=class extends Og{constructor(t,e,n){super(t,e,n),this.data=e}get textGeometry(){return this.geometry}get charWidths(){return this.textGeometry.charWidths}get charCoords(){return this.textGeometry.charCoords}get wrappedText(){return this.textGeometry.wrappedText}get font(){return this.textGeometry.font}get initialOffsetY(){var t;let e=this.dataPatched;return(null==(t=this.font)?void 0:t.getLineInitialOffsetY(this.lineHeight,this.wrappedText.length,e.geometry.height,this.fontScale,e.geometry.verticalAlign))??0}get fontScale(){let t=this.dataPatched;return this.font?t.geometry.fontSize/this.font.unitsPerEm:1}get AD(){return Math.abs(this.ascender-this.descender)}get ascender(){var t;return((null==(t=this.font)?void 0:t.ascender)??1)*this.fontScale}get descender(){var t;return((null==(t=this.font)?void 0:t.descender)??1)*this.fontScale}get lineHeight(){let t=this.dataPatched;return t.geometry.fontSize*t.geometry.lineHeight}raycast(t,e){let{matrixWorld:n}=this;if(!isNaN(t.ray.origin.x)&&0!==this.scale.x&&0!==this.scale.y&&0!==this.scale.z&&(Xg.copy(n).invert(),Yg.copy(t.ray).applyMatrix4(Xg),Yg.intersectBox(this.singleBBox,$g))){let r=$g.applyMatrix4(n),i=t.ray.origin.distanceTo(r);e.push({distance:i,point:r.clone(),object:this})}}},nv=1e-4,rv=new o,iv=new o;tp.then((t=>{Qg=[(Zg=t).get_face_center,Zg.get_edge_midpoint,Zg.get_vertex_position],Jg=[Zg.get_face_normal,Zg.get_edge_normal,Zg.get_vertex_normal],tv=[Zg.face_count,Zg.edge_count,Zg.vertex_count]}));var av=new s,sv=new s,ov=new o,lv=new o,hv=new o,dv=new o,cv=new o,uv=new o,pv=new qg,fv=class extends(bd(d)){constructor(t,e){super(),this.parameters=e,this.objectForSample=void 0,this._pendingMediaLoad=!1,this.object=t}resetOnMove(){this.removeFromParent(),this.parent=null}expandClones(t){if(null===this.parent)this.updateState(this.parameters,t);else for(let e of this.children)e instanceof wd&&e.expand()}invalidateTransform(t){this.matrixWorldNeedsUpdate=!0,this.traverse((e=>{e instanceof wd&&e.object===t&&(e.matrixWorldNeedsUpdate=!0)}))}onObjUpdateMatrix(){"toObject"!==this.parameters.type&&(this.matrixWorldNeedsUpdate=!0)}update(){switch(this._updateCount(),this.parameters.type){case"radial":this._updateRadial(this.parameters);break;case"linear":this._updateLinear(this.parameters);break;case"grid":this._updateGrid(this.parameters);break;case"toObject":this._updateToObject(this.parameters)}for(let t of this.children)t.updateMatrix(),t.hasNonUniformScale&&(t.updateMatrixWorld(),t.updateMatrixWorldSVD())}_updateCount(t){let e;if(e=void 0!==t?t:"grid"===this.parameters.type?Math.round(this.parameters.grid.count[0])*Math.round(this.parameters.grid.count[1])*Math.round(this.parameters.grid.count[2]):this.parameters.count,"toObject"===this.parameters.type&&!this.parameters.toObject.object&&(e=0),"toObject"===this.parameters.type&&this.objectForSample){for(let e=0,n=this.children.length;e<n;++e)this.remove(this.children[0]);let t=this.children;if(t.length===e)return;if(t.length<e)for(let n=0,r=e-t.length;n<r;++n){let t=new wd(this.object);t.expand(),this.add(t)}else for(let n=0,r=t.length-e;n<r;++n)this.remove(t[n])}else{if(this.children.length===e)return;if(this.children.length<e)for(let t=0,n=e-this.children.length;t<n;++t){let t=new wd(this.object);t.expand(),this.add(t)}else for(let t=0,n=this.children.length-e;t<n;++t)this.remove(this.children[0])}}_updateRadial(t){let e,n=t.radial,r=n.start*x.DEG2RAD,i=r-n.end*x.DEG2RAD,a=new vt(n.rotation[0],n.rotation[1],n.rotation[2]);switch(n.axis){case"z":e=new o(0,0,1);break;case"y":e=new o(0,1,0);break;default:e=new o(1,0,0)}let s=t.randomnessObject??gl.defaultData([1,1,1]).randomnessObject,l="perlin"===s.noiseType;pv.noiseSeed(s.seed);let h=dd((0,rd.default)(s.seed)),d=Ig(s.strength,this.parameters.randomness);for(let[o,c]of this.children.entries()){let u=o*(s.freqScale/10)+s.movement,p=l?pv.noise(u):h(u,u),f=o+1;c.scale.x=n.scale[0]+d(f,Ng(p,s.scale[0]))||nv,c.scale.y=n.scale[1]+d(f,Ng(p,s.scale[1]))||nv,c.scale.z=n.scale[2]+d(f,Ng(p,s.scale[2]))||nv,c.position.setScalar(0);let m=i/t.count*o-r;switch(n.axis){case"x":c.rotation.set(0,m,0);break;case"y":c.rotation.set(0,0,m);break;case"z":c.rotation.set(m,0,0)}c.translateOnAxis(e,n.radius),c.position.x+=n.position[0]+d(f,Ng(p,s.position[0])),c.position.y+=n.position[1]+d(f,Ng(p,s.position[1])),c.position.z+=n.position[2]+d(f,Ng(p,s.position[2]));let g=d(f,Ng(p,s.rotation[0])),v=d(f,Ng(p,s.rotation[1])),y=d(f,Ng(p,s.rotation[2]));!0===n.alignment?(c.rotation.x+=a.x+g,c.rotation.y+=a.y+v,c.rotation.z+=a.z+y):c.rotation.set(a.x+g,a.y+v,a.z+y)}}_updateLinear(t){if("linear"!==t.type)throw new Error;let e=t.linear,n=new vt(e.rotation[0],e.rotation[1],e.rotation[2]),r=t.randomnessObject??gl.defaultData([1,1,1]).randomnessObject,i="perlin"===r.noiseType;pv.noiseSeed(r.seed);let a=dd((0,rd.default)(r.seed)),s=Ig(r.strength,this.parameters.randomness);for(let[o,l]of this.children.entries()){let t=o*(r.freqScale/10)+r.movement,h=i?pv.noise(t):a(t,t),d=o+1,c=s(d,Ng(h,r.rotation[0])),u=s(d,Ng(h,r.rotation[1])),p=s(d,Ng(h,r.rotation[2]));l.scale.x=1+(e.scale[0]-1)*o+s(d,Ng(h,r.scale[0]))||nv,l.scale.y=1+(e.scale[1]-1)*o+s(d,Ng(h,r.scale[1]))||nv,l.scale.z=1+(e.scale[2]-1)*o+s(d,Ng(h,r.scale[2]))||nv,l.rotation.x=n.x*o+c,l.rotation.y=n.y*o+u,l.rotation.z=n.z*o+p,l.position.x=e.position[0]*o+s(d,Ng(h,r.position[0])),l.position.y=e.position[1]*o+s(d,Ng(h,r.position[1])),l.position.z=e.position[2]*o+s(d,Ng(h,r.position[2]))}}_updateGrid(t){let e=0,n=t.grid,r=t.randomnessObject??gl.defaultData([1,1,1]).randomnessObject,i=Ig(r.strength,this.parameters.randomness),a="perlin"===r.noiseType;pv.noiseSeed(r.seed);let s=function(t=Math.random){let e=cd(t),n=new Float64Array(e).map((t=>hd[t%12*3])),r=new Float64Array(e).map((t=>hd[t%12*3+1])),i=new Float64Array(e).map((t=>hd[t%12*3+2]));return function(t,a,s){let o,l,h,d,c,u,p,f,m,g,v=.3333333333333333*(t+a+s),y=od(t+v),b=od(a+v),x=od(s+v),w=(y+b+x)*sd,_=t-(y-w),S=a-(b-w),A=s-(x-w);_>=S?S>=A?(c=1,u=0,p=0,f=1,m=1,g=0):_>=A?(c=1,u=0,p=0,f=1,m=0,g=1):(c=0,u=0,p=1,f=1,m=0,g=1):S<A?(c=0,u=0,p=1,f=0,m=1,g=1):_<A?(c=0,u=1,p=0,f=0,m=1,g=1):(c=0,u=1,p=0,f=1,m=1,g=0);let O=_-c+sd,M=S-u+sd,C=A-p+sd,P=_-f+2*sd,D=S-m+2*sd,T=A-g+2*sd,z=_-1+.5,E=S-1+.5,L=A-1+.5,I=255&y,N=255&b,j=255&x,B=.6-_*_-S*S-A*A;if(B<0)o=0;else{let t=I+e[N+e[j]];B*=B,o=B*B*(n[t]*_+r[t]*S+i[t]*A)}let U=.6-O*O-M*M-C*C;if(U<0)l=0;else{let t=I+c+e[N+u+e[j+p]];U*=U,l=U*U*(n[t]*O+r[t]*M+i[t]*C)}let k=.6-P*P-D*D-T*T;if(k<0)h=0;else{let t=I+f+e[N+m+e[j+g]];k*=k,h=k*k*(n[t]*P+r[t]*D+i[t]*T)}let R=.6-z*z-E*E-L*L;if(R<0)d=0;else{let t=I+1+e[N+1+e[j+1]];R*=R,d=R*R*(n[t]*z+r[t]*E+i[t]*L)}return 32*(o+l+h+d)}}((0,rd.default)(r.seed));if(!0===n.useCenter){let t={x:n.count[0]%2==0?2:1,y:n.count[1]%2==0?2:1,z:n.count[2]%2==0?2:1},l=new o(n.size[0]*(n.count[0]-t.x)*.5,n.size[1]*(n.count[1]-t.y)*.5,n.size[2]*(n.count[2]-t.z)*.5);for(let o=0;o<n.count[0];o++)for(let t=0;t<n.count[1];t++)for(let h=0;h<n.count[2];h++){let d=[(o+1)*(r.freqScale/10)+r.movement,(t+1)*(r.freqScale/10)+r.movement,(h+1)*(r.freqScale/10)+r.movement],c=a?pv.noise(...d):s(...d),u=this.children[e++];u.scale.x=1+i(e,Ng(c,r.scale[0]))||nv,u.scale.y=1+i(e,Ng(c,r.scale[1]))||nv,u.scale.z=1+i(e,Ng(c,r.scale[2]))||nv;let p=i(e,Ng(c,r.rotation[0])),f=i(e,Ng(c,r.rotation[1])),m=i(e,Ng(c,r.rotation[2]));u.rotation.set(p,f,m),u.position.x=n.size[0]*o-l.x+i(e,Ng(c,r.position[0])),u.position.y=n.size[1]*t-l.y+i(e,Ng(c,r.position[1])),u.position.z=n.size[2]*h-l.z+i(e,Ng(c,r.position[2]))}}else for(let o=0;o<n.count[0];o++)for(let t=0;t<n.count[1];t++)for(let l=0;l<n.count[2];l++){let h=[(o+1)*(r.freqScale/10)+r.movement,(t+1)*(r.freqScale/10)+r.movement,(l+1)*(r.freqScale/10)+r.movement],d=a?pv.noise(...h):s(...h),c=this.children[e++];c.scale.x=1+i(e,Ng(d,r.scale[0]))||nv,c.scale.y=1+i(e,Ng(d,r.scale[1]))||nv,c.scale.z=1+i(e,Ng(d,r.scale[2]))||nv;let u=i(e,Ng(d,r.rotation[0])),p=i(e,Ng(d,r.rotation[1])),f=i(e,Ng(d,r.rotation[2]));c.rotation.set(u,p,f),c.position.x=n.size[0]*o+i(e,Ng(d,r.position[0])),c.position.y=-n.size[1]*t+i(e,Ng(d,r.position[1])),c.position.z=-n.size[2]*l+i(e,Ng(d,r.position[2]))}}_updateToObject(t){var e;if("toObject"!==t.type)throw new Error;let{toObject:n}=t,r=new vt(n.rotation[0],n.rotation[1],n.rotation[2]),i=t.randomnessObject??gl.defaultData([1,1,1]).randomnessObject,a="perlin"===i.noiseType;pv.noiseSeed(i.seed);let l=dd((0,rd.default)(i.seed)),h=Ig(i.strength,this.parameters.randomness);if(!n.object){for(let[,t]of this.children.entries())t.position.set(0,0,0),t.scale.setScalar(1),t.rotation.set(0,0,0);return void(this.objectForSample=void 0)}if(!this.objectForSample)return;if(this.objectForSample instanceof ev){if(!(null==(e=this.objectForSample.font)?void 0:e.isLoaded)||void 0===this.objectForSample.geometry.attributes.position)return void(this._pendingMediaLoad=!0);this._pendingMediaLoad=!1}if(void 0===this.objectForSample.geometry&&this.objectForSample.isAncestorOf(this.object.uuid))return void console.warn(`Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child/descendant of the object it's being cloned to. Please re-parent it so that they are siblings instead.`);let d=this.getSubdivData(),c=[],u=t=>{let e=t.length;return[t.map((t=>t[0])).reduce(((t,e)=>t+e),0)/e,t.map((t=>t[1])).reduce(((t,e)=>t+e),0)/e,t.map((t=>t[2])).reduce(((t,e)=>t+e),0)/e]},p=t=>Math.round(1e6*t)/1e6;d.forEach((t=>{let e=d.filter((e=>p(t.pos[0])===p(e.pos[0])&&p(t.pos[1])===p(e.pos[1])&&p(t.pos[2])===p(e.pos[2])));e.length>1?c.push({pos:t.pos,norm:u(e.map((t=>t.norm)))}):c.push(t)}));let f=function(t){let e=[],n={};for(var r=0,i=t.length;r<i;r++){var a=JSON.stringify(t[r].pos.map((t=>Math.round(1e4*t)/1e4)));n[a]||(e.push(t[r]),n[a]=!0)}return e}(c);if(f.length>0){let t=Math.round(f.length*n.count/100);this._updateCount(t)}else{let t=this.objectForSample.geometry.getAttribute("position");if(!t||isNaN(t.count)||0===t.count)return void console.warn(`Oh no! The object "${this.object.name}" (${this.object.uuid}) cannot be cloned on the surface of "${this.objectForSample.name}" (${this.objectForSample.uuid}) because the latter does not have a valid geometry.`)}this.objectForSample.updateMatrixWorld();let m=new class{constructor(t){this.weightAttribute=null;let e=t.geometry;if(!e.isBufferGeometry||3!==e.attributes.position.itemSize)throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.");e.index&&(e=e.toNonIndexed()),this.geometry=e,this.randomFunction=Math.random,this.positionAttribute=this.geometry.getAttribute("position"),this.distribution=null}build(){let t=this.positionAttribute,e=new Float32Array(t.count/3);for(let r=0;r<t.count;r+=3){let n=1;pd.a.fromBufferAttribute(t,r),pd.b.fromBufferAttribute(t,r+1),pd.c.fromBufferAttribute(t,r+2),n*=pd.getArea(),e[r/3]=n}this.distribution=new Float32Array(t.count/3);let n=0;for(let r=0;r<e.length;r++)n+=e[r],this.distribution[r]=n;return this}setRandomGenerator(t){return this.randomFunction=t,this}sample(t,e){if(this.distribution){let n=this.distribution[this.distribution.length-1],r=this.binarySearch(this.randomFunction()*n);return this.sampleFace(r,t,e)}}binarySearch(t){if(!this.distribution)return 0;let e=this.distribution,n=0,r=e.length-1,i=-1;for(;n<=r;){let a=Math.ceil((n+r)/2);if(0===a||e[a-1]<=t&&e[a]>t){i=a;break}t<e[a]?r=a-1:n=a+1}return i}sampleFace(t,e,n){let r=this.randomFunction(),i=this.randomFunction();return r+i>1&&(r=1-r,i=1-i),pd.a.fromBufferAttribute(this.positionAttribute,3*t),pd.b.fromBufferAttribute(this.positionAttribute,3*t+1),pd.c.fromBufferAttribute(this.positionAttribute,3*t+2),e.set(0,0,0).addScaledVector(pd.a,r).addScaledVector(pd.b,i).addScaledVector(pd.c,1-(r+i)),pd.getNormal(n),this}}(this.objectForSample).build(),g=Eg[n.axis],v=this.children;m.setRandomGenerator((0,rd.default)(this.object.uuid+n.seed));for(let[y,b]of v.entries()){let t=y*(i.freqScale/10)+i.movement,e=a?pv.noise(t):l(t,t),d=y+1,c=h(d,Ng(e,i.rotation[0])),u=h(d,Ng(e,i.rotation[1])),p=h(d,Ng(e,i.rotation[2]));"random"===n.spreadType?m.sample(hv,dv):(f.length&&(hv.fromArray(f[y].pos),dv.fromArray(f[y].norm)),this.objectForSample instanceof zg&&hv.applyMatrix4(av.copy(this.objectForSample.matrixWorld).invert())),hv.applyMatrix4(this.object.hiddenMatrix.clone().invert()),b.position.copy(hv),ov.fromArray(g);let v="normal"===n.align?dv:this.object.getWorldDirection(uv),x=lv.fromArray(n.position);lv.x+=lv.x+h(d,Ng(e,i.position[0])),lv.y+=lv.y+h(d,Ng(e,i.position[1])),lv.z+=lv.z+h(d,Ng(e,i.position[2]));let w=Math.acos(v.dot(ov)),_=cv.crossVectors(ov,v).normalize(),S=sv.makeRotationAxis(_,w),A=v.clone().cross(this.object.up).normalize(),O=A.clone().cross(v).normalize(),M=(new s).makeBasis(A,v,O),C=new o(ov.y,ov.z,ov.x).normalize(),P=C.clone().cross(ov).normalize(),D=(new s).makeBasis(C,ov,P).invert(),T=(new s).multiplyMatrices(M,D);b.rotation.setFromRotationMatrix(T),x.applyMatrix4(S),b.position.add(x),b.rotation.x=b.rotation.x+r.x+c,b.rotation.y=b.rotation.y+r.y+u,b.rotation.z=b.rotation.z+r.z+p,b.scale.setScalar(1),b.scale.x=b.scale.x+n.scale[0]+h(d,Ng(e,i.scale[0]))||nv,b.scale.y=b.scale.y+n.scale[1]+h(d,Ng(e,i.scale[1]))||nv,b.scale.z=b.scale.z+n.scale[2]+h(d,Ng(e,i.scale[2]))||nv,b.scale.multiply(this.object.scale),b.hiddenMatrix=this.object.hiddenMatrix}}getSubdivData(){if(!this.objectForSample)return[];let t=this.parameters.toObject.spreadType;if("random"===t)return[];if(this.objectForSample instanceof zg){let e=this.objectForSample,n=Lg[t],r=tv[n],i=Qg[n],a=Jg[n],s=[],o=r(e.subdivPointerNew);for(let t=0;t<=o-1;t++){let n=i(e.subdivPointerNew,t),r=a(e.subdivPointerNew,t);rv.fromArray(n).applyMatrix4(e.matrixWorld),iv.fromArray(r),s.push({pos:rv.toArray(),norm:iv.toArray()})}return s}return(this.objectForSample.geometry.index?function(t){let e=[];for(let n=0;n<=t.index.count;n++)if(Vg.fromArray(t.index.array,3*n),Fg.setFromAttributeAndIndices(t.attributes.position,Vg.x,Vg.y,Vg.z),Fg.getNormal(Gg),Fg.getMidpoint(Hg),!(isNaN(Hg.x)||isNaN(Hg.y)||isNaN(Hg.z))){let{a:t,b:n,c:r}=Fg,i=t.toArray(),a=n.toArray(),s=r.toArray(),o=t.distanceTo(n),l=n.distanceTo(r),h=r.distanceTo(t),d=Rg(i,a),c=Rg(a,s),u=Rg(s,i),p=[o,l,h],f=Math.max(...p),m=p.filter((t=>Math.round(t)===Math.round(f))).length>1,g=[],v=Fg.getMidpoint(Hg).toArray();f===o&&!m&&(g=[c,u,u],v=d),f===l&&!m&&(g=[d,u,u],v=c),f===h&&!m&&(g=[d,c,c],v=u),m&&(g=[d,c,u]),e.push({vertices:[i,a,s],faceCenters:g,midpoint:v,norm:Fg.getNormal(Gg).toArray()})}return e}(this.objectForSample.geometry):function(t){let e=[],{position:n}=t.attributes;for(let r=0;r<n.count;r++){Fg.setFromAttributeAndIndices(n,3*r,3*r+1,3*r+2),Fg.getNormal(Gg),Fg.getMidpoint(Hg);let t=Fg.a.toArray(),i=Fg.b.toArray(),a=Fg.c.toArray();e.push({vertices:[t,i,a],faceCenters:[Rg(t,i),Rg(i,a),Rg(a,t)],midpoint:Hg.toArray(),norm:Gg.toArray()})}return e}(this.objectForSample.geometry)).map(((e,n)=>"polygon_center"===t?{pos:e.midpoint,norm:e.norm}:"vertex"===t?[{pos:e.vertices[0],norm:e.norm},{pos:e.vertices[1],norm:e.norm},{pos:e.vertices[2],norm:e.norm}]:"edge"===t?[{pos:e.faceCenters[0],norm:e.norm},{pos:e.faceCenters[1],norm:e.norm},{pos:e.faceCenters[2],norm:e.norm}]:[])).flat()}updateState(t,e){var n;if(this.parameters=ia(t),"toObject"!==this.parameters.type)(null===this.parent||this.parent!==this.object)&&(this.removeFromParent(),null==(n=this.object.parent)||n.add(this),this.matrix=this.object.matrix,this.hiddenMatrix=this.object.hiddenMatrix,this.matrixWorldNeedsUpdate=!0,this.matrixAutoUpdate=!1);else if(null===this.parent||this.parent.uuid!==this.parameters.toObject.object){this.removeFromParent();let t=e.find(this.parameters.toObject.object);this.objectForSample=t instanceof kp?t:void 0,this.matrix=new s,this.hiddenMatrix=new s,this.matrixWorldNeedsUpdate=!0,this.matrixAutoUpdate=!1,t&&t.add(this)}this.update()}get pendingMediaLoad(){return this._pendingMediaLoad}},mv=t=>{var e;return(e=class extends t{}).geometryHelper=new O(30,30,30),e},gv=new f,vv=new m,yv=new s,bv=(t,e,n,r,i=!1)=>{let a=e,s=t.matrixWorld;if(null===a.boundingSphere&&a.computeBoundingSphere(),vv.copy(a.boundingSphere),vv.applyMatrix4(s),!1===n.ray.intersectsSphere(vv)||(yv.copy(s).invert(),gv.copy(n.ray).applyMatrix4(yv),null!==a.boundingBox&&!1===gv.intersectsBox(a.boundingBox)))return;let l,h,d,c,u,p,f=a.index,m=a.attributes.position,g=a.drawRange;if(!1===i){for(u=Math.max(0,g.start),p=Math.min(f.count,g.start+g.count);u<p;u+=3)if(h=f.getX(u),d=f.getX(u+1),c=f.getX(u+2),l=v(t,n,gv,m,h,d,c),l)return l.faceIndex=Math.floor(u/3),void r.push(l)}else{let e=a.attributes.position,i=new o,s=new o,l=new o,h=new o,d=2,c=1/((t.scale.x+t.scale.y+t.scale.z)/3),u=c*c;for(let a=Math.max(0,g.start),o=Math.min(e.count,g.start+g.count)-1;a<o;a+=d){if(i.fromBufferAttribute(e,a),s.fromBufferAttribute(e,a+1),gv.distanceSqToSegment(i,s,h,l)>u)continue;h.applyMatrix4(t.matrixWorld);let o=n.ray.origin.distanceTo(h);o<n.near||o>n.far||r.push({distance:o,point:l.clone().applyMatrix4(t.matrixWorld),object:t})}}function v(t,e,n,r,i,a,s){let l=new o,h=new o,d=new o,c=new o,u=new o;if(l.fromBufferAttribute(r,i),h.fromBufferAttribute(r,a),d.fromBufferAttribute(r,s),null===n.intersectTriangle(l,h,d,!1,c))return null;u.copy(c),u.applyMatrix4(t.matrixWorld);let p=e.ray.origin.distanceTo(u);return p<e.near||p>e.far?null:{faceIndex:1,distance:p,point:u.clone(),object:t}}},xv=new o,wv=new g,_v=class extends X{constructor(t){let n=new e,r=new Y({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],a=[],s={},o=new _(15711266),l=new _(15711266),h=new _(2857471);function d(t,e,n){c(t,n),c(e,n)}function c(t,e){i.push(0,0,0),a.push(e.r,e.g,e.b),void 0===s[t]&&(s[t]=[]),s[t].push(i.length/3-1)}d("n1","n2",o),d("n2","n4",o),d("n4","n3",o),d("n3","n1",o),d("f1","f2",o),d("f2","f4",o),d("f4","f3",o),d("f3","f1",o),d("n1","f1",o),d("n2","f2",o),d("n3","f3",o),d("n4","f4",o),d("p","n1",l),d("p","n2",l),d("p","n3",l),d("p","n4",l),d("u1","u2",h),d("u2","u3",h),d("u3","u1",h),n.setAttribute("position",new S(i,3)),n.setAttribute("color",new S(a,3)),super(n,r),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update()}update(){let t=this.geometry,e=this.pointMap;wv.projectionMatrixInverse.elements=[.5112609807824982,-0,-0,-0,-0,.41421356237309503,-0,-0,-0,-0,-0,-.099999,-0,-0,-1.0000000000000002,.100001];let n=.8;Sv("n1",e,t,wv,-1,-1,n),Sv("n2",e,t,wv,1,-1,n),Sv("n3",e,t,wv,-1,1,n),Sv("n4",e,t,wv,1,1,n);let r=n;Sv("f1",e,t,wv,-1,-1,r),Sv("f2",e,t,wv,1,-1,r),Sv("f3",e,t,wv,-1,1,r),Sv("f4",e,t,wv,1,1,r);Sv("u1",e,t,wv,.35,1.1,.8),Sv("u2",e,t,wv,-.35,1.1,.8),Sv("u3",e,t,wv,0,1.55,.8),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}};function Sv(t,e,n,r,i,a,s){xv.set(i,a,s).unproject(r);let o=e[t];if(void 0!==o){let t=n.getAttribute("position");for(let e=0,n=o.length;e<n;e++)t.setXYZ(o[e],xv.x,xv.y,xv.z)}}var Av,Ov=class extends(mv(_v)){constructor(t){super(t),this.object=t,this.object=t,this.name=`CombinedCameraHelper: ${t.uuid}`}updateMatrixWorld(t){super.updateMatrixWorld(t),this.updateTarget()}updateTarget(){let t=this.object.getTarget();this.updateWorldMatrix(!0,!1),this.worldToLocal(t)}raycast(t,e){bv(this.object,this.geometry,t,e,!0)}};(Av||(Av={})).is=t=>"objectHelper"in t;var Mv,Cv=(t,e)=>class extends(Fd(t)){constructor(){super(...arguments),this.objectHelper=new e(this),this.gizmos={}}get geometryHelper(){return e.geometryHelper}raycast(t,e){this.objectHelper.raycast(t,e)}showGizmos(){for(let t in this.gizmos){let e=this.gizmos[t];e instanceof yt&&(e.visible=!0)}}updateEntityBoxSize(t,e){this.objectHelper.visible&&this.geometryHelper instanceof O?(t.setScalar(0),e.set(this.geometryHelper.parameters.width,this.geometryHelper.parameters.height,this.geometryHelper.parameters.height).multiplyScalar(.5)):super.updateEntityBoxSize(t,e)}hideGizmos(){for(let t in this.gizmos){let e=this.gizmos[t];e instanceof yt&&(e.visible=!1)}}},Pv=new o,Dv=new o,Tv=new bt,zv=new o,Ev=new o,Lv=new o,Iv=class extends(Cv(g,Ov)){constructor(t="",e={...hh.defaultData,name:""}){super(),this._cameraType="OrthographicCamera",this.targetOffset=ml.DefaultTargetOffset,this.isUpVectorFlipped=!1,this.angleOffsetFromUp=0,this.wasMovedByUser=!1,this.wasMovedBySwitchCameraAction=!1,this.super_Entity(t,e),this.previousProjectionMatrix=new s,this.matrixAutoUpdate=!0,this.width=window.innerWidth,this.height=window.innerHeight;let n=this.width,r=this.height;this.orthoCamera=new ut(-.5*n,.5*n,.5*r,-.5*r,-5e4,1e4),this.perspCamera=new pt(45,n/r,50,1e4),this.left=this.orthoCamera.left,this.right=this.orthoCamera.right,this.top=this.orthoCamera.top,this.bottom=this.orthoCamera.bottom,this.far=this.orthoCamera.far,this.view=this.orthoCamera.view,this.aspect=this.perspCamera.aspect,this.focus=this.perspCamera.focus,this.filmGauge=this.perspCamera.filmGauge,this.filmOffset=this.perspCamera.filmOffset,this.objectHelper.update()}get isPerspectiveCamera(){return"PerspectiveCamera"===this.cameraType}get isOrthographicCamera(){return!this.isPerspectiveCamera}get cameraType(){return this._cameraType}set fov(t){this.perspCamera.fov=t}get fov(){return this.perspCamera.fov}setNear(t,e){"PerspectiveCamera"===t?this.perspCamera.near=e:this.orthoCamera.near=e}setZoom(t,e){e>=0&&("PerspectiveCamera"===t?this.perspCamera.zoom=e:this.orthoCamera.zoom=e)}set cameraType(t){"PerspectiveCamera"===t?this.toPerspective():"OrthographicCamera"===t&&this.toOrthographic()}get near(){return"PerspectiveCamera"===this._cameraType?this.perspCamera.near:this.orthoCamera.near}set near(t){"PerspectiveCamera"===this._cameraType?this.perspCamera.near=t:this.orthoCamera.near=t}get zoom(){return"PerspectiveCamera"===this._cameraType?this.perspCamera.zoom:this.orthoCamera.zoom}set zoom(t){t>=0&&("PerspectiveCamera"===this._cameraType?this.perspCamera.zoom=t:this.orthoCamera.zoom=t)}lookAt(t,e,n){"number"==typeof t&&(t=new o(t,e,n)),super.lookAt(t),this.getWorldPosition(Pv),this.targetOffset=Pv.distanceTo(t)}getTarget(t=new o){return this.getWorldDirection(Dv),this.getWorldPosition(Pv),Dv.multiplyScalar(this.targetOffset),t.copy(Pv).add(Dv),t}getDistanceToTarget(){let t=this.getTarget();return this.getWorldPosition(Pv),Pv.distanceTo(t)}updateUp(){this.getWorldQuaternion(Tv),zv.set(0,0,1).applyQuaternion(Tv),Ev.copy(d.DEFAULT_UP),this.isUpVectorFlipped&&Ev.negate(),Ev.applyQuaternion(Tv),Lv.copy(d.DEFAULT_UP).projectOnPlane(zv),this.angleOffsetFromUp=Lv.angleTo(Ev),this.angleOffsetFromUp*=Lv.cross(Ev).dot(zv)>=0?1:-1}updateTransformState(t,e){let n=super.updateTransformState(t,e);return void 0!==t.isUpVectorFlipped&&(this.isUpVectorFlipped=t.isUpVectorFlipped),this.updateUp(),n}getViewFrontToObject(t){let e=t.getWorldPosition(new o),n=t.getWorldDirection(new o).multiplyScalar(this.targetOffset);return{position:e.clone().add(n),target:e}}getViewToTarget(t){let e=this.getWorldDirection(new o).multiplyScalar(this.targetOffset);return{position:t.clone().sub(e),target:t}}getViewToObject(t){let e=new o;return t.getWorldPosition(e),this.getViewToTarget(e)}setViewplaneSize(t,e,n=!1){if(this.aspect=t/e,n){let n=t>e?this.aspect:1,r=t>e?1:this.aspect;this.left=-395*n,this.right=395*n,this.top=1/r*395,this.bottom=1/r*-395}else this.left=.5*-t,this.right=.5*t,this.top=.5*e,this.bottom=.5*-e;this.updateProjectionMatrix()}copyViewPlaneSize(t){this.aspect=t.aspect,this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.updateProjectionMatrix()}toOrthographic(){this.orthoCamera.left=this.left,this.orthoCamera.right=this.right,this.orthoCamera.top=this.top,this.orthoCamera.bottom=this.bottom,this.orthoCamera.view=this.view,this.orthoCamera.far=this.far,this.orthoCamera.updateProjectionMatrix(),this.projectionMatrix=this.orthoCamera.projectionMatrix,this.projectionMatrixInverse=this.orthoCamera.projectionMatrixInverse,this._cameraType="OrthographicCamera",this.objectHelper&&this.objectHelper.update()}toPerspective(){this.perspCamera.aspect=this.aspect,this.perspCamera.fov=this.fov,this.perspCamera.view=this.view,this.perspCamera.far=this.far,this.perspCamera.updateProjectionMatrix(),this.projectionMatrix=this.perspCamera.projectionMatrix,this.projectionMatrixInverse=this.perspCamera.projectionMatrixInverse,this._cameraType="PerspectiveCamera",this.objectHelper&&this.objectHelper.update()}setFocalLength(t){this.perspCamera.setFocalLength(t),this.toPerspective()}getFocalLength(){return this.perspCamera.getFocalLength()}getEffectiveFOV(){return this.perspCamera.getEffectiveFOV()}getFilmWidth(){return this.perspCamera.getFilmWidth()}getFilmHeight(){return this.perspCamera.getFilmHeight()}setViewOffset(t,e,n,r,i,a){"PerspectiveCamera"===this._cameraType?this.perspCamera.setViewOffset(t,e,n,r,i,a):this.orthoCamera.setViewOffset(t,e,n,r,i,a)}clearViewOffset(){"PerspectiveCamera"===this._cameraType?(this.perspCamera.clearViewOffset(),this.toPerspective()):(this.orthoCamera.clearViewOffset(),this.toOrthographic())}copyHistory(){this.previousProjectionMatrix&&this.previousProjectionMatrix.copy(this.projectionMatrix)}updateProjectionMatrix(){"PerspectiveCamera"===this._cameraType?this.toPerspective():"OrthographicCamera"===this._cameraType&&this.toOrthographic()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}copy(t,e){return super.copy(t,e),this.parent=t.parent,this.orthoCamera.copy(t.orthoCamera),this.perspCamera.copy(t.perspCamera),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.far=t.far,this.view=null===t.view?null:Object.assign({},t.view),this._cameraType=t._cameraType,this.aspect=t.aspect,this.fov=t.fov,this.focus=t.focus,this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this.targetOffset=t.targetOffset,this.updateProjectionMatrix(),this}toCameraState(t=[]){let e={type:this.cameraType,far:this.far,orthographic:{near:this.orthoCamera.near,zoom:this.orthoCamera.zoom},perspective:{near:this.perspCamera.near,fov:this.perspCamera.fov,zoom:this.perspCamera.zoom},up:this.up.toArray(),targetOffset:this.targetOffset,isUpVectorFlipped:this.isUpVectorFlipped};return Ia(e,t)}updateCameraSubtype(t,e){let n="perspective"===t?"PerspectiveCamera":"OrthographicCamera";void 0!==e.zoom&&this.setZoom(n,e.zoom),void 0!==e.near&&this.setNear(n,e.near),void 0!==e.fov&&"PerspectiveCamera"===n&&(this.fov=e.fov)}updateState(t,e){this.updateCameraState(t,e)}updateCameraState(t,e){this.updateState_Entity(t,e),void 0!==t.far&&(this.far=t.far),void 0!==t.orthographic&&this.updateCameraSubtype("orthographic",t.orthographic),void 0!==t.perspective&&this.updateCameraSubtype("perspective",t.perspective),void 0!==t.type&&(this.cameraType=t.type),void 0!==t.up&&this.up.fromArray(t.up),void 0!==t.targetOffset&&(this.targetOffset=t.targetOffset),void 0!==t.isUpVectorFlipped&&(this.isUpVectorFlipped=t.isUpVectorFlipped),this.updateProjectionMatrix()}updateByPatchedOp(t,e,n){super.updateByPatchedOp(t,e,n),1===t.path.length&&0===t.type&&this.updateCameraSubtype(t.path[0],t.props)}toState(t){return{...super.toState(t),...this.toCameraState(t),type:this.cameraType}}},Nv=new s,jv=new s,Bv=new s,Uv=new o,kv=new o,Rv=class extends bg{constructor(t,n,r){super(t,n),this.data=n,this.meshSetAddresses=[],this.needsTransformForDownstream=!1,this.geometry=new e,this.onAfterRender=(t,e,n,r,i,a)=>{super.onAfterRender(t,e,n,r,i,a),this.recomputeBoolean()},this.geometry.userData.parameters={width:0,height:0,depth:0}}get booleanOp(){return this.data.geometry.operation}get phongAngle(){return this.data.geometry.phongAngle??45}get isLOD(){return this.recomputeBoolean(),!1}updateByPatchedOp(t,e,n){super.updateByPatchedOp(t,e,n),1===t.path.length&&"geometry"===t.path[0]&&0===t.type&&void 0!==t.props.operation&&(this.freeBooleanPointer(),this.resetBBoxNeedsUpdate())}freeBooleanPointer(){super.freeBooleanPointer(),this.geometry.dispose()}recomputeBoolean(t,n=!0){var r;if(-1!==this.booleanMeshSetAddress&&!t)return;for(let e=0;e<this.children.length;e++){let r=this.children[e];r instanceof Rv&&!0===r.dataPatched.visible&&r.recomputeBoolean(!0===t,n)}this.meshSetAddresses=[];for(let e=0;e<this.children.length;e++){let i=this.children[e];if(i instanceof kp&&!0===i.dataPatched.visible&&(null==(r=i.geometry.attributes.position)?void 0:r.count)>0&&i.geometry.drawRange.count>0){if(Nv.multiplyMatrices(i.hiddenMatrix,i.matrix),-1===i.booleanMeshSetAddress){if((i.geometry.index??i.geometry.getAttribute("position")).count/3<15e5&&(i.booleanMeshSetAddress=_p.getMeshSet(i.geometry,!0===t,n)),-1===i.booleanMeshSetAddress)return;_p.transformMeshSet(i.booleanMeshSetAddress,Nv),i.booleanMatrixInvOld.copy(Nv).invert(),i.booleanWasTransformed=!1}else i instanceof Rv&&!0===i.needsTransformForDownstream?(_p.transformMeshSet(i.booleanMeshSetAddress,Nv),i.needsTransformForDownstream=!1):!0===i.booleanWasTransformed&&(_p.transformMeshSet(i.booleanMeshSetAddress,jv.multiplyMatrices(Nv,i.booleanMatrixInvOld)),i.booleanMatrixInvOld.copy(Nv).invert(),i.booleanWasTransformed=!1);!1===_p.hasOpenEdges(i.booleanMeshSetAddress)||e===this.children.length-1&&2===this.booleanOp?(this.meshSetAddresses.push(i.booleanMeshSetAddress),i.geometry.userData.wasFilteredFromBoolean=!1):i.geometry.userData.wasFilteredFromBoolean=!0}}if(0===this.meshSetAddresses.length)return this.geometry.setAttribute("position",new S([],0)),void this.geometry.setDrawRange(0,0);if(!0===t)return _p.calcBooleanTopological(this.meshSetAddresses,this.booleanOp);let i=this.geometry;i.dispose(),this.geometry=new e,this.geometry.userData=i.userData,this.geometry.boundingSphere=i.boundingSphere;try{this.booleanMeshSetAddress=_p.calcBoolean(this.meshSetAddresses,this.booleanOp,this.geometry,this.phongAngle)}catch(pl){this.booleanMeshSetAddress=0,console.error(pl)}this.booleanMatrixInvOld.copy(this.matrix).invert(),this.needsTransformForDownstream=!0,Mg(this),Cg(this)}dispose(){super.dispose(),this.geometry.dispose()}get recursiveBBox(){var t;let e=super.recursiveBBox;return-1===(null==(t=this.geometry.boundingSphere)?void 0:t.radius)&&(e.getCenter(this.geometry.boundingSphere.center),Bv.copy(this.matrixWorld).invert(),this.geometry.boundingSphere.center.applyMatrix4(Bv),Uv.copy(e.max).applyMatrix4(Bv),kv.copy(e.min).applyMatrix4(Bv),this.geometry.boundingSphere.radius=Uv.distanceTo(kv)/2),e}};(Mv||(Mv={})).is=function(t){return yd.is(t)&&t instanceof M};var Fv=(t,e)=>class extends(Cv(t,e)){updateState_Light(t,e){this.updateState_Entity(t,e),void 0!==t.color&&(this.color=e.shared.color(t.color)),void 0!==t.intensity&&(this.intensity=t.intensity),void 0!==t.depth&&(this.shadow.camera.far=t.depth,this.shadow.needsUpdate=!0),void 0!==t.shadows&&(this.castShadow=t.shadows)}},Vv=t=>t instanceof kp,Gv=t=>null!==t&&t instanceof Rv,Hv=t=>Av.is(t),Wv=class extends(mv(T)){constructor(t,e=15){super(e),this.object=t,this.object.updateMatrixWorld(),this.name=`EmptyObjectHelper: ${t.uuid}`,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.object.isBone&&(this.visible=!1)}raycast(t,e){bv(this.object,Wv.geometryHelper,t,e)}update(){}},qv=class extends(Cv(xt,Wv)){constructor(t,e){super(),this.super_Entity(t,e),this.objectHelper.update()}updateState(t,e){this.updateState_Entity(t,e)}},$v=v.lights_fragment_begin,Xv=v.shadowmask_pars_fragment,Yv=null,Kv=class extends(mv(z)){constructor(t,e=15,n=10066329){super(t,e,n),this.object=t,this.added=!1,this.name=`DirectionalLightHelper: ${t.uuid}`}raycast(t,e){bv(this.object,Kv.geometryHelper,t,e)}},Zv=class extends(mv(E)){constructor(t,e=15,n=6710886){super(t,e,n),this.object=t,this.name=`PointLightHelper: ${t.uuid}`}raycast(t,e){bv(this.object,Zv.geometryHelper,t,e)}},Qv=class extends(mv(L)){constructor(t,e=6710886){super(t,e),this.object=t,this.name=`SpotLightHelper: ${t.uuid}`}raycast(t,e){bv(this.object,Qv.geometryHelper,t,e)}update(){if(void 0!==this.object){let t=Qv._vector,e=this.object.distance?this.object.distance:1e3,n=e*Math.tan(this.object.angle);this.cone.scale.set(n,n,e),t.setFromMatrixPosition(this.object.target.matrixWorld),this.cone.lookAt(t);let r=void 0!==this.color?this.color:this.light.color;if(this.cone.material instanceof Array)for(let i=0,a=this.cone.material.length;i<a;i++)this.cone.material[i].color.set(r);else this.cone.material.color.set(r)}}},Jv=Qv;Jv._vector=new o;var ty=class extends(Fv(Mt,Kv)){constructor(t,e,n){super(),this.super_Entity(t,e),this.castShadow=!0,this.shadow.mapSize.width=2048,this.shadow.mapSize.height=2048,this.shadow.normalBias=1,this.layers.enable(3);let r=this.shadow.camera;r.top=1250,r.bottom=-1250,r.right=1250,r.left=-1250,r.near=-1e4,r.far=2500;let i=new wt(this.shadow.camera);i.visible=!1,this.gizmos.shadowmap=i}update(){this.shadow.camera.updateProjectionMatrix();for(let t in this.gizmos){let e=this.gizmos[t];e instanceof wt&&e.update()}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.objectHelper&&this.objectHelper.update()}updateState(t,e){this.updateState_Light(t,e);let n=void 0!==t.depth&&t.depth!==this.shadow.camera.far||void 0!==t.size&&t.size/2!==this.shadow.camera.right;void 0!==t.size&&function(t,e){t.shadow.camera.right=e/2,t.shadow.camera.left=-e/2,t.shadow.camera.top=e/2,t.shadow.camera.bottom=-e/2,t.shadow.needsUpdate=!0}(this,t.size),void 0!==t.shadowRadius&&(this.shadow.radius=t.shadowRadius),void 0!==t.shadowResolution&&(this.shadow.mapSize.set(t.shadowResolution,t.shadowResolution),this.shadow.map&&(this.shadow.map.dispose(),this.shadow.map=null)),void 0!==t.penumbraSize&&e.scene.markPenumbraSizeDirty(),n&&this.update()}},ey=new o,ny=new o,ry=new bt,iy=class extends(Fv(Ct,Jv)){constructor(t,e,n){super(),this.super_Entity(t,e),this.castShadow=!0,this.shadow.mapSize.width=1024,this.shadow.mapSize.height=1024,this.shadow.normalBias=1,this.layers.enable(3);let r=this.shadow.camera;r.fov=2*x.RAD2DEG*this.angle,r.aspect=1,r.near=100,r.far=2500;let i=new wt(this.shadow.camera);i.visible=!1,this.gizmos.shadowmap=i,this.update()}update(){this.shadow.camera.updateProjectionMatrix();for(let t in this.gizmos){let e=this.gizmos[t];e instanceof wt&&e.update()}}updateMatrixWorld(t){super.updateMatrixWorld(t),ny.setFromMatrixPosition(this.matrixWorld),ry.setFromRotationMatrix(this.matrixWorld),ey.copy(this.up).applyQuaternion(ry).negate().multiplyScalar(this.distance),this.target.position.copy(ny).add(ey),this.target.updateMatrixWorld(),this.objectHelper&&this.objectHelper.update()}updateState(t,e){this.updateState_Light(t,e),void 0!==t.distance&&(this.distance=t.distance),void 0!==t.decay&&(this.decay=t.decay),void 0!==t.angle&&(this.angle=t.angle),void 0!==t.penumbra&&(this.penumbra=t.penumbra),void 0!==t.shadowRadius&&(this.shadow.radius=t.shadowRadius),void 0!==t.penumbraSize&&e.scene.markPenumbraSizeDirty(),void 0!==t.shadowResolution&&(this.shadow.mapSize.set(t.shadowResolution,t.shadowResolution),this.shadow.map&&(this.shadow.map.dispose(),this.shadow.map=null))}},ay=class extends(Fd(Q)){constructor(t,e){super(),this.data=e,this.bgColor=new $p(1,1,1,1),this.fog=null,this.backupFog=new ft(16777215,.1,2e3),this.fogUseBGColor=!1,this.isActive=!1,this.aoColor=new _,this.penumbraSizeArrayCache=null,this.super_Entity(t,e),this.personalCamera=new Iv(yl,{...hh.defaultData,...e.camera,name:"Personal Camera"}),this.personalCamera.objectHelper.visible=!1,this.add(this.personalCamera),this.activeCamera=this.personalCamera,this.ambientLight=new mt(13882323,8553090,.75),this.ambientLight.name="Default Ambient Light",this.ambientLight.layers.enable(3),this.ambientLight.removeFromParent(),this.add(this.ambientLight)}get scene(){return this.parent}get postprocessing(){return this.data.postprocessing}updateVisible(){}setBackgroundColor(t){this.bgColor=t,!0===this.fogUseBGColor&&(this.backupFog.color=t)}updateAmbientLight(t,e){void 0!==t.color&&(this.ambientLight.color=Im(t.color,e)),void 0!==t.intensity&&(this.ambientLight.intensity=t.intensity),void 0!==t.enabled&&(t.enabled?this.add(this.ambientLight):this.remove(this.ambientLight))}onDeactive(){this.isActive=!1}onActive(t){this.isActive=!0,t.fog=this.fog,this.updateShadow(this.data.shadow)}forceMaterialsUpdate(){this.traverseEntity((t=>{if(t instanceof bg)if(Array.isArray(t.material))for(let e of t.material)e.needsUpdate=!0;else t.material.needsUpdate=!0,t.material.dispose()}))}updateShadow(t){void 0!==t.softShadowQuality&&this.isActive&&((t="medium")=>{if(Yv===t)return!1;Yv=t;let e=(t=>{switch(t){case"low":return 8;case"medium":default:return 16;case"high":return 32}})(t);v.shadowmap_pars_fragment=(t=>`\n\n// PCSS implementation based on:\n// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n// NOTE: This number affects how big the shadow blur can\n// possibly get. Bigger number == bigger blur, but less precise results\n\nconst float  gPenumbraFilterSize = 80.0;\nconst int   gPenumbraSamples = ${t};\nconst int gShadowSamples = ${t};\nconst float gShadowSamplesRpc = 1.0f / float(gShadowSamples);\n\n#ifdef USE_SHADOWMAP\n    #if NUM_DIR_LIGHT_SHADOWS > 0\n\n        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n        struct DirectionalLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n    #endif\n\n    #if NUM_SPOT_LIGHT_SHADOWS > 0\n\n        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n        varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n        struct SpotLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n    #endif\n\n    #if NUM_POINT_LIGHT_SHADOWS > 0\n\n        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n        struct PointLightShadow {\n            float shadowBias;\n            float shadowNormalBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n            float shadowCameraNear;\n            float shadowCameraFar;\n        };\n\n        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n    #endif\n\n    /*\n    #if NUM_RECT_AREA_LIGHTS > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\nfloat computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)\n{\n    float penumbra = 1.0;\n    float blockerDepthAvg = 0.0;\n    float blockerCount = 0.0;\n\n    #pragma unroll_loop_start\n    for(int i = 0; i < gPenumbraSamples; i ++)\n    {\n        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;\n        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );\n\n        if(depth < compare + 0.0001)\n        {\n            blockerDepthAvg += depth;\n            blockerCount++;\n        }\n    }\n    #pragma unroll_loop_end\n\n    if (blockerCount > 0.0)\n    {\n        blockerDepthAvg /= blockerCount;\n\n        // Compute penumbra\n        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);\n        penumbra *= penumbra;\n        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows\n\n        return clamp(penumbra, 0.00, 1.0);\n    }\n    return 0.0;\n}\n\nfloat vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)\n{\n    float shadow         = 0.0f;\n\n    // NOTE: When using TAA, we should use screen space interleaved gradient noise\n    vec2 halton = haltonSequence[frameIndex];\n    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n    float temporalAngle  = temporalOffset * PI2;\n\n    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);\n    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);\n    if (penumbra == -1.0) {\n        return 1.0;\n    }\n\n    #pragma unroll_loop_start\n    for (int i = 0; i < gShadowSamples; i++)\n    {\n        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n        // Overall blurring offset\n        vec2 offset = vogelSample * (shadowRadius * 2.);\n\n        // Penumbra offset\n        offset += vogelSample * (penumbra * texelScalar);\n\n        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    }\n    #pragma unroll_loop_end\n\n    return shadow * gShadowSamplesRpc;\n}\n\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n            float dx = texelSize.x;\n            float dy = texelSize.y;\n\n            vec2 uv = shadowCoord.xy;\n            vec2 f = fract( uv * shadowMapSize + 0.5 );\n            uv -= f * texelSize;\n\n            shadow = (\n                texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n                     f.x ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n                     f.y ) +\n                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n                          f.x ),\n                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n                          f.x ),\n                     f.y )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##         dim    := ( 4 , 2 )\n        //  # #         center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        float shadow = 1.0;\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        compare += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        vec2 halton = haltonSequence[frameIndex];\n        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);\n        float temporalAngle  = temporalOffset * PI2;\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )\n            for (int i = 0; i < gShadowSamples; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                // NOTE: Removed for now\n                // Penumbra offset\n                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * gShadowSamplesRpc;\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n            for (int i = 0; i < 16; i++) {\n                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;\n\n                // Overall blurring offset\n                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);\n\n                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );\n\n            }\n            return shadow * (1.0 / 16.0);\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );\n\n        #endif\n\n    }\n\n#endif\n`)(e);let n=$v.slice();n=n.replace("getShadow( spotShadowMap[ i ]","getShadow( UNROLLED_LOOP_INDEX + 3, spotShadowMap[ i ]"),n=n.replace("getShadow( directionalShadowMap[ i ]","getShadow( UNROLLED_LOOP_INDEX, directionalShadowMap[ i ]"),v.lights_fragment_begin=n;let r=Xv.slice();return r=r.replaceAll("getShadow(","getShadow( UNROLLED_LOOP_INDEX, "),v.shadowmask_pars_fragment=r,!0})(t.softShadowQuality)&&this.forceMaterialsUpdate()}updateFog(t,e){if(t.enabled?this.fog=this.backupFog:this.fog=null,this.isActive){this.scene.fog=this.fog}this.fogUseBGColor=t.useBackgroundColor,t.useBackgroundColor?this.backupFog.color.set(this.bgColor):this.backupFog.color=Im(t.color,e),this.backupFog.near=t.near,this.backupFog.far=t.far}updateAo(t,e){void 0!==t.aoColor&&(this.aoColor=Im(t.aoColor,e))}updateByOp(t,e,n,r){super.updateByOp(t,e,n,r);let i=e;Ts(t.path,["fog"])?this.updateFog(i.fog,n.shared):Ts(t.path,["ao"])?this.updateAo(i.ao,n.shared):Ts(t.path,["ambient"])?this.updateAmbientLight(i.ambient,n.shared):Ts(t.path,["shadow"])&&this.updateShadow(i.shadow)}updateState(t,e){this.updateState_Entity(t,e),void 0!==t.backgroundColor&&this.setBackgroundColor(Im(t.backgroundColor,e.shared)),void 0!==t.fog&&this.updateFog(t.fog,e.shared),void 0!==t.ambient&&this.updateAmbientLight(t.ambient,e.shared),void 0!==t.ao&&this.updateAo(t.ao,e.shared),void 0!==t.shadow&&this.updateShadow(t.shadow)}raycast(t,e){super.raycast(t,e)}switchActiveCamera(t){t&&t.isDescendantOf(this)&&(this.activeCamera!==this.personalCamera&&(this.activeCamera.objectHelper.visible=!0),this.activeCamera=t,t.objectHelper.visible=!1)}get playCamera(){var t;return(null==(t=this.scene)?void 0:t.find(this.data.publish.playCamera))??this.personalCamera}switchToPlayCamera(){this.switchActiveCamera(this.playCamera)}get penumbraSizeArray(){return null===this.penumbraSizeArrayCache&&this.updatePenumbraSizeArray(),this.penumbraSizeArrayCache}updatePenumbraSizeArray(){this.penumbraSizeArrayCache=new Array(5).fill(.5);let t=0,e=0;this.traverseEntity((n=>{if(!n.visible)return!0;n instanceof ty&&n.visible&&t<3&&(this.penumbraSizeArrayCache[t]=n.data.penumbraSize,t+=1),n instanceof iy&&n.visible&&t<2&&(this.penumbraSizeArrayCache[3+e]=n.data.penumbraSize,e+=1)}))}raycastWithClones(t){let e=[],n=r=>{for(let i of r.children){let r=i.cloner;yd.is(i)&&(i.visible||(null==r?void 0:r.object.data.visible))&&((Vv(i)||Hv(i)&&this.scene.enableHelpers&&i.objectHelper.visible)&&(t.intersectObject(i,!1,e),xy(i,t,e,!0)),n(i))}};return n(this),e}},sy=class extends(Fv(Pt,Zv)){constructor(t,e,n){super(),this.super_Entity(t,e),this.castShadow=!0,this.shadow.mapSize.width=1024,this.shadow.mapSize.height=1024,this.shadow.normalBias=1,this.layers.enable(3);let r=this.shadow.camera;r.fov=90,r.aspect=1,r.near=100,r.far=2500;let i=new o(-r.far+this.position.x,-r.far+this.position.y,-r.far+this.position.z),a=new o(r.far+this.position.x,r.far+this.position.y,r.far+this.position.z),s=new c(i,a),l=new yt(s,new _(16755200));l.visible=!1,this.gizmos.shadowmap=l,this.update()}update(){if(this.shadow&&(this.shadow.camera.updateProjectionMatrix(),this.gizmos))for(let t in this.gizmos){let e=this.gizmos[t];if(e instanceof yt){let t=this.shadow.camera,n=new o(-t.far+this.position.x,-t.far+this.position.y,-t.far+this.position.z),r=new o(t.far+this.position.x,t.far+this.position.y,t.far+this.position.z);e.box.set(n,r),e.updateMatrixWorld(!0)}}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.objectHelper&&this.objectHelper.update()}updateState(t,e){this.updateState_Light(t,e),void 0!==t.distance&&(this.distance=t.distance),void 0!==t.decay&&(this.decay=t.decay),void 0!==t.shadowRadius&&(this.shadow.radius=t.shadowRadius),void 0!==t.shadowResolution&&(this.shadow.mapSize.set(t.shadowResolution,t.shadowResolution),this.shadow.map&&(this.shadow.map.dispose(),this.shadow.map=null))}},oy=class extends Og{get forceComputeSize(){return!0}get shape(){return this.geometry.userData.shape}updateEntityBoxSize(t,e){let n=this.geometry.getAttribute("position");void 0!==n?jp(n,this.geometry.drawRange.start,this.geometry.drawRange.count<1/0?this.geometry.drawRange.count:n.count,t,e):super.updateEntityBoxSize(t,e)}},ly=class extends Og{constructor(t,e,n){super(t,e,n),this._shapeId=null,this._context=n}updateState(t,e){super.updateState(t,e),this.updateShape()}updateShape(){var t;let e,n={...this.data.geometry.extrusion.shape};for(let i in n)"string"==typeof n[i]&&(n[i]=this._context.shared.getVariable(n[i],[this.uuid,"geometry","extrusion","shape",i]));if("Custom"===n.type){let r=n.shapeId;if(r!==this._shapeId&&this.detachShape(),r){this._shapeId=r;let n=this._context.scene.find(r);(null==n?void 0:n.data)&&(n.attachedPaths.add(this),e=null==(t=n.geometry.userData)?void 0:t.shape),e||this._context.scene.addPendingCommand((()=>this.updateShape()))}}else{let t;switch(n.type){case"Rectangle":t=Gu;break;case"Ellipse":t=hu;break;case"Polygon":t=Uu;break;case"Star":t=Wu;break;default:throw new Error(`Unknown shape type: ${n.type}`)}e=t.create({parameters:n}).userData.shape}let r=this.geometry;e&&r.inputs&&(r.inputs.shapeData=e,r.build(),this.attachedSurfaceCloners.forEach((t=>t.update())))}detachShape(){var t;null!==this._shapeId&&(null==(t=this._context.scene.find(this._shapeId))||t.attachedPaths.delete(this))}createGeometryDelayed(t){this.geometryCreateDeleyed=t.shared,this.updateShape(),this.refreshAttachedPaths(t)}updateTransformState(t,e){return super.updateTransformState(t,e)}updateGeometryInteractions(t,e){super.updateGeometryInteractions(t,e),this.updateShape()}updateEntityBoxSize(t,e){let n=this.geometry.getAttribute("position");void 0!==n?jp(n,this.geometry.drawRange.start,this.geometry.drawRange.count<1/0?this.geometry.drawRange.count:n.count,t,e):super.updateEntityBoxSize(t,e)}},hy=class extends(Cv(xt,Wv)){constructor(t,e,n){super(),"Instance"===e.type&&"string"==typeof t&&(e=this.transformAssignData(e,n)),this.super_Entity(t,e),this.objectHelper.update()}get isComponentRoot(){return"Component"===this.data.type&&"string"==typeof this.identity}get isInstanceRoot(){return"Instance"===this.data.type&&"string"==typeof this.identity}transformAssignData(t,e){let n=Qh.getComponentData({scene:e.scene.data,shared:e.shared.data},t.component);if(n){let e,r;for(let i of uh.rootOverrideProps)void 0===t[i]?(void 0===e&&(e={...t}),e[i]=n.data[i]):(void 0===r&&(r={}),r[i]=t[i],void 0===e&&(e={...t}),e[i]=Qa.apply(n.data[i],t[i]));return this.overrideData=r,e}return{...ah.defaultData,...t,...ka(ah.defaultData,uh.rootOverrideProps)}}updateByOp(t,e,n,r){let i;if(this.isInstanceRoot&&!r)if(e=this.transformAssignData(e,n),0===t.type&&0===t.path.length&&this.component)for(let a of uh.rootOverrideProps)a in t.props&&void 0===t.props[a]&&(void 0===i&&(i={...t,props:{...t.props}}),i.props[a]=this.component.data[a]);else if(0===t.type&&t.path.length>0&&uh.rootOverrideProps.includes(t.path[0])){let n=t.path[0];void 0===i&&(i={...t,path:[],props:{[n]:e[n]}})}super.updateByOp(i??t,e,n,r)}updateState(t,e){this.updateState_Entity(t,e)}expandInstanceChildren(t){let e=this.data;if(void 0===this.component){let n=t.scene.find(e.component)??null,r=!1;if(n!==this.oldComponent){if(this.oldComponent){let e=0;for(let n of this.children){if(!yd.is(n))break;t.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(n),dy(n),e+=1}this.children.splice(0,e)}r=!0}if(n){let i={};uy(t,[this.uuid],e.overrides,this,n,n,0,r,i);for(let e of this.children)if(yd.is(e)){let n=e.data;"Empty"===n.type&&n.animations&&e.traverseEntity((e=>{if(e instanceof Og&&e.isSkinnedMesh){let n=e.dataPatched;if(n.bones&&n.boneInverses){let r=n.bones.map((e=>t.scene.find(i[e]))),a=n.boneInverses.map((t=>(new s).fromArray(t))),o=new J(r,a);e.bind(o,e.bindMatrix)}}else e.matrixAutoUpdate=!0}))}}this.oldComponent=this.component}}};function dy(t){if(t.component){let e=t.component.instances.indexOf(t);e>=0&&t.component.instances.splice(e,1);for(let n of t.children)yd.is(n)&&dy(n)}}function cy(t,e,n,r){return t.component===e&&Ta(t.identity,r)?t.overrideData===n?2:1:0}function uy(t,e,n,r,i,a,s,o,l){if(s>50)return!1;if(r.component!==i){if(r.component){let t=r.component.instances.indexOf(r);t>=0&&r.component.instances.splice(t,1)}i.instances.push(r),r.component=i}i instanceof hy&&i.isInstanceRoot&&i.expandInstanceChildren(t);let h=0;for(let d of i.children)if(yd.is(d)){let i=[...e,..."string"==typeof d.identity?[d.identity]:d.identity],c=ch.resolve(n,i,1);null==c||c instanceof rs||(Object.setPrototypeOf(c,rs.prototype),console.error("wrong prototype"));let u,p=null;if(!o){let e=r.children[h];if(p=yd.is(e)?e:null,null!==p){let t=cy(p,d,c,i);u=t>=1?p.stateSelection:void 0,2!==t&&(p=null)}if(null===p&&(p=t.scene.findInstance(i)??null,null!==p)){let e=cy(p,d,c,i);if(u=e>=1?p.stateSelection:void 0,2!==e)p=null;else{let e=p.parent.children.indexOf(p);p.parent.children.splice(e,1),r.children.splice(h,0,p),p.parent===r?e<=h&&console.error("not possible"):(p.parent=r,p.matrixWorldNeedsUpdate=!0,p.resetBBoxNeedsUpdate(),p.updateVisible(),t.pendingDeletes.delete(p))}}}if(null===p){let e=c?Qa.apply(d.data,c):d.data;fl.is(e.type)&&(e={...e,type:"Empty"}),p=Td.createEntity(i,e,t),p.overrideData=c,r.add(p),r.children.splice(r.children.length-1,1),r.children.splice(h,0,p),p.updateState(p.data,t),u&&p.changeSelectedState(u,t),t.scene.registerInstanceAndSetUuid(p)}if(p.isBone){l[p.identity[p.identity.length-1]]=p.uuid}h+=1,uy(t,e,n,p,d,a,s+1,o,l)}if(!o){let e=h;for(;;){let e=r.children[h];if(!yd.is(e))break;t.pendingDeletes.add(e),h+=1}r.children.splice(e,h-e)}return!0}var py=class extends(Cv(_t,Wv)){constructor(t,e){super(),this.super_Entity(t,e),this.objectHelper.update(),this.matrixAutoUpdate=!0}updateState(t,e){this.updateState_Entity(t,e)}};function fy(t,e,n){return"Mesh"===e.type?function(t,e,n){let r;return"TextGeometry"===e.geometry.type?new ev(t,e,n):(r="SubdivGeometry"===e.geometry.type?new zg(t,e,n):"PathGeometry"===e.geometry.type?new ly(t,e,n):"VectorGeometry"===e.geometry.type?new oy(t,e,n):"BooleanGeometry"===e.geometry.type?new Rv(t,e,n):new Og(t,e,n),r)}(t,e,n):"Empty"===e.type?new qv(t,e):"Bone"===e.type?new py(t,e):"Page"===e.type?new ay(t,e):"PointLight"===e.type?new sy(t,e,n):"SpotLight"===e.type?new iy(t,e,n):"DirectionalLight"===e.type?new ty(t,e,n):"Component"===e.type||"Instance"===e.type?new hy(t,e,n):fl.is(e.type)?new Iv(t,e):(console.error(e),new qv(t,e))}function my(t,e){let n=!1,r=e.getLayersOfType("transmission"),i=e.getLayersOfType("outline");return i.length>0&&(t.layers.set(8),r.length>0&&t.layers.enable(3),n=!0,Cg(t),Mg(t)),0===r.length&&0===i.length&&t.layers.set(0),t instanceof bg&&t.needsAO&&t.layers.enable(5),n}function gy(t,e){if(!e.layers)return!1;let n=!1,r=e.getLayersOfType("transmission").filter((t=>t.data.visible)),i=e.getLayersOfType("outline").filter((t=>t.data.visible));return r.length>0&&(t.layers.set(3),i.length>0&&t.layers.enable(8),n=!0),0===r.length&&0===i.length&&t.layers.set(0),t.needsAO&&t.layers.enable(5),n}Td.createEntity=fy,Td.changeEntityProptotype=function(t,e,n){let r=fy(t.identity,e,n),i=t.children,a=t.attachedPaths,s=t.parent,o=t.component,l=t.instances,h=t.overrideData,d=t.uuid,c=t.stateSelection;t.dispose();for(let u of Object.keys(t))delete t[u];Object.setPrototypeOf(t,Object.getPrototypeOf(r));for(let u of Object.keys(r))t[u]=r[u];t.children=[...t.children,...i],t.attachedPaths=a,t.parent=s,t.component=o,t.instances=l,t.uuid=d,t.overrideData=h,t.updateState(t.data,n),c&&t.changeSelectedState(c,n),t.resetBBoxNeedsUpdate()},Td.Cloner=fv;var vy=new y,yy=new s,by=new f;function xy(t,e,n,r=!1){let i=t.cloner;if(i)for(let a of i.children){let i=yy.copy(a.matrixWorld).invert(),s=by.copy(e.ray).applyMatrix4(i),o=t.matrixWorld;s.applyMatrix4(o);let l=vy;l.set(s.origin,s.direction),l.near=e.near,l.far=e.far;let h=l.intersectObject(t,!1);h.length>0&&n.push({...h[0],object:r?a:t})}}(new u).wireframe=!0;var wy,_y=new o,Sy=class extends Q{constructor(t,e){super(),this.data=t,this.enableHelpers=!1,this.wireframeState=!1,this.needsTransmissionDirty=!0,this.needsNormalDirty=!0,this._needsTransmission=!1,this._needsNormal=!1,this.geometryCacheChanged=!1,this.entityByUuid={},this.entityIdentityToEntity={},this.toExpandCloner=new Set,this.toUpdateCloner=new Set,this.pendingCommands=[],this.pathConstraints=new class{constructor(){this._constraints=new Map}setConstraint(t,e){null===e?this._constraints.delete(t):this._constraints.set(t,e)}removeDependencies(t){this._constraints.delete(t)}applyConstraints(t){let e=new Set;this._constraints.forEach(((n,r)=>{let i=[r,n],a=n;for(;this._constraints.has(a);)a=this._constraints.get(a),e.has(a)||i.push(a);for(let s=i.length-2;s>=0;s--)if(!e.has(i[s])){let n=t.find(i[s]);n?n.applyPathSnapping(t):console.warn(`missing entity ${i[s]}`),e.add(i[s])}}))}findDependency(t,e){let n=t;for(;this._constraints.has(n);)if(n=this._constraints.get(n),n===e)return!0;return!1}},this.errorPage=new ay("fdasfa",{...ph.defaultData,name:""}),this.invisibleObjects=new qv("jflkdsafjasdifjaslk",{...sh.defaultData,visible:!1,name:"buildin invisible"}),this.needsRecomputeInstances=!1,this.init(t,e),this.matrixAutoUpdate=!1}markGeometryCacheDirty(){this.geometryCacheChanged=!0}markNeedsUpdateRendererDirty(){this.needsTransmissionDirty=!0,this.needsNormalDirty=!0}needsTransmission(){return this.needsTransmissionDirty&&(this._needsTransmission=function(t){let e=!1;return t.traverseEntity((t=>{if(t instanceof bg)if(Array.isArray(t.material))for(let n=0;n<t.material.length;n++)gy(t,t.material[n])&&(e=!0);else gy(t,t.material)&&(e=!0)})),e}(this),this.needsTransmissionDirty=!1),this._needsTransmission}needsNormal(){return this.needsNormalDirty&&(this._needsNormal=function(t){let e=!1;return t.traverseEntity((t=>{if(t instanceof bg)if(Array.isArray(t.material))for(let n=0;n<t.material.length;n++)my(t,t.material[n])&&(e=!0);else my(t,t.material)&&(e=!0)})),e}(this),this.needsNormalDirty=!1),this._needsNormal}registerInstanceAndSetUuid(t){let e=t.identity.join("-"),n=this.entityIdentityToEntity[e];n&&(t.uuid=n.uuid),this.entityIdentityToEntity[e]=t,this.entityByUuid[t.uuid]=t}markPenumbraSizeDirty(){for(let t of this.children)t instanceof ay&&(t.penumbraSizeArrayCache=null)}findInstance(t){return this.entityIdentityToEntity[t.join("-")]}get bgColor(){return this.activePage.bgColor}get postprocessing(){return this.activePage.data.postprocessing}getWithSortKey(t){let e=this.find(t);if(void 0===e)return;let n=[],r=e;for(;r!==this;){let t=r;r=r.parent;let e=r.children.indexOf(t);n.splice(0,0,e)}return{entity:e,sortKey:n}}getAllSorted(t){let e=[];for(let n of t){let t=this.getWithSortKey(n.id);void 0!==t&&e.push(t)}return e.sort(((t,e)=>function(t,e){let n=0;for(;n<t.length&&n<e.length;){if(t[n]<e[n])return-1;if(t[n]>e[n])return 1;n+=1}return n!==e.length?-1:n!==t.length?1:0}(t.sortKey,e.sortKey))),e.map((t=>t.entity))}nonExistOrDescendantOf(t,e){let n=this.find(t);if(void 0===n)return!0;for(;n;){if(n.uuid===e)return!0;n=n.parent}return!1}find(t){if(this.activePage&&this.activePage.personalCamera.parent){if("f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera"===t)return this.activePage.personalCamera;if(t===yl)return this.activePage.personalCamera}if(""===t||void 0===t)return;let e=this.entityByUuid[t];return void 0===e?this.getObjectByProperty("uuid",t):e}debugEnsureEntity(t){let e=this.find(t);e?Array.isArray(e.identity)&&void 0===this.findInstance(e.identity)&&console.error("not found instance"):console.error("not found")}addPendingExpandCloner(t){this.toExpandCloner.add(t)}addPendingUpdateCloner(t){this.toUpdateCloner.add(t)}markToExpandCloner(t){this.toExpandCloner.add(t),t.traverseEntityAncestors((t=>{this.toExpandCloner.add(t)}))}doPendingExpandCloner(){this.toExpandCloner.forEach((t=>{t.expandCloner(this)})),this.toExpandCloner.clear()}doPendingUpdateCloner(){this.toUpdateCloner.forEach((t=>{var e;null==(e=t.cloner)||e.update()})),this.toUpdateCloner.clear()}doPendingUpdates(){this.doPendingExpandCloner(),this.doPendingUpdateCloner(),this.applyPendingCommands()}addPendingCommand(t){this.pendingCommands.push(t)}applyPendingCommands(){this.pendingCommands.forEach((t=>t())),this.pendingCommands.length=0}updateByLibOp(t,e){1===t.path.length&&"components"===t.path[0]&&1===t.type&&this.createChildrenObjects([{...t.data.asset,id:t.id}],this.invisibleObjects,e)}updateTreeByOp(t,e){var n;if(0===t.path.length&&7===t.type){let n=null===t.parent?this:this.find(t.parent);if(void 0===n)throw new Error("unexpected");let r=this.createObject(t.id,t.data,t.children,n,t.localIndex,e);r.updateVisible(),r.resetBBoxNeedsUpdate(),Vv(r)&&Gv(r.parent)&&(r.invalidateUpstreamBooleanData(),r.parent.invalidateDownstreamBooleanData().recomputeBoolean()),this.markNeedsRecomputeInstancesForAncessors(n),this.markNeedsRecomputeInstancesForChildren(r),this.markToExpandCloner(r),this.markPenumbraSizeDirty()}else if(0===t.path.length&&8===t.type){let e=this.find(t.id);if(void 0===e)throw new Error("unexpected");this.markToExpandCloner(e),e.resetBBoxNeedsUpdate(),this.unregisterObject(e);let n=e.parent;this.markNeedsRecomputeInstancesForAncessors(n),this.markNeedsRecomputeInstancesForChildren(e),this.markPenumbraSizeDirty(),e.parent.remove(e),Gv(e.parent)&&(e.parent.invalidateUpstreamBooleanData(),e.parent.invalidateDownstreamBooleanData().recomputeBoolean()),Vv(e)&&(e.freeBooleanPointer(),n instanceof Rv&&n.invalidateDownstreamBooleanData().recomputeBoolean()),e instanceof ly&&e.detachShape(),this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(e),this.pathConstraints.removeDependencies(e.uuid)}else if(0===t.path.length&&9===t.type){let e=this.find(t.id);if(void 0===e)throw new Error("unexpected");this.markNeedsRecomputeInstancesForChildren(e);let r=e.parent;this.markNeedsRecomputeInstancesForAncessors(r),null==(n=e.cloner)||n.resetOnMove(),this.markToExpandCloner(e);let i=null===t.parent?this:this.find(t.parent);if(void 0===i)throw new Error("unexpected");i.add(e),this.markNeedsRecomputeInstancesForAncessors(i),this.markToExpandCloner(e),e.invalidateClonerTransform(e),e.updateVisible(),e.resetBBoxNeedsUpdate(),this.markPenumbraSizeDirty();let a=t.localIndex;i.children.splice(a,0,i.children.pop()),Vv(e)&&(e.invalidateUpstreamBooleanData(),Gv(e.parent)?e.parent.invalidateDownstreamBooleanData().recomputeBoolean():r instanceof Rv&&r.invalidateDownstreamBooleanData().recomputeBoolean())}this.markNeedsUpdateRendererDirty(),this.markGeometryCacheDirty()}get playPage(){return this.find(this.data.publish.playPage)??this.errorPage}updatePage(t){this.activePage&&this.activePage.onDeactive(),this.activePage=this.errorPage;for(let e of this.children)e instanceof ay&&(e.visible=e.uuid===t,e.visible&&(this.activePage=e,this.activePage.onActive(this)))}updateEntityByOp(t,e,n,r){if(0===e.type){if(("overrides"in e.props||"component"in e.props)&&this.markNeedsRecomputeInstances(),"visible"in e.props&&this.markPenumbraSizeDirty(),e.path.includes("overrides")&&"states"in e.props){let{rest:t}=e.props;e={...e,props:t},this.markNeedsRecomputeInstances()}"pathSnapping"===e.path[0]&&void 0!==e.props.pathId&&this.pathConstraints.setConstraint(t,e.props.pathId)}let i=this.find(t);if(i)try{(function(t,e,n,r){t.updateByOp(e,n,r,!1)})(i,e,n,{scene:this,shared:r}),i instanceof Og&&i.updateGeometryGroupsIfNeeded()}catch(nl){console.error(nl)}}get activeCamera(){return this.activePage.activeCamera}switchActiveCamera(t){this.activePage.switchActiveCamera(t)}isInvisibleObjects(t){return t===this.invisibleObjects||t.hasAnccestor(this.invisibleObjects)}init(t,e){let n=Object.entries(e.data.lib.components).map(((t,e)=>({data:t[1].asset.data,children:t[1].asset.children,id:t[0],fi:e})));this.invisibleObjects.updateState(this.invisibleObjects.data,{scene:this,shared:e}),this.add(this.invisibleObjects),this.createChildrenObjects(n,this.invisibleObjects,e),this.createChildrenObjects(t.objects,this,e),this.updatePage(t.publish.playPage),this.activePage.switchToPlayCamera(),this.expandInstances(e,!0),this.traverseEntity((t=>{Gv(t)&&t.recomputeBoolean(),t instanceof Iv&&t.updateUp()})),this.doPendingExpandCloner(),this.applyPendingCommands()}markNeedsRecomputeInstances(){this.needsRecomputeInstances=!0}markNeedsRecomputeInstancesForChildren(t){t.traverseEntity((t=>{("Component"===t.data.type||"Instance"===t.data.type)&&this.markNeedsRecomputeInstances()}))}markNeedsRecomputeInstancesForAncessors(t){yd.is(t)&&("Component"===t.data.type&&this.markNeedsRecomputeInstances(),t.traverseAncestors((t=>{yd.is(t)&&"Component"===t.data.type&&this.markNeedsRecomputeInstances()})))}relativeizeInner(t,e,n,r,i,a,s){if(t){let o=r.find(t);o&&o!==r&&i.forInstancesRec((r=>{r.data=Ps(r.data,(i=>{let o=i.events.data(s.id),l=r.goUp(a);if(l){let r=[...Qt(l.identity),t].join("-"),i=this.entityIdentityToEntity[r];if(i){let t=i.uuid;As.zoom(o,e)[n]=t}else console.warn("cannot find instance")}})).data}))}}rewriteActions(t,e,n,r,i,a){t.forEach((t=>{("Transition"===t.data.type||"Animation"===t.data.type)&&this.relativeizeInner(t.data.object,[...e,t.id],"object",n,r,i,a)}))}rewriteEventsBeforeGoToPlayMode(){this.traverseEntity((t=>{if(t instanceof hy&&"string"==typeof t.identity&&"Component"===t.data.type)return t.traverseEntity(((e,n)=>{e.data.events.forEach((r=>{if("GameControl"===r.data.type){let i=!1;if(e.forInstancesRec((t=>{t.data=Ps(t.data,(e=>{t.isInstanceRoot||(e.events.delete(r.id),i=!0)})).data})),!1===i)for(let a of zh.list)this.rewriteActions(r.data.gameActions[a],["gameActions",a],t,e,n,r)}else"Conditional"===r.data.type?("Distance"===r.data.condition.type?(this.relativeizeInner(r.data.condition.fromObject,["condition"],"fromObject",t,e,n,r),this.relativeizeInner(r.data.condition.toObject,["condition"],"toObject",t,e,n,r)):"State"===r.data.condition.type?this.relativeizeInner(r.data.condition.object,["condition"],"object",t,e,n,r):"Comparison"===r.data.condition.type&&("Property"===r.data.condition.lOperand.type&&this.relativeizeInner(r.data.condition.lOperand.value[0],["condition","lOperand","value"],0,t,e,n,r),"Property"===r.data.condition.rOperand.type&&this.relativeizeInner(r.data.condition.rOperand.value[0],["condition","rOperand","value"],0,t,e,n,r)),this.rewriteActions(r.data.inActions,["inActions"],t,e,n,r),this.rewriteActions(r.data.outActions,["outActions"],t,e,n,r)):"actions"in r.data&&this.rewriteActions(r.data.actions,["actions"],t,e,n,r)}))})),!0}))}expandInstances(t,e,n){let r=new Set;this.traverseEntity((i=>{if(i instanceof hy&&i.isInstanceRoot)return i.expandInstanceChildren({scene:this,shared:t,pendingDeletes:r}),e||i.resetBBoxNeedsUpdate(),n&&i.traverseEntity((t=>{n.addClip(t)})),!0}));for(let i of r)this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(i),dy(i)}recomputeInstances(t,e){this.needsRecomputeInstances&&(this.needsRecomputeInstances=!1,this.traverseEntity((t=>{t instanceof hy&&t.isInstanceRoot&&(t.component=void 0)})),this.expandInstances(t,!1,e))}disposeAndUnregisterEntityRecursivelyIfNotReregistered(t){t.traverseEntity((t=>{let e="string"==typeof t.identity?t.identity:t.identity.join("-");this.entityIdentityToEntity[e]===t&&(delete this.entityByUuid[t.uuid],delete this.entityIdentityToEntity[e]),t.dispose()}))}clearScene(){for(let t of this.children)yd.is(t)&&t.disposeRecursively();this.children.length=0}resetAfterClear(t,e){this.init(t,e)}raycast(t){return this.raycast1(t,!1)}raycast1(t,e){let n=[],r=i=>{for(let a of i.children){let i=a.cloner;if(yd.is(a)&&!a.raycastLock&&(a.visible||(null==i?void 0:i.object.data.visible)))if(!0===e&&a.isInstanceRoot){let e=[];if(t.intersectObject(a,!0,e),e.length){let t=e[0];t.object=a,t.point.applyMatrix4(t.object.matrixWorld);let r=a.matrixWorld.clone().invert();t.point.applyMatrix4(r),n.push(t)}}else(Vv(a)||Hv(a)&&this.enableHelpers&&a.objectHelper.visible)&&(t.intersectObject(a,!1,n),xy(a,t,n)),r(a)}};return r(this),n}raycastWithClones(t){let e=[],n=r=>{for(let i of r.children){let r=i.cloner;yd.is(i)&&(i.visible||(null==r?void 0:r.object.data.visible))&&((Vv(i)||Hv(i)&&this.enableHelpers&&i.objectHelper.visible)&&(t.intersectObject(i,!1,e),xy(i,t,e,!0)),n(i))}};return n(this),e}forEachEntity(t){for(let e of this.children)yd.is(e)&&t(e)}traverseConcreteEntity(t){for(let e of this.children)yd.is(e)&&e.isConcreteEntity&&e.traverseEntity(t)}traverseEntity(t){for(let e of this.children)yd.is(e)&&e.traverseEntity(t)}updateFont(t,e){this.traverseEntity((n=>{if(n instanceof Og&&"Mesh"===n.data.type&&"TextGeometry"===n.data.geometry.type&&n.data.geometry.font===t){let r=n.geometry,i=n.data.geometry;r.updateFont(t,e).then((()=>{r.update(i);let t=n.invalidateDownstreamBooleanData();Gv(t)&&t.recomputeBoolean()}))}}))}traverseObject(t){for(let e of this.children)ud.is(e)&&e.traverseObject(t)}traverseVisibleEntity(t){for(let e of this.children)yd.is(e)&&e.visible&&e.traverseVisibleEntity(t)}dispose(){this.clearScene()}createChildrenObjects(t,e,n){let r=0;for(let i of t)this.createObject(i.id,i.data,i.children,e,r,n),r+=1}registerObjectCreatedInLegacy(t){this.entityByUuid[t.uuid]=t}unregisterObject(t){delete this.entityByUuid[t.uuid];for(let e of t.children)this.unregisterObject(e)}createObject(t,e,n,r,i,a){var o;let l={scene:this,shared:a},h=fy(t,e,l);return h&&(this.entityByUuid[t]=h,r.add(h),r.children.splice(i,0,r.children.pop()),n.length>0&&(h.isInstanceRoot?console.error("instance should not have children!"):this.createChildrenObjects(n,h,a)),h.updateState(e,l),h instanceof Og&&h.updateGeometryGroupsIfNeeded(),h.updateVisible(),h.cloner&&this.toExpandCloner.add(h),(null==(o=e.pathSnapping)?void 0:o.pathId)&&this.pathConstraints.setConstraint(t,e.pathSnapping.pathId)),"Empty"===e.type&&e.animations&&h.traverseEntity((t=>{if(t instanceof Og&&t.isSkinnedMesh){let e=t.dataPatched;if(e.bones&&e.boneInverses){let n=e.bones.map((t=>this.find(t))),r=e.boneInverses.map((t=>(new s).fromArray(t))),i=new J(n,r);t.bind(i,t.bindMatrix)}}else t.matrixAutoUpdate=!0})),h}getCenter(t){let e=[];for(let r=0,i=t.length;r<i;++r){let{id:n,recursive:i}=t[r],a=this.find(n),s=i?a.recursiveBBox:a.singleBBox;e.push(...s.vertices)}let n=new c;return n.setFromPoints(e),n.getCenter(_y),_y}copyMatrixWorld(t,e){if(null===t)return void e.identity();let n=this.find(t);n?e.copy(n.matrixWorld):e.identity()}copyParentMatrixWorld(t,e){var n;if(null===t)return void e.identity();let r=null==(n=this.find(t))?void 0:n.parent;r?e.copy(r.matrixWorld):e.identity()}traverseMaterial(t){this.traverseEntity((e=>{if(e instanceof kp)if(Array.isArray(e.material))for(let n=0;n<e.material.length;n++)e.material[n]instanceof Zm&&t(e.material[n]);else e.material instanceof Zm&&t(e.material)}))}updateViewPlaneSize(t,e,n=!1){this.traverseConcreteEntity((r=>{r instanceof Iv&&r.setViewplaneSize(t,e,n)}))}};async function Ay(t){if(wy){let e,n={attributeIDs:wy.defaultAttributeIDs,attributeTypes:wy.defaultAttributeTypes,useUniqueIDs:!1};try{e=await wy.decodeGeometry(new Int8Array(t).buffer,n)}catch(Ja){console.error(Ja)}if(e)return{index:e.index?{array:e.index.array}:void 0,attributes:Object.entries(e.attributes).map((([t,e])=>({name:t,itemSize:e.itemSize,array:e.array})))}}return null}async function Oy(t,e){let[n,r]=Cs(Xo.deserialize(new Uint8Array(t)));nd(n);let i=[];n.scene.objects.traverse(((t,e)=>{"Mesh"===e.type&&"NonParametricGeometry"===e.geometry.type&&void 0!==e.geometry.data.draco&&i.push(e)})),i.length&&await(wy||(wy=new Nt).setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.2/").preload(),wy.decoderPending);for(let a of i){let t=await Ay(Ds(a.geometry.data.draco));if(t){t.index&&(a.geometry.data.index={array:t.index.array,itemSize:1,normalized:!1,type:"Uint32Array"});let e={};t.attributes.forEach((({name:t,array:n,itemSize:r})=>{e[t]={array:n,itemSize:r,type:"Float32Array",normalized:!1}})),a.geometry.data.attributes=e,a.geometry.data.draco=void 0}}return e&&e(n),r.result().data}function My(t){let e=new Set;return t.traverse((t=>{if(t instanceof bg)if(me(t.material))t.material.forEach((t=>{let n=t;e.has(n)||e.add(n)}));else{let n=t.material;e.has(n)||e.add(n)}})),e.forEach((t=>{if(t instanceof Array)return;let e=t.onBeforeCompile.bind(t);if(function(t){return t.getLayersOfType("transmission").length>0}(t)){Object.assign(t,{isMeshStandardMaterial:!0,isMeshPhysicalMaterial:!0,transmission:1,attenuationColor:new _,specularColor:new _});let n=0;t.onBeforeCompile=(r,i)=>{e&&e(r,i),r.uniforms=Object.assign({},tt.physical.uniforms,r.uniforms),t.getLayersOfType("transmission").forEach((e=>{if(r.uniforms.transmissionSamplerMap.value){let n=e.color;n&&(n.transmissionSamplerMap.value=r.uniforms.transmissionSamplerMap.value,n.transmissionSamplerSize.value=r.uniforms.transmissionSamplerSize.value,n.aspectRatio.value=function(t,e){return t>=e?new l(e/t,1):new l(1,t/e)}(window.innerWidth,window.innerHeight),t.defines.IS_THREEJS_EXPORT=!0)}else n++,n<2&&(t.needsUpdate=!0)}))}}else(function(t){let e=0;for(let n of t.layers){if("displace"!==n.data.type&&n.data.isMask)return!0;if("light"!==n.type&&"fresnel"!==n.type){let t=n.uniforms["f"+n.id+"_alpha"];t&&(e+=(1-e)*t.value)}}return e<1})(t)||(t.onBeforeCompile=(n,r)=>{e&&e(n,r),t.transparent=!1})})),t}function Cy(t){Object.values(t.shared.materials).forEach((t=>{Py(t)})),t.scene.objects.traverse(((t,e)=>{"material"in e?Py(e.material):"materials"in e&&e.materials.forEach((t=>{Py(t)}))}))}function Py(t){if("string"==typeof t)return;let e=[];t.layers.forEach(((t,n)=>{"outline"===t.type&&e.push(n)})),e.reverse().forEach((e=>{t.layers.delete(e)})),e.length&&console.warn("The Spline Loader currently does not support the outline layer.")}var Dy=Ht(Kt(),1);var Ty="The SplineLoader only accepts .splinecode files that are generated from Spline export panel.",zy=class extends r{load(t,e,n,r=console.error){let a=new i(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),t.endsWith(".spline")?console.warn(Ty+" The .spline files are only meant to be used by the Editor."):t.endsWith(".splinecode")||console.warn(Ty),a.load(t,(async t=>{try{if("string"==typeof t)throw new Error("The .spline file is not binary!");let n=await this.parse(t);e(n)}catch(nl){r(nl)}}),n,r)}async parse(t){let e=await Oy(t,Cy);e.version&&(0,Dy.default)(e.version,"0.9.473")>0&&console.warn("Your .splinecode file is more recent than the library. Please upgrade @splinetool/loader to the latest version."),await Promise.all([Tg(e)&&np(),Kg(e)&&hg()].filter(Boolean));let n=new vg(e.shared);Object.values(n.getMaterials()).forEach((t=>Object.assign(t,{isAsset:!0})));let r=new Sy(e.scene,n),i=r.activeCamera;return i&&Object.assign(i,{makeDefault:!0}),r=function(t){let e=[];return t.traverse((t=>{t instanceof fv&&e.push(t)})),e.forEach((e=>{let n=e.object,r=[...e.children.map((t=>{let e;if(t.updateMatrix(),void 0!==t.geometry)try{e=t.geometry.clone().applyMatrix4(t.matrix)}catch(n){console.error(n)}return void 0!==e&&t.matrix.determinant()<0&&function(t){let e;if(t.index)for(let n=0;n<t.index.array.length;n+=3)e=t.index.array[n],t.index.array[n]=t.index.array[n+2],t.index.array[n+2]=e}(e),e})).filter((t=>void 0!==t))];if(!e.parameters.hideBase&&n instanceof kp&&r.unshift(n.geometry),r.length){let t=zt(r);n instanceof kp&&(n.geometry=t)}e.removeFromParent(),n.setFromClonerState(null,{scene:t,shared:yg})})),t}(r),r=My(r),r=function(t){return t.traverse((t=>{if("Camera"===t.type){let e=t;e.type=e.cameraType}})),t}(r),r=function(t){let e=[],n=(t,r=0)=>{let i=r>0?t+r:t;return e.includes(i)?n(t,r+1):i};return t.traverse((t=>{if(e.includes(t.name)){let e=t.name,r=n(t.name);if(t.name=r,t.isMesh){let n=t;n.material instanceof Array?n.material.forEach((t=>{t.name=t.name.replace(e,r)})):n.material.isAsset||(n.material.name=n.material.name.replace(e,r))}}e.push(t.name)})),t}(r),r=function(t){return t.traverse((t=>{t.matrixAutoUpdate=!0})),t}(r),r=function(t){return t.traverseMaterial((t=>{t.needsJitter=!1})),t}(r),r}};function Ey(t){const e=Dt(zy,t);return Tt(e)}export{Lt as a,zt as m,Ey as u};
