import{j as t}from"./r3-other-vendor-2c8fc3cb.js";import{R as e,a as n}from"./react-vendor-670efa73.js";import{O as r,B as a,az as i,r as o,u as s,aV as l,aR as c,aE as u,R as f,al as h,V as d,k as m,C as p,bl as g,p as v,b as x,w as y,bX as b,bq as w,t as T,j as R,aN as S,D as I,ax as M,as as P,bb as F,bZ as A,b_ as D,U as C,aX as _,b$ as E,c0 as B,c1 as z,c2 as O,aG as N,c3 as H,c4 as k,aP as W,P as U,l as L,aZ as V,a5 as q,ap as G,a3 as j,c5 as Y,Y as $,N as X,c6 as Q,aD as Z,aF as K,Q as J,F as tt,H as et,ag as nt,c7 as rt,c8 as at,bm as it}from"./three-vendor-6d04682c.js";import{b as ot,d as st,O as lt,Y as ct,J as ut,C as ft}from"./r3-extend-vendor-ed1023dc.js";import{m as ht,a as dt}from"./three-sp-vendor-e6627391.js";const mt=new r(-1,1,1,-1,0,1),pt=new a;pt.setAttribute("position",new i([-1,3,0,-1,-1,0,3,-1,0],3)),pt.setAttribute("uv",new i([0,2,0,0,2,0],2));let gt=class{constructor(t){this._mesh=new o(pt,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,mt)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}};class vt extends s{constructor(t){super(t);for(const e in this.uniforms)Object.defineProperty(this,e,{get(){return this.uniforms[e].value},set(t){this.uniforms[e].value=t}})}setDefine(t,e=void 0){null==e?t in this.defines&&(delete this.defines[t],this.needsUpdate=!0):this.defines[t]!==e&&(this.defines[t]=e,this.needsUpdate=!0)}}class xt extends vt{constructor(t){super({blending:l,uniforms:{target1:{value:null},target2:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}"}),this.setValues(t)}}function yt(t=1){let e="uint";return t>1&&(e="uvec"+t),`\n\t\t${e} sobolReverseBits( ${e} x ) {\n\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\n\n\t\t}\n\n\t\t${e} sobolHashCombine( uint seed, ${e} v ) {\n\n\t\t\treturn seed ^ ( v + ${e}( ( seed << 6 ) + ( seed >> 2 ) ) );\n\n\t\t}\n\n\t\t${e} sobolLaineKarrasPermutation( ${e} x, ${e} seed ) {\n\n\t\t\tx += seed;\n\t\t\tx ^= x * 0x6c50b47cu;\n\t\t\tx ^= x * 0xb82f1e52u;\n\t\t\tx ^= x * 0xc7afe638u;\n\t\t\tx ^= x * 0x8d22f6e6u;\n\t\t\treturn x;\n\n\t\t}\n\n\t\t${e} nestedUniformScrambleBase2( ${e} x, ${e} seed ) {\n\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\n\t\t\tx = sobolReverseBits( x );\n\t\t\treturn x;\n\n\t\t}\n\t`}function bt(t=1){let e="uint",n="float",r="",a=".r",i="1u";return t>1&&(e="uvec"+t,n="vec"+t,r=t+"",2===t?(a=".rg",i="uvec2( 1u, 2u )"):3===t?(a=".rgb",i="uvec3( 1u, 2u, 3u )"):(a="",i="uvec4( 1u, 2u, 3u, 4u )")),`\n\n\t\t${n} sobol${r}( int effect ) {\n\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\n\t\t\tuint index = sobolPathIndex;\n\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\n\t\t\t${n} sobol_pt = sobolGetTexturePoint( shuffled_index )${a};\n\t\t\t${e} result = ${e}( sobol_pt * 16777216.0 );\n\n\t\t\t${e} seed2 = sobolHashCombine( seed, ${i} );\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\n\n\t\t\treturn SOBOL_FACTOR * ${n}( result >> 8 );\n\n\t\t}\n\t`}const wt=`\n\n\t// Utils\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\n\n\t${yt(1)}\n\t${yt(2)}\n\t${yt(3)}\n\t${yt(4)}\n\n\tuint sobolHash( uint x ) {\n\n\t\t// finalizer from murmurhash3\n\t\tx ^= x >> 16;\n\t\tx *= 0x85ebca6bu;\n\t\tx ^= x >> 13;\n\t\tx *= 0xc2b2ae35u;\n\t\tx ^= x >> 16;\n\t\treturn x;\n\n\t}\n\n`,Tt=`\n\n\t// Seeds\n\tuniform sampler2D sobolTexture;\n\tuint sobolPixelIndex;\n\tuint sobolPathIndex;\n\tuint sobolBounceIndex;\n\n\tuint sobolGetSeed( uint bounce, uint effect ) {\n\n\t\treturn sobolHash(\n\t\t\tsobolHashCombine(\n\t\t\t\tsobolHashCombine(\n\t\t\t\t\tsobolHash( bounce ),\n\t\t\t\t\tsobolPixelIndex\n\t\t\t\t),\n\t\t\t\teffect\n\t\t\t)\n\t\t);\n\n\t}\n\n\tvec4 sobolGetTexturePoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\tindex = index % SOBOL_MAX_POINTS;\n\n\t\t}\n\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\n\t\tuint y = index / dim.x;\n\t\tuint x = index - y * dim.x;\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\n\t\treturn texture( sobolTexture, uv );\n\n\t}\n\n\t${bt(1)}\n\t${bt(2)}\n\t${bt(3)}\n\t${bt(4)}\n\n`;class Rt extends vt{constructor(){super({blending:l,uniforms:{resolution:{value:new d}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:`\n\n\t\t\t\t${wt}\n\t\t\t\t\n\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\n\t);\n\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\n\n\t\tuint X = 0u;\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\n\n\t\t\tuint mask = ( index >> bit ) & 1u;\n\t\t\tX ^= mask * directions[ bit ];\n\n\t\t}\n\t\treturn X;\n\n\t}\n\n\tvec4 generateSobolPoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\treturn vec4( 0.0 );\n\n\t\t}\n\n\t\t// NOTEL this sobol "direction" is also available but we can't write out 5 components\n\t\t// uint x = index & 0x00ffffffu;\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\n\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\n\n\t}\n\n\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\n\n\t\t\t\t}\n\t\t\t`})}}class St{generate(t,e=256){const n=new c(e,e,{type:u,format:f,minFilter:h,magFilter:h,generateMipmaps:!1}),r=t.getRenderTarget();t.setRenderTarget(n);const a=new gt(new Rt);return a.material.resolution.set(e,e),a.render(t),t.setRenderTarget(r),a.dispose(),n}}const It=new m,Mt=new m;function*Pt(){const{_renderer:t,_fsQuad:e,_blendQuad:n,_primaryTarget:r,_blendTargets:a,_sobolTarget:i,_subframe:o,alpha:s,camera:c,material:u}=this,f=new m,h=new m,d=n.material;let[p,v]=a;for(;;){s?(d.opacity=this._opacityFactor/(this._samples+1),u.blending=l,u.opacity=1):(u.opacity=this._opacityFactor/(this._samples+1),u.blending=g);const[a,m,x,y]=o,b=r.width,w=r.height;u.resolution.set(b*x,w*y),u.sobolTexture=i.texture,u.seed++;const T=this.tiles.x||1,R=this.tiles.y||1,S=T*R,I=1/t.getPixelRatio();for(let i=0;i<R;i++)for(let o=0;o<T;o++){u.cameraWorldMatrix.copy(c.matrixWorld),u.invProjectionMatrix.copy(c.projectionMatrixInverse);let l=0;c.projectionMatrix.elements[15]>0&&(l=1),c.isEquirectCamera&&(l=2),u.setDefine("CAMERA_TYPE",l);const g=t.getRenderTarget(),M=t.autoClear,P=t.getScissorTest();t.getScissor(f),t.getViewport(h);let F=o,A=i;if(!this.stableTiles){const t=this._currentTile%(T*R);F=t%T,A=~~(t/T),this._currentTile=t+1}t.setRenderTarget(r),t.setScissorTest(!0),It.x=F*b/T,It.y=(R-A-1)*w/R,It.z=b/T,It.w=w/R,It.x=a*b+x*It.x,It.y=m*w+y*It.y,It.z=x*It.z,It.w=y*It.w,It.x=It.x,It.y=It.y,It.z=It.z,It.w=It.w,It.multiplyScalar(I).ceil(),Mt.x=a*b,Mt.y=m*w,Mt.z=x*b,Mt.w=y*w,Mt.multiplyScalar(I).ceil(),t.setScissor(It),t.setViewport(Mt),t.autoClear=!1,e.render(t),t.setViewport(h),t.setScissor(f),t.setScissorTest(P),t.setRenderTarget(g),t.autoClear=M,s&&(d.target1=p.texture,d.target2=r.texture,t.setRenderTarget(v),n.render(t),t.setRenderTarget(g)),this._samples+=1/S,o===T-1&&i===R-1&&(this._samples=Math.round(this._samples)),yield}[p,v]=[v,p]}}const Ft=new p;class At{get material(){return this._fsQuad.material}set material(t){this._fsQuad.material=t}get target(){return this._alpha?this._blendTargets[1]:this._primaryTarget}set alpha(t){this._alpha!==t&&(t||(this._blendTargets[0].dispose(),this._blendTargets[1].dispose()),this._alpha=t,this.reset())}get alpha(){return this._alpha}get samples(){return this._samples}constructor(t){this.camera=null,this.tiles=new d(1,1),this.stableNoise=!1,this.stableTiles=!0,this._samples=0,this._subframe=new m(0,0,1,1),this._opacityFactor=1,this._renderer=t,this._alpha=!1,this._fsQuad=new gt(null),this._blendQuad=new gt(new xt),this._task=null,this._currentTile=0,this._sobolTarget=(new St).generate(t),this._primaryTarget=new c(1,1,{format:f,type:u}),this._blendTargets=[new c(1,1,{format:f,type:u}),new c(1,1,{format:f,type:u})]}setSize(t,e){t=Math.ceil(t),e=Math.ceil(e),this._primaryTarget.width===t&&this._primaryTarget.height===e||(this._primaryTarget.setSize(t,e),this._blendTargets[0].setSize(t,e),this._blendTargets[1].setSize(t,e),this.reset())}dispose(){this._primaryTarget.dispose(),this._blendTargets[0].dispose(),this._blendTargets[1].dispose(),this._sobolTarget.dispose(),this._fsQuad.dispose(),this._blendQuad.dispose(),this._task=null}reset(){const{_renderer:t,_primaryTarget:e,_blendTargets:n}=this,r=t.getRenderTarget(),a=t.getClearAlpha();t.getClearColor(Ft),t.setRenderTarget(e),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[0]),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[1]),t.setClearColor(0,0),t.clearColor(),t.setClearColor(Ft,a),t.setRenderTarget(r),this._samples=0,this._task=null,this.stableNoise&&(this.material.seed=0)}update(){this._task||(this._task=Pt.call(this)),this._task.next()}}const Dt=0,Ct=1,_t=2,Et=1.25,Bt=1,zt=32,Ot=65535,Nt=Math.pow(2,-24);class Ht{constructor(){}}function kt(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function Wt(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const a=t[r+3]-t[r];a>n&&(n=a,e=r)}return e}function Ut(t,e){e.set(t)}function Lt(t,e,n){let r,a;for(let i=0;i<3;i++){const o=i+3;r=t[i],a=e[i],n[i]=r<a?r:a,r=t[o],a=e[o],n[o]=r>a?r:a}}function Vt(t,e,n){for(let r=0;r<3;r++){const a=e[t+2*r],i=e[t+2*r+1],o=a-i,s=a+i;o<n[r]&&(n[r]=o),s>n[r+3]&&(n[r+3]=s)}}function qt(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}function Gt(t,e,n,r,a=null){let i=1/0,o=1/0,s=1/0,l=-1/0,c=-1/0,u=-1/0,f=1/0,h=1/0,d=1/0,m=-1/0,p=-1/0,g=-1/0;const v=null!==a;for(let x=6*e,y=6*(e+n);x<y;x+=6){const e=t[x+0],n=t[x+1],r=e-n,a=e+n;r<i&&(i=r),a>l&&(l=a),v&&e<f&&(f=e),v&&e>m&&(m=e);const y=t[x+2],b=t[x+3],w=y-b,T=y+b;w<o&&(o=w),T>c&&(c=T),v&&y<h&&(h=y),v&&y>p&&(p=y);const R=t[x+4],S=t[x+5],I=R-S,M=R+S;I<s&&(s=I),M>u&&(u=M),v&&R<d&&(d=R),v&&R>g&&(g=R)}r[0]=i,r[1]=o,r[2]=s,r[3]=l,r[4]=c,r[5]=u,v&&(a[0]=f,a[1]=h,a[2]=d,a[3]=m,a[4]=p,a[5]=g)}const jt=32,Yt=(t,e)=>t.candidate-e.candidate,$t=new Array(jt).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),Xt=new Float32Array(6);function Qt(t,e){function n(t){h&&h(t/d)}function r(e,a,h,d=null,p=0){if(!m&&p>=l&&(m=!0,c&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),h<=u||p>=l)return n(a+h),e.offset=a,e.count=h,e;const g=function(t,e,n,r,a,i){let o=-1,s=0;if(i===Dt)o=Wt(e),-1!==o&&(s=(e[o]+e[o+3])/2);else if(i===Ct)o=Wt(t),-1!==o&&(s=function(t,e,n,r){let a=0;for(let i=e,o=e+n;i<o;i++)a+=t[6*i+2*r];return a/n}(n,r,a,o));else if(i===_t){const i=qt(t);let l=Et*a;const c=6*r,u=6*(r+a);for(let t=0;t<3;t++){const r=e[t],f=(e[t+3]-r)/jt;if(a<jt/4){const e=[...$t];e.length=a;let r=0;for(let a=c;a<u;a+=6,r++){const i=e[r];i.candidate=n[a+2*t],i.count=0;const{bounds:o,leftCacheBounds:s,rightCacheBounds:l}=i;for(let t=0;t<3;t++)l[t]=1/0,l[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0;Vt(a,n,o)}e.sort(Yt);let f=a;for(let t=0;t<f;t++){const n=e[t];for(;t+1<f&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),f--}for(let a=c;a<u;a+=6){const r=n[a+2*t];for(let t=0;t<f;t++){const i=e[t];r>=i.candidate?Vt(a,n,i.rightCacheBounds):(Vt(a,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<f;n++){const r=e[n],c=r.count,u=a-r.count,f=r.leftCacheBounds,h=r.rightCacheBounds;let d=0;0!==c&&(d=qt(f)/i);let m=0;0!==u&&(m=qt(h)/i);const p=Bt+Et*(d*c+m*u);p<l&&(o=t,l=p,s=r.candidate)}}else{for(let t=0;t<jt;t++){const e=$t[t];e.count=0,e.candidate=r+f+t*f;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let a=c;a<u;a+=6){let e=~~((n[a+2*t]-r)/f);e>=jt&&(e=jt-1);const i=$t[e];i.count++,Vt(a,n,i.bounds)}const e=$t[jt-1];Ut(e.bounds,e.rightCacheBounds);for(let t=jt-2;t>=0;t--){const e=$t[t],n=$t[t+1];Lt(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let h=0;for(let n=0;n<jt-1;n++){const e=$t[n],r=e.count,c=e.bounds,u=$t[n+1].rightCacheBounds;0!==r&&(0===h?Ut(c,Xt):Lt(c,Xt,Xt)),h+=r;let f=0,d=0;0!==h&&(f=qt(Xt)/i);const m=a-h;0!==m&&(d=qt(u)/i);const p=Bt+Et*(f*h+d*m);p<l&&(o=t,l=p,s=e.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);return{axis:o,pos:s}}(e.boundingData,d,o,a,h,f);if(-1===g.axis)return n(a+h),e.offset=a,e.count=h,e;const v=function(t,e,n,r,a){let i=n,o=n+r-1;const s=a.pos,l=2*a.axis;for(;;){for(;i<=o&&e[6*i+l]<s;)i++;for(;i<=o&&e[6*o+l]>=s;)o--;if(!(i<o))return i;for(let n=0;n<3;n++){let r=t[3*i+n];t[3*i+n]=t[3*o+n],t[3*o+n]=r;let a=e[6*i+2*n+0];e[6*i+2*n+0]=e[6*o+2*n+0],e[6*o+2*n+0]=a;let s=e[6*i+2*n+1];e[6*i+2*n+1]=e[6*o+2*n+1],e[6*o+2*n+1]=s}i++,o--}}(s,o,a,h,g);if(v===a||v===a+h)n(a+h),e.offset=a,e.count=h;else{e.splitAxis=g.axis;const t=new Ht,n=a,s=v-a;e.left=t,t.boundingData=new Float32Array(6),Gt(o,n,s,t.boundingData,i),r(t,n,s,i,p+1);const l=new Ht,c=v,u=h-s;e.right=l,l.boundingData=new Float32Array(6),Gt(o,c,u,l.boundingData,i),r(l,c,u,i,p+1)}return e}!function(t,e){if(!t.index){const n=t.attributes.position.count,r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let a;a=n>65535?new Uint32Array(new r(4*n)):new Uint16Array(new r(2*n)),t.setIndex(new v(a,1));for(let t=0;t<n;t++)a[t]=t}}(t,e);const a=new Float32Array(6),i=new Float32Array(6),o=function(t,e){const n=t.attributes.position,r=t.index.array,a=r.length/3,i=new Float32Array(6*a),o=n.normalized,s=n.array,l=n.offset||0;let c=3;n.isInterleavedBufferAttribute&&(c=n.data.stride);const u=["getX","getY","getZ"];for(let f=0;f<a;f++){const t=3*f,a=6*f;let h,d,m;o?(h=r[t+0],d=r[t+1],m=r[t+2]):(h=r[t+0]*c+l,d=r[t+1]*c+l,m=r[t+2]*c+l);for(let r=0;r<3;r++){let t,l,c;o?(t=n[u[r]](h),l=n[u[r]](d),c=n[u[r]](m)):(t=s[h+r],l=s[d+r],c=s[m+r]);let f=t;l<f&&(f=l),c<f&&(f=c);let p=t;l>p&&(p=l),c>p&&(p=c);const g=(p-f)/2,v=2*r;i[a+v+0]=f+g,i[a+v+1]=g+(Math.abs(f)+g)*Nt,f<e[r]&&(e[r]=f),p>e[r+3]&&(e[r+3]=p)}}return i}(t,a),s=t.index.array,l=e.maxDepth,c=e.verbose,u=e.maxLeafTris,f=e.strategy,h=e.onProgress,d=t.index.count/3;let m=!1;const p=[],g=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const a of t.groups)n.add(a.start),n.add(a.start+a.count);const r=Array.from(n.values()).sort(((t,e)=>t-e));for(let a=0;a<r.length-1;a++){const t=r[a],n=r[a+1];e.push({offset:t/3,count:(n-t)/3})}return e}(t);if(1===g.length){const t=g[0],e=new Ht;e.boundingData=a,function(t,e,n,r){let a=1/0,i=1/0,o=1/0,s=-1/0,l=-1/0,c=-1/0;for(let u=6*e,f=6*(e+n);u<f;u+=6){const e=t[u+0];e<a&&(a=e),e>s&&(s=e);const n=t[u+2];n<i&&(i=n),n>l&&(l=n);const r=t[u+4];r<o&&(o=r),r>c&&(c=r)}r[0]=a,r[1]=i,r[2]=o,r[3]=s,r[4]=l,r[5]=c}(o,t.offset,t.count,i),r(e,t.offset,t.count,i),p.push(e)}else for(let v of g){const t=new Ht;t.boundingData=new Float32Array(6),Gt(o,v.offset,v.count,t.boundingData,i),r(t,v.offset,v.count,i),p.push(t)}return p}class Zt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let a=0,i=t.length;a<i;a++){const i=t[a][e];n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let a=0,i=e.length;a<i;a++){const i=e[a],o=t.dot(i);n=o<n?o:n,r=o>r?o:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}Zt.prototype.setFromBox=function(){const t=new x;return function(e,n){const r=n.min,a=n.max;let i=1/0,o=-1/0;for(let s=0;s<=1;s++)for(let n=0;n<=1;n++)for(let l=0;l<=1;l++){t.x=r.x*s+a.x*(1-s),t.y=r.y*n+a.y*(1-n),t.z=r.z*l+a.z*(1-l);const c=e.dot(t);i=Math.min(c,i),o=Math.max(c,o)}this.min=i,this.max=o}}();const Kt=function(){const t=new x,e=new x,n=new x;return function(r,a,i){const o=r.start,s=t,l=a.start,c=e;n.subVectors(o,l),t.subVectors(r.end,r.start),e.subVectors(a.end,a.start);const u=n.dot(c),f=c.dot(s),h=c.dot(c),d=n.dot(s),m=s.dot(s)*h-f*f;let p,g;p=0!==m?(u*f-d*h)/m:0,g=(u+p*f)/h,i.x=p,i.y=g}}(),Jt=function(){const t=new d,e=new x,n=new x;return function(r,a,i,o){Kt(r,a,t);let s=t.x,l=t.y;if(s>=0&&s<=1&&l>=0&&l<=1)return r.at(s,i),void a.at(l,o);if(s>=0&&s<=1)return l<0?a.at(0,o):a.at(1,o),void r.closestPointToPoint(o,!0,i);if(l>=0&&l<=1)return s<0?r.at(0,i):r.at(1,i),void a.closestPointToPoint(i,!0,o);{let t,c;t=s<0?r.start:r.end,c=l<0?a.start:a.end;const u=e,f=n;return r.closestPointToPoint(c,!0,e),a.closestPointToPoint(t,!0,n),u.distanceToSquared(c)<=f.distanceToSquared(t)?(i.copy(u),void o.copy(c)):(i.copy(t),void o.copy(f))}}}(),te=function(){const t=new x,e=new x,n=new y,r=new b;return function(a,i){const{radius:o,center:s}=a,{a:l,b:c,c:u}=i;r.start=l,r.end=c;if(r.closestPointToPoint(s,!0,t).distanceTo(s)<=o)return!0;r.start=l,r.end=u;if(r.closestPointToPoint(s,!0,t).distanceTo(s)<=o)return!0;r.start=c,r.end=u;if(r.closestPointToPoint(s,!0,t).distanceTo(s)<=o)return!0;const f=i.getPlane(n);if(Math.abs(f.distanceToPoint(s))<=o){const t=f.projectPoint(s,e);if(i.containsPoint(t))return!0}return!1}}();function ee(t){return Math.abs(t)<1e-15}class ne extends w{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new x)),this.satBounds=new Array(4).fill().map((()=>new Zt)),this.points=[this.a,this.b,this.c],this.sphere=new T,this.plane=new y,this.needsUpdate=!0}intersectsSphere(t){return te(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,a=this.satAxes,i=this.satBounds,o=a[0],s=i[0];this.getNormal(o),s.setFromPoints(o,r);const l=a[1],c=i[1];l.subVectors(t,e),c.setFromPoints(l,r);const u=a[2],f=i[2];u.subVectors(e,n),f.setFromPoints(u,r);const h=a[3],d=i[3];h.subVectors(n,t),d.setFromPoints(h,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}ne.prototype.closestPointToSegment=function(){const t=new x,e=new x,n=new b;return function(r,a=null,i=null){const{start:o,end:s}=r,l=this.points;let c,u=1/0;for(let f=0;f<3;f++){const o=(f+1)%3;n.start.copy(l[f]),n.end.copy(l[o]),Jt(n,r,t,e),c=t.distanceToSquared(e),c<u&&(u=c,a&&a.copy(t),i&&i.copy(e))}return this.closestPointToPoint(o,t),c=o.distanceToSquared(t),c<u&&(u=c,a&&a.copy(t),i&&i.copy(o)),this.closestPointToPoint(s,t),c=s.distanceToSquared(t),c<u&&(u=c,a&&a.copy(t),i&&i.copy(s)),Math.sqrt(u)}}(),ne.prototype.intersectsTriangle=function(){const t=new ne,e=new Array(3),n=new Array(3),r=new Zt,a=new Zt,i=new x,o=new x,s=new x,l=new x,c=new b,u=new b,f=new b;return function(h,d=null,m=!1){this.needsUpdate&&this.update(),h.isExtendedTriangle?h.needsUpdate&&h.update():(t.copy(h),t.update(),h=t);const p=this.plane,g=h.plane;if(Math.abs(p.normal.dot(g.normal))>1-1e-10){const t=this.satBounds,o=this.satAxes;n[0]=h.a,n[1]=h.b,n[2]=h.c;for(let e=0;e<4;e++){const a=t[e],i=o[e];if(r.setFromPoints(i,n),a.isSeparated(r))return!1}const s=h.satBounds,l=h.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let n=0;n<4;n++){const t=s[n],a=l[n];if(r.setFromPoints(a,e),t.isSeparated(r))return!1}for(let c=0;c<4;c++){const t=o[c];for(let o=0;o<4;o++){const s=l[o];if(i.crossVectors(t,s),r.setFromPoints(i,e),a.setFromPoints(i,n),r.isSeparated(a))return!1}}return d&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}{const t=this.points;let e=!1,n=0;for(let s=0;s<3;s++){const r=t[s],a=t[(s+1)%3];c.start.copy(r),c.end.copy(a),c.delta(o);const i=e?u.start:u.end,l=ee(g.distanceToPoint(r));if(ee(g.normal.dot(o))&&l){u.copy(c),n=2;break}if((g.intersectLine(c,i)||l)&&!ee(i.distanceTo(a))){if(n++,e)break;e=!0}}if(1===n&&h.containsPoint(u.end))return d&&(d.start.copy(u.end),d.end.copy(u.end)),!0;if(2!==n)return!1;const r=h.points;let a=!1,i=0;for(let o=0;o<3;o++){const t=r[o],e=r[(o+1)%3];c.start.copy(t),c.end.copy(e),c.delta(s);const n=a?f.start:f.end,l=ee(p.distanceToPoint(t));if(ee(p.normal.dot(s))&&l){f.copy(c),i=2;break}if((p.intersectLine(c,n)||l)&&!ee(n.distanceTo(e))){if(i++,a)break;a=!0}}if(1===i&&this.containsPoint(f.end))return d&&(d.start.copy(f.end),d.end.copy(f.end)),!0;if(2!==i)return!1;if(u.delta(o),f.delta(s),o.dot(s)<0){let t=f.start;f.start=f.end,f.end=t}const m=u.start.dot(o),v=u.end.dot(o),x=f.start.dot(o),y=f.end.dot(o);return(m===y||x===v||v<x!==m<y)&&(d&&(l.subVectors(u.start,f.start),l.dot(o)>0?d.start.copy(u.start):d.start.copy(f.start),l.subVectors(u.end,f.end),l.dot(o)<0?d.end.copy(u.end):d.end.copy(f.end)),!0)}}}(),ne.prototype.distanceToPoint=function(){const t=new x;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),ne.prototype.distanceToTriangle=function(){const t=new x,e=new x,n=["a","b","c"],r=new b,a=new b;return function(i,o=null,s=null){const l=o||s?r:null;if(this.intersectsTriangle(i,l))return(o||s)&&(o&&l.getCenter(o),s&&l.getCenter(s)),0;let c=1/0;for(let e=0;e<3;e++){let r;const a=n[e],l=i[a];this.closestPointToPoint(l,t),r=l.distanceToSquared(t),r<c&&(c=r,o&&o.copy(t),s&&s.copy(l));const u=this[a];i.closestPointToPoint(u,t),r=u.distanceToSquared(t),r<c&&(c=r,o&&o.copy(u),s&&s.copy(t))}for(let u=0;u<3;u++){const l=n[u],f=n[(u+1)%3];r.set(this[l],this[f]);for(let u=0;u<3;u++){const l=n[u],f=n[(u+1)%3];a.set(i[l],i[f]),Jt(r,a,t,e);const h=t.distanceToSquared(e);h<c&&(c=h,o&&o.copy(t),s&&s.copy(e))}}return Math.sqrt(c)}}();class re{constructor(t,e,n){this.isOrientedBox=!0,this.min=new x,this.max=new x,this.matrix=new R,this.invMatrix=new R,this.points=new Array(8).fill().map((()=>new x)),this.satAxes=new Array(3).fill().map((()=>new x)),this.satBounds=new Array(3).fill().map((()=>new Zt)),this.alignedSatBounds=new Array(3).fill().map((()=>new Zt)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}re.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let l=0;l<=1;l++)for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){const o=r[1*l|2*a|4*i];o.x=l?n.x:e.x,o.y=a?n.y:e.y,o.z=i?n.z:e.z,o.applyMatrix4(t)}const a=this.satBounds,i=this.satAxes,o=r[0];for(let l=0;l<3;l++){const t=i[l],e=a[l],n=r[1<<l];t.subVectors(o,n),e.setFromPoints(t,r)}const s=this.alignedSatBounds;s[0].setFromPointsField(r,"x"),s[1].setFromPointsField(r,"y"),s[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},re.prototype.intersectsBox=function(){const t=new Zt;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,a=this.satBounds,i=this.satAxes,o=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,o[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,o[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,o[2].isSeparated(t))return!1;for(let s=0;s<3;s++){const n=i[s],r=a[s];if(t.setFromBox(n,e),r.isSeparated(t))return!1}return!0}}(),re.prototype.intersectsTriangle=function(){const t=new ne,e=new Array(3),n=new Zt,r=new Zt,a=new x;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(t.copy(i),t.update(),i=t);const o=this.satBounds,s=this.satAxes;e[0]=i.a,e[1]=i.b,e[2]=i.c;for(let t=0;t<3;t++){const r=o[t],a=s[t];if(n.setFromPoints(a,e),r.isSeparated(n))return!1}const l=i.satBounds,c=i.satAxes,u=this.points;for(let t=0;t<3;t++){const e=l[t],r=c[t];if(n.setFromPoints(r,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const i=s[t];for(let t=0;t<4;t++){const o=c[t];if(a.crossVectors(i,o),n.setFromPoints(a,e),r.setFromPoints(a,u),n.isSeparated(r))return!1}}return!0}}(),re.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},re.prototype.distanceToPoint=function(){const t=new x;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),re.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new b)),n=new Array(12).fill().map((()=>new b)),r=new x,a=new x;return function(i,o=0,s=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(s||l)&&(i.getCenter(a),this.closestPointToPoint(a,r),i.closestPointToPoint(r,a),s&&s.copy(r),l&&l.copy(a)),0;const c=o*o,u=i.min,f=i.max,h=this.points;let d=1/0;for(let t=0;t<8;t++){const e=h[t];a.copy(e).clamp(u,f);const n=e.distanceToSquared(a);if(n<d&&(d=n,s&&s.copy(e),l&&l.copy(a),n<c))return Math.sqrt(n)}let m=0;for(let r=0;r<3;r++)for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){const o=(r+1)%3,s=(r+2)%3,l=1<<r|a<<o|i<<s,c=h[a<<o|i<<s],d=h[l];e[m].set(c,d);const p=t[r],g=t[o],v=t[s],x=n[m],y=x.start,b=x.end;y[p]=u[p],y[g]=a?u[g]:f[g],y[v]=i?u[v]:f[g],b[p]=f[p],b[g]=a?u[g]:f[g],b[v]=i?u[v]:f[g],m++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){a.x=t?f.x:u.x,a.y=e?f.y:u.y,a.z=n?f.z:u.z,this.closestPointToPoint(a,r);const i=a.distanceToSquared(r);if(i<d&&(d=i,s&&s.copy(r),l&&l.copy(a),i<c))return Math.sqrt(i)}for(let t=0;t<12;t++){const i=e[t];for(let t=0;t<12;t++){const e=n[t];Jt(i,e,r,a);const o=r.distanceToSquared(a);if(o<d&&(d=o,s&&s.copy(r),l&&l.copy(a),o<c))return Math.sqrt(o)}}return Math.sqrt(d)}}();const ae=new x,ie=new x,oe=new x,se=new d,le=new d,ce=new d,ue=new x;function fe(t,e,n,r,a,i,o){ae.fromBufferAttribute(e,r),ie.fromBufferAttribute(e,a),oe.fromBufferAttribute(e,i);const s=function(t,e,n,r,a,i){let o;return o=i===S?t.intersectTriangle(r,n,e,!0,a):t.intersectTriangle(e,n,r,i!==I,a),null===o?null:{distance:t.origin.distanceTo(a),point:a.clone()}}(t,ae,ie,oe,ue,o);if(s){n&&(se.fromBufferAttribute(n,r),le.fromBufferAttribute(n,a),ce.fromBufferAttribute(n,i),s.uv=w.getUV(ue,ae,ie,oe,se,le,ce,new d));const t={a:r,b:a,c:i,normal:new x,materialIndex:0};w.getNormal(ae,ie,oe,t.normal),s.face=t,s.faceIndex=r}return s}function he(t,e,n,r,a){const i=3*r,o=t.index.getX(i),s=t.index.getX(i+1),l=t.index.getX(i+2),c=fe(n,t.attributes.position,t.attributes.uv,o,s,l,e);return c?(c.faceIndex=r,a&&a.push(c),c):null}function de(t,e,n,r){const a=t.a,i=t.b,o=t.c;let s=e,l=e+1,c=e+2;n&&(s=n.getX(e),l=n.getX(e+1),c=n.getX(e+2)),a.x=r.getX(s),a.y=r.getY(s),a.z=r.getZ(s),i.x=r.getX(l),i.y=r.getY(l),i.z=r.getZ(l),o.x=r.getX(c),o.y=r.getY(c),o.z=r.getZ(c)}function me(t,e,n,r,a,i,o){const s=n.index,l=n.attributes.position;for(let c=t,u=e+t;c<u;c++)if(de(o,3*c,s,l),o.needsUpdate=!0,r(o,c,a,i))return!0;return!1}class pe{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function ge(t,e){return 65535===e[t+15]}function ve(t,e){return e[t+6]}function xe(t,e){return e[t+14]}function ye(t){return t+8}function be(t,e){return e[t+6]}function we(t,e){return e[t+7]}const Te=new M,Re=new x,Se=["x","y","z"];function Ie(t,e,n,r,a){let i=2*t,o=_e,s=Ee,l=Be;if(ge(i,s)){!function(t,e,n,r,a,i){for(let o=r,s=r+a;o<s;o++)he(t,e,n,o,i)}(e,n,r,ve(t,l),xe(i,s),a)}else{const i=ye(t);Ae(i,o,r,Re)&&Ie(i,e,n,r,a);const s=be(t,l);Ae(s,o,r,Re)&&Ie(s,e,n,r,a)}}function Me(t,e,n,r){let a=2*t,i=_e,o=Ee,s=Be;if(ge(a,o)){return function(t,e,n,r,a){let i=1/0,o=null;for(let s=r,l=r+a;s<l;s++){const r=he(t,e,n,s);r&&r.distance<i&&(o=r,i=r.distance)}return o}(e,n,r,ve(t,s),xe(a,o))}{const a=we(t,s),o=Se[a],l=r.direction[o]>=0;let c,u;l?(c=ye(t),u=be(t,s)):(c=be(t,s),u=ye(t));const f=Ae(c,i,r,Re)?Me(c,e,n,r):null;if(f){const t=f.point[o];if(l?t<=i[u+a]:t>=i[u+a+3])return f}const h=Ae(u,i,r,Re)?Me(u,e,n,r):null;return f&&h?f.distance<=h.distance?f:h:f||h||null}}const Pe=function(){let t,e;const n=[],r=new pe((()=>new M));return function(...i){t=r.getPrimitive(),e=r.getPrimitive(),n.push(t,e);const o=a(...i);r.releasePrimitive(t),r.releasePrimitive(e),n.pop(),n.pop();const s=n.length;return s>0&&(e=n[s-1],t=n[s-2]),o};function a(n,r,i,o,s=null,l=0,c=0){function u(t){let e=2*t,n=Ee,r=Be;for(;!ge(e,n);)e=2*(t=ye(t));return ve(t,r)}function f(t){let e=2*t,n=Ee,r=Be;for(;!ge(e,n);)e=2*(t=be(t,r));return ve(t,r)+xe(e,n)}let h=2*n,d=_e,m=Ee,p=Be;if(ge(h,m)){const e=ve(n,p),r=xe(h,m);return kt(n,d,t),o(e,r,!1,c,l+n,t)}{const h=ye(n),g=be(n,p);let v,x,y,b,w=h,T=g;if(s&&(y=t,b=e,kt(w,d,y),kt(T,d,b),v=s(y),x=s(b),x<v)){w=g,T=h;const t=v;v=x,x=t,y=b}y||(y=t,kt(w,d,y));const R=i(y,ge(2*w,m),v,c+1,l+w);let S;if(2===R){const t=u(w);S=o(t,f(w)-t,!0,c+1,l+w,y)}else S=R&&a(w,r,i,o,s,l,c+1);if(S)return!0;b=e,kt(T,d,b);const I=i(b,ge(2*T,m),x,c+1,l+T);let M;if(2===I){const t=u(T);M=o(t,f(T)-t,!0,c+1,l+T,b)}else M=I&&a(T,r,i,o,s,l,c+1);return!!M}}}(),Fe=function(){const t=new ne,e=new ne,n=new R,r=new re,a=new re;return function i(o,s,l,c,u=null){let f=2*o,h=_e,d=Ee,m=Be;null===u&&(l.boundingBox||l.computeBoundingBox(),r.set(l.boundingBox.min,l.boundingBox.max,c),u=r);if(!ge(f,d)){const t=o+8,e=m[o+6];kt(t,h,Te);if(u.intersectsBox(Te)&&i(t,s,l,c,u))return!0;kt(e,h,Te);return!!(u.intersectsBox(Te)&&i(e,s,l,c,u))}{const r=s,i=r.index,u=r.attributes.position,p=l.index,g=l.attributes.position,v=ve(o,m),x=xe(f,d);if(n.copy(c).invert(),l.boundsTree){kt(o,h,a),a.matrix.copy(n),a.needsUpdate=!0;return l.boundsTree.shapecast({intersectsBounds:t=>a.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(c),t.b.applyMatrix4(c),t.c.applyMatrix4(c),t.needsUpdate=!0;for(let n=3*v,r=3*(x+v);n<r;n+=3)if(de(e,n,i,u),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}})}for(let a=3*v,o=x+3*v;a<o;a+=3){de(t,a,i,u),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,r=p.count;n<r;n+=3)if(de(e,n,p,g),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function Ae(t,e,n,r){return kt(t,e,Te),n.intersectBox(Te,r)}const De=[];let Ce,_e,Ee,Be;function ze(t){Ce&&De.push(Ce),Ce=t,_e=new Float32Array(t),Ee=new Uint16Array(t),Be=new Uint32Array(t)}function Oe(){Ce=null,_e=null,Ee=null,Be=null,De.length&&ze(De.pop())}const Ne=Symbol("skip tree generation"),He=new M,ke=new M,We=new R,Ue=new re,Le=new re,Ve=new x,qe=new x,Ge=new x,je=new x,Ye=new x,$e=new M,Xe=new pe((()=>new ne));class Qe{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),Qe.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,a=n.getIndex();let i;return i=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:a.array.slice()}:{roots:r,index:a.array},i}static deserialize(t,e,n={}){if("boolean"==typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),Qe.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n={setIndex:!0,...n};const{index:r,roots:a}=t,i=new Qe(e,{...n,[Ne]:!0});if(i._roots=a,n.setIndex){const n=e.getIndex();if(null===n){const n=new v(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return i}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:Dt,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Ne]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[Ne]||(this._roots=function(t,e){const n=Qt(t,e);let r,a,i;const o=[],s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<n.length;u++){const t=n[u];let e=l(t);const f=new s(zt*e);r=new Float32Array(f),a=new Uint32Array(f),i=new Uint16Array(f),c(0,t),o.push(f)}return o;function l(t){return t.count?1:1+l(t.left)+l(t.right)}function c(t,e){const n=t/4,o=t/2,s=!!e.count,l=e.boundingData;for(let a=0;a<6;a++)r[n+a]=l[a];if(s){const r=e.offset,s=e.count;return a[n+6]=r,i[o+14]=s,i[o+15]=Ot,t+zt}{const r=e.left,i=e.right,o=e.splitAxis;let s;if(s=c(t+zt,r),s/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return a[n+6]=s/4,s=c(s,i),a[n+7]=o,s}}}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new M))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,r=e.attributes.position;let a,i,o,s,l=0;const c=this._roots;for(let f=0,h=c.length;f<h;f++)a=c[f],i=new Uint32Array(a),o=new Uint16Array(a),s=new Float32Array(a),u(0,l),l+=a.byteLength;function u(e,a,l=!1){const c=2*e;if(o[c+15]===Ot){const t=i[e+6];let a=1/0,l=1/0,u=1/0,f=-1/0,h=-1/0,d=-1/0;for(let e=3*t,i=3*(t+o[c+14]);e<i;e++){const t=n[e],i=r.getX(t),o=r.getY(t),s=r.getZ(t);i<a&&(a=i),i>f&&(f=i),o<l&&(l=o),o>h&&(h=o),s<u&&(u=s),s>d&&(d=s)}return(s[e+0]!==a||s[e+1]!==l||s[e+2]!==u||s[e+3]!==f||s[e+4]!==h||s[e+5]!==d)&&(s[e+0]=a,s[e+1]=l,s[e+2]=u,s[e+3]=f,s[e+4]=h,s[e+5]=d,!0)}{const n=e+8,r=i[e+6],o=n+a,c=r+a;let f=l,h=!1,d=!1;t?f||(h=t.has(o),d=t.has(c),f=!h&&!d):(h=!0,d=!0);const m=f||d;let p=!1;(f||h)&&(p=u(n,a,f));let g=!1;m&&(g=u(r,a,f));const v=p||g;if(v)for(let t=0;t<3;t++){const a=n+t,i=r+t,o=s[a],l=s[a+3],c=s[i],u=s[i+3];s[e+t]=o<c?o:c,s[e+t+3]=l>u?l:u}return v}}}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),a=new Uint16Array(n);!function e(i,o=0){const s=2*i,l=a[s+15]===Ot;if(l){const e=r[i+6],c=a[s+14];t(o,l,new Float32Array(n,4*i,6),e,c)}else{const a=i+8,s=r[i+6],c=r[i+7];t(o,l,new Float32Array(n,4*i,6),c)||(e(a,o+1),e(s,o+1))}}(0)}raycast(t,e=P){const n=this._roots,r=this.geometry,a=[],i=e.isMaterial,o=Array.isArray(e),s=r.groups,l=i?e.side:e;for(let c=0,u=n.length;c<u;c++){const i=o?e[s[c].materialIndex].side:l,u=a.length;if(ze(n[c]),Ie(0,r,i,t,a),Oe(),o){const t=s[c].materialIndex;for(let e=u,n=a.length;e<n;e++)a[e].face.materialIndex=t}}return a}raycastFirst(t,e=P){const n=this._roots,r=this.geometry,a=e.isMaterial,i=Array.isArray(e);let o=null;const s=r.groups,l=a?e.side:e;for(let c=0,u=n.length;c<u;c++){const a=i?e[s[c].materialIndex].side:l;ze(n[c]);const u=Me(0,r,a,t);Oe(),null!=u&&(null==o||u.distance<o.distance)&&(o=u,i&&(u.face.materialIndex=s[c].materialIndex))}return o}intersectsGeometry(t,e){const n=this.geometry;let r=!1;for(const a of this._roots)if(ze(a),r=Fe(0,n,t,e),Oe(),r)break;return r}shapecast(t,e,n){const r=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,n,r,a)=>{const i=3*n;return t(e,i,i+1,i+2,r,a)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const a=Xe.getPrimitive();let{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:s,intersectsTriangle:l}=t;if(s&&l){const t=s;s=(e,n,i,o,s)=>!!t(e,n,i,o,s)||me(e,n,r,l,i,o,a)}else s||(s=l?(t,e,n,i)=>me(t,e,r,l,n,i,a):(t,e,n)=>n);let c=!1,u=0;for(const f of this._roots){if(ze(f),c=Pe(0,r,o,s,i,u),Oe(),c)break;u+=f.byteLength}return Xe.releasePrimitive(a),c}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:a}=n;const i=this.geometry.index,o=this.geometry.attributes.position,s=t.geometry.index,l=t.geometry.attributes.position;We.copy(e).invert();const c=Xe.getPrimitive(),u=Xe.getPrimitive();if(a){let t=function(t,n,r,f,h,d,m,p){for(let g=r,v=r+f;g<v;g++){de(u,3*g,s,l),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(de(c,3*e,i,o),c.needsUpdate=!0,a(c,u,e,g,h,d,m,p))return!0}return!1};if(r){const e=r;r=function(n,r,a,i,o,s,l,c){return!!e(n,r,a,i,o,s,l,c)||t(n,r,a,i,o,s,l,c)}}else r=t}t.getBoundingBox(ke),ke.applyMatrix4(e);const f=this.shapecast({intersectsBounds:t=>ke.intersectsBox(t),intersectsRange:(e,n,a,i,o,s)=>(He.copy(s),He.applyMatrix4(We),t.shapecast({intersectsBounds:t=>He.intersectsBox(t),intersectsRange:(t,a,s,l,c)=>r(e,n,t,a,i,o,l,c)}))});return Xe.releasePrimitive(c),Xe.releasePrimitive(u),f}intersectsBox(t,e){return Ue.set(t.min,t.max,e),Ue.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Ue.intersectsBox(t),intersectsTriangle:t=>Ue.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},a=0,i=1/0){t.boundingBox||t.computeBoundingBox(),Ue.set(t.boundingBox.min,t.boundingBox.max,e),Ue.needsUpdate=!0;const o=this.geometry,s=o.attributes.position,l=o.index,c=t.attributes.position,u=t.index,f=Xe.getPrimitive(),h=Xe.getPrimitive();let d=qe,m=Ge,p=null,g=null;r&&(p=je,g=Ye);let v=1/0,x=null,y=null;return We.copy(e).invert(),Le.matrix.copy(We),this.shapecast({boundsTraverseOrder:t=>Ue.distanceToBox(t),intersectsBounds:(t,e,n)=>n<v&&n<i&&(e&&(Le.min.copy(t.min),Le.max.copy(t.max),Le.needsUpdate=!0),!0),intersectsRange:(n,r)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>Le.distanceToBox(t),intersectsBounds:(t,e,n)=>n<v&&n<i,intersectsRange:(t,i)=>{for(let o=3*t,b=3*(t+i);o<b;o+=3){de(h,o,u,c),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let t=3*n,e=3*(n+r);t<e;t+=3){de(f,t,l,s),f.needsUpdate=!0;const e=f.distanceToTriangle(h,d,p);if(e<v&&(m.copy(d),g&&g.copy(p),v=e,x=t/3,y=o/3),e<a)return!0}}}});for(let t=0,i=u?u.count:c.count;t<i;t+=3){de(h,t,u,c),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let e=3*n,i=3*(n+r);e<i;e+=3){de(f,e,l,s),f.needsUpdate=!0;const n=f.distanceToTriangle(h,d,p);if(n<v&&(m.copy(d),g&&g.copy(p),v=n,x=e/3,y=t/3),n<a)return!0}}}}),Xe.releasePrimitive(f),Xe.releasePrimitive(h),v===1/0?null:(n.point?n.point.copy(m):n.point=m.clone(),n.distance=v,n.faceIndex=x,r&&(r.point?r.point.copy(g):r.point=g.clone(),r.point.applyMatrix4(We),m.applyMatrix4(We),r.distance=m.sub(r.point).length(),r.faceIndex=y),n)}closestPointToPoint(t,e={},n=0,r=1/0){const a=n*n,i=r*r;let o=1/0,s=null;if(this.shapecast({boundsTraverseOrder:e=>(Ve.copy(t).clamp(e.min,e.max),Ve.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<o&&n<i,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,Ve);const r=t.distanceToSquared(Ve);return r<o&&(qe.copy(Ve),o=r,s=n),r<a}}),o===1/0)return null;const l=Math.sqrt(o);return e.point?e.point.copy(qe):e.point=qe.clone(),e.distance=l,e.faceIndex=s,e}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{kt(0,new Float32Array(e),$e),t.union($e)})),t}}function Ze(t){switch(t){case 1:return k;case 2:return H;case 3:case 4:return z}}class Ke extends A{constructor(){super(),this.minFilter=h,this.magFilter=h,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(t){const e=this.overrideItemSize,n=t.itemSize,r=t.count;if(null!==e){if(n*r%e!=0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");t.itemSize=e,t.count=r*n/e}const a=t.itemSize,i=t.count,o=t.normalized,s=t.array.constructor,l=s.BYTES_PER_ELEMENT;let c,h,d,m,p=this._forcedType,g=a;if(null===p)switch(s){case Float32Array:p=u;break;case Uint8Array:case Uint16Array:case Uint32Array:p=F;break;case Int8Array:case Int16Array:case Int32Array:p=D}let v=function(t){switch(t){case 1:return"R";case 2:return"RG";case 3:case 4:return"RGBA"}throw new Error}(a);switch(p){case u:d=1,h=function(t){switch(t){case 1:return N;case 2:return O;case 3:case 4:return f}}(a),o&&1===l?(m=s,v+="8",s===Uint8Array?c=C:(c=E,v+="_SNORM")):(m=Float32Array,v+="32F",c=u);break;case D:v+=8*l+"I",d=o?Math.pow(2,8*s.BYTES_PER_ELEMENT-1):1,h=Ze(a),1===l?(m=Int8Array,c=E):2===l?(m=Int16Array,c=B):(m=Int32Array,c=D);break;case F:v+=8*l+"UI",d=o?Math.pow(2,8*s.BYTES_PER_ELEMENT-1):1,h=Ze(a),1===l?(m=Uint8Array,c=C):2===l?(m=Uint16Array,c=_):(m=Uint32Array,c=F)}3!==g||h!==f&&h!==z||(g=4);const x=Math.ceil(Math.sqrt(i)),y=new m(g*x*x),b=t.normalized;t.normalized=!1;for(let u=0;u<i;u++){const e=g*u;y[e]=t.getX(u)/d,a>=2&&(y[e+1]=t.getY(u)/d),a>=3&&(y[e+2]=t.getZ(u)/d,4===g&&(y[e+3]=1)),a>=4&&(y[e+3]=t.getW(u)/d)}t.normalized=b,this.internalFormat=v,this.format=h,this.type=c,this.image.width=x,this.image.height=x,this.image.data=y,this.needsUpdate=!0,this.dispose(),t.itemSize=n,t.count=r}}class Je extends Ke{constructor(){super(),this._forcedType=F}}class tn extends Ke{constructor(){super(),this._forcedType=u}}class en{constructor(){this.autoDispose=!0,this.index=new Je,this.position=new tn,this.bvhBounds=new A,this.bvhContents=new A,this.index.overrideItemSize=3}updateFrom(t){const{geometry:e}=t;!function(t,e,n){const r=t._roots;if(1!==r.length)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const a=r[0],i=new Uint16Array(a),o=new Uint32Array(a),s=new Float32Array(a),l=a.byteLength/zt,c=2*Math.ceil(Math.sqrt(l/2)),d=new Float32Array(4*c*c),m=Math.ceil(Math.sqrt(l)),p=new Uint32Array(2*m*m);for(let u=0;u<l;u++){const t=u*zt/4,e=2*t,n=t;for(let r=0;r<3;r++)d[8*u+0+r]=s[n+0+r],d[8*u+4+r]=s[n+3+r];if(ge(e,i)){const n=xe(e,i),r=ve(t,o),a=4294901760|n;p[2*u+0]=a,p[2*u+1]=r}else{const e=4*be(t,o)/zt,n=we(t,o);p[2*u+0]=n,p[2*u+1]=e}}e.image.data=d,e.image.width=c,e.image.height=c,e.format=f,e.type=u,e.internalFormat="RGBA32F",e.minFilter=h,e.magFilter=h,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose(),n.image.data=p,n.image.width=m,n.image.height=m,n.format=H,n.type=F,n.internalFormat="RG32UI",n.minFilter=h,n.magFilter=h,n.generateMipmaps=!1,n.needsUpdate=!0,n.dispose()}(t,this.bvhBounds,this.bvhContents),this.index.updateFrom(e.index),this.position.updateFrom(e.attributes.position)}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:r}=this;t&&t.dispose(),e&&e.dispose(),n&&n.dispose(),r&&r.dispose()}}const nn=new x,rn=new x,an=new x,on=new m,sn=new x,ln=new x,cn=new m,un=new m,fn=new R,hn=new R;function dn(t,e){if(!t&&!e)return;const n=t.count===e.count,r=t.normalized===e.normalized,a=t.array.constructor===e.array.constructor,i=t.itemSize===e.itemSize;if(!(n&&r&&a&&i))throw new Error}function mn(t,e=null){const n=t.array.constructor,r=t.normalized,a=t.itemSize,i=null===e?t.count:e;return new v(new n(a*i),a,r)}function pn(t,e,n=0){if(t.isInterleavedBufferAttribute){const r=t.itemSize;for(let a=0,i=t.count;a<i;a++){const i=a+n;e.setX(i,t.getX(a)),r>=2&&e.setY(i,t.getY(a)),r>=3&&e.setZ(i,t.getZ(a)),r>=4&&e.setW(i,t.getW(a))}}else{const r=e.array,a=r.constructor,i=r.BYTES_PER_ELEMENT*t.itemSize*n;new a(r.buffer,i,t.array.length).set(t.array)}}function gn(t,e,n){const r=t.elements,a=e.elements;for(let i=0,o=a.length;i<o;i++)r[i]+=a[i]*n}function vn(t,e,n){const r=t.skeleton,a=t.geometry,i=r.bones,o=r.boneInverses;cn.fromBufferAttribute(a.attributes.skinIndex,e),un.fromBufferAttribute(a.attributes.skinWeight,e),fn.elements.fill(0);for(let s=0;s<4;s++){const t=un.getComponent(s);if(0!==t){const e=cn.getComponent(s);hn.multiplyMatrices(i[e].matrixWorld,o[e]),gn(fn,hn,t)}}return fn.multiply(t.bindMatrix).premultiply(t.bindMatrixInverse),n.transformDirection(fn),n}function xn(t,e,n,r,a){sn.set(0,0,0);for(let i=0,o=t.length;i<o;i++){const o=e[i],s=t[i];0!==o&&(ln.fromBufferAttribute(s,r),n?sn.addScaledVector(ln,o):sn.addScaledVector(ln.sub(a),o))}a.add(sn)}class yn{constructor(t){this.matrixWorld=new R,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=t,this.update()}update(){const t=this.mesh,e=t.geometry,n=t.skeleton,r=(e.index?e.index.count:e.attributes.position.count)/3;if(this.matrixWorld.copy(t.matrixWorld),this.geometryHash=e.attributes.position.version,this.primitiveCount=r,n){n.boneTexture||n.computeBoneTexture(),n.update();const t=n.boneMatrices;this.boneMatrices&&this.boneMatrices.length===t.length?this.boneMatrices.set(t):this.boneMatrices=t.slice()}else this.boneMatrices=null}didChange(){const t=this.mesh,e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===e.attributes.position.version&&function(t,e){if(null===t||null===e)return t===e;if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n)}}class bn{constructor(t){Array.isArray(t)||(t=[t]);const e=[];t.forEach((t=>{t.traverseVisible((t=>{t.isMesh&&e.push(t)}))})),this.meshes=e,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(e.length).fill().map((()=>new a)),this._diffMap=new WeakMap}getMaterials(){const t=[];return this.meshes.forEach((e=>{Array.isArray(e.material)?t.push(...e.material):t.push(e.material)})),t}generate(t=new a){let e=[];const{meshes:n,useGroups:r,_intermediateGeometry:i,_diffMap:o}=this;for(let a=0,s=n.length;a<s;a++){const t=n[a],r=i[a],s=o.get(t);!s||s.didChange(t)?(this._convertToStaticGeometry(t,r),e.push(!1),s?s.update():o.set(t,new yn(t))):e.push(!0)}!function(t,e={useGroups:!1,updateIndex:!1,skipAttributes:[]},n=new a){const r=null!==t[0].index,{useGroups:i=!1,updateIndex:o=!1,skipAttributes:s=[]}=e,l=new Set(Object.keys(t[0].attributes)),c={};let u=0;n.clearGroups();for(let a=0;a<t.length;++a){const e=t[a];let o=0;if(r!==(null!==e.index))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const t in e.attributes){if(!l.has(t))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.');void 0===c[t]&&(c[t]=[]),c[t].push(e.attributes[t]),o++}if(o!==l.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(i){let t;if(r)t=e.index.count;else{if(void 0===e.attributes.position)throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");t=e.attributes.position.count}n.addGroup(u,t,a),u+=t}}if(r){let e=!1;if(!n.index){let r=0;for(let e=0;e<t.length;++e)r+=t[e].index.count;n.setIndex(new v(new Uint32Array(r),1,!1)),e=!0}if(o||e){const e=n.index;let r=0,a=0;for(let n=0;n<t.length;++n){const i=t[n],o=i.index;if(!0!==s[n])for(let t=0;t<o.count;++t)e.setX(r,o.getX(t)+a),r++;a+=i.attributes.position.count}}}for(const a in c){const t=c[a];if(!(a in n.attributes)){let e=0;for(const n in t)e+=t[n].count;n.setAttribute(a,mn(c[a][0],e))}const e=n.attributes[a];let r=0;for(let n=0,a=t.length;n<a;n++){const a=t[n];!0!==s[n]&&pn(a,e,r),r+=a.count}}}(i,{useGroups:r,skipAttributes:e},t);for(const a in t.attributes)t.attributes[a].needsUpdate=!0;return t}_convertToStaticGeometry(t,e=new a){const n=t.geometry,r=this.applyWorldTransforms,i=this.attributes.includes("normal"),o=this.attributes.includes("tangent"),s=n.attributes,l=e.attributes;e.index||(e.index=n.index),l.position||e.setAttribute("position",mn(s.position)),i&&!l.normal&&s.normal&&e.setAttribute("normal",mn(s.normal)),o&&!l.tangent&&s.tangent&&e.setAttribute("tangent",mn(s.tangent)),dn(n.index,e.index),dn(s.position,l.position),i&&dn(s.normal,l.normal),o&&dn(s.tangent,l.tangent);const c=s.position,u=i?s.normal:null,f=o?s.tangent:null,h=n.morphAttributes.position,d=n.morphAttributes.normal,m=n.morphAttributes.tangent,p=n.morphTargetsRelative,g=t.morphTargetInfluences,v=new W;v.getNormalMatrix(t.matrixWorld);for(let a=0,x=s.position.count;a<x;a++)nn.fromBufferAttribute(c,a),u&&rn.fromBufferAttribute(u,a),f&&(on.fromBufferAttribute(f,a),an.fromBufferAttribute(f,a)),g&&(h&&xn(h,g,p,a,nn),d&&xn(d,g,p,a,rn),m&&xn(m,g,p,a,an)),t.isSkinnedMesh&&(t.boneTransform(a,nn),u&&vn(t,a,rn),f&&vn(t,a,an)),r&&nn.applyMatrix4(t.matrixWorld),l.position.setXYZ(a,nn.x,nn.y,nn.z),u&&(r&&rn.applyNormalMatrix(v),l.normal.setXYZ(a,rn.x,rn.y,rn.z)),f&&(r&&an.transformDirection(t.matrixWorld),l.tangent.setXYZW(a,an.x,an.y,an.z,on.w));for(const a in this.attributes){const t=this.attributes[a];"position"!==t&&"tangent"!==t&&"normal"!==t&&t in s&&(l[t]||e.setAttribute(t,mn(s[t])),dn(s[t],l[t]),pn(s[t],l[t]))}return e}}function wn(t,e,n){const r=t.index,a=t.attributes.position.count,i=r?r.count:a;let o,s=t.groups;0===s.length&&(s=[{count:i,start:0,materialIndex:0}]),o=n.length<=255?new Uint8Array(a):new Uint16Array(a);for(let l=0;l<s.length;l++){const t=s[l],a=t.start,c=t.count,u=Math.min(c,i-a),f=Array.isArray(e)?e[t.materialIndex]:e,h=n.indexOf(f);for(let e=0;e<u;e++){let t=a+e;r&&(t=r.getX(t)),o[t]=h}}return new v(o,1,!1)}function Tn(t,e){if(e)for(const n in t.attributes)e.includes(n)||t.deleteAttribute(n)}function Rn(t,e){const{attributes:n=[],normalMapRequired:r=!1}=e;if(!t.attributes.normal&&n&&n.includes("normal")&&t.computeVertexNormals(),!t.attributes.uv&&n&&n.includes("uv")){const e=t.attributes.position.count;t.setAttribute("uv",new v(new Float32Array(2*e),2,!1))}if(!t.attributes.tangent&&n&&n.includes("tangent"))if(r)null===t.index&&(t=dt(t)),t.computeTangents();else{const e=t.attributes.position.count;t.setAttribute("tangent",new v(new Float32Array(4*e),4,!1))}if(!t.attributes.color&&n&&n.includes("color")){const e=t.attributes.position.count,n=new Float32Array(4*e);n.fill(1),t.setAttribute("color",new v(n,4))}if(!t.index){const e=t.attributes.position.count,n=new Array(e);for(let t=0;t<e;t++)n[t]=t;t.setIndex(n)}}function Sn(t,e={}){e={attributes:null,cloneGeometry:!0,...e};const n=[],r=new Set;for(let o=0,s=t.length;o<s;o++){const e=t[o];!1!==e.visible&&(Array.isArray(e.material)?e.material.forEach((t=>r.add(t))):r.add(e.material))}const a=Array.from(r);for(let o=0,s=t.length;o<s;o++){const r=t[o];if(!1===r.visible)continue;r.updateMatrixWorld();const i=t[o].geometry,s=e.cloneGeometry?i.clone():i;s.applyMatrix4(r.matrixWorld),Rn(s,{attributes:e.attributes,normalMapRequired:!!r.material.normalMap}),Tn(s,e.attributes);const l=wn(s,r.material,a);s.setAttribute("materialIndex",l),n.push(s)}const i=new Set;a.forEach((t=>{for(const e in t){const n=t[e];n&&n.isTexture&&i.add(n)}}));return{geometry:ht(n,!1),materials:a,textures:Array.from(i)}}class In{prepScene(t){t=Array.isArray(t)?t:[t];const e=[],n=[];for(let r=0,a=t.length;r<a;r++)t[r].traverseVisible((t=>{if(t.isSkinnedMesh||t.isMesh&&t.morphTargetInfluences){const n=new bn(t);n.attributes=["position","color","normal","tangent","uv","uv2"],n.applyWorldTransforms=!1;const r=new o(n.generate(),t.material);r.matrixWorld.copy(t.matrixWorld),r.matrix.copy(t.matrixWorld),r.matrix.decompose(r.position,r.quaternion,r.scale),e.push(r)}else t.isMesh?e.push(t):(t.isRectAreaLight||t.isSpotLight||t.isDirectionalLight||t.isPointLight)&&n.push(t)}));return{...Sn(e,{attributes:["position","normal","tangent","uv","color"]}),lights:n}}generate(t,e={}){const{materials:n,textures:r,geometry:a,lights:i}=this.prepScene(t),o={strategy:_t,...e,maxLeafTris:1};return{scene:t,materials:n,textures:r,lights:i,bvh:new Qe(a,o)}}}class Mn extends U{set bokehSize(t){this.fStop=this.getFocalLength()/t}get bokehSize(){return this.getFocalLength()/this.fStop}constructor(...t){super(...t),this.fStop=1.4,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=25,this.anamorphicRatio=1}copy(t,e){return super.copy(t,e),this.fStop=t.fStop,this.apertureBlades=t.apertureBlades,this.apertureRotation=t.apertureRotation,this.focusDistance=t.focusDistance,this.anamorphicRatio=t.anamorphicRatio,this}}const Pn=new d,Fn=new d,An=new L,Dn=new p;class Cn extends A{constructor(t,e){super(new Float32Array(t*e*4),t,e,f,u,V,q,G,j,j),this.generationCallback=null}update(){this.dispose(),this.needsUpdate=!0;const{data:t,width:e,height:n}=this.image;for(let r=0;r<e;r++)for(let a=0;a<n;a++){Fn.set(e,n),Pn.set(r/e,a/n),Pn.x-=.5,Pn.y=1-Pn.y,An.theta=2*Pn.x*Math.PI,An.phi=Pn.y*Math.PI,An.radius=1,this.generationCallback(An,Pn,Fn,Dn);const i=4*(a*e+r);t[i+0]=Dn.r,t[i+1]=Dn.g,t[i+2]=Dn.b,t[i+3]=1}}copy(t){return super.copy(t),this.generationCallback=t.generationCallback,this}}const _n=new x;class En extends Cn{constructor(t=512){super(t,t),this.topColor=(new p).set(16777215),this.bottomColor=(new p).set(0),this.exponent=2,this.generationCallback=(t,e,n,r)=>{_n.setFromSpherical(t);const a=.5*_n.y+.5;r.lerpColors(this.bottomColor,this.topColor,a**this.exponent)}}copy(t){return super.copy(t),this.topColor.copy(t.topColor),this.bottomColor.copy(t.bottomColor),this}}function Bn(t){return`${t.source.uuid}:${t.encoding}`}function zn(t){const e=new Set,n=[];for(let r=0,a=t.length;r<a;r++){const a=t[r],i=Bn(a);e.has(i)||(e.add(i),n.push(a))}return n}const On=180;class Nn{constructor(){this._features={}}isUsed(t){return t in this._features}setUsed(t,e=!0){!1===e?delete this._features[t]:this._features[t]=!0}reset(){this._features={}}}class Hn extends A{constructor(){super(new Float32Array(4),1,1),this.format=f,this.type=u,this.wrapS=G,this.wrapT=G,this.generateMipmaps=!1,this.threeCompatibilityTransforms=!1,this.features=new Nn}setCastShadow(t,e){this.image.data[t*On+57]=e?0:1}getCastShadow(t){const e=this.image.data;return!Boolean(e[t*On+57])}setMatte(t,e){this.image.data[t*On+56]=e?1:0}getMatte(t){const e=this.image.data;return Boolean(e[t*On+56])}updateFrom(t,e){function n(t,e,n=-1){if(e in t&&t[e]){const n=Bn(t[e]);return h[n]}return n}function r(t,e,n){return e in t?t[e]:n}function a(t,e,n,r){let a;if(a=l?function(t){return t.map||t.specularMap||t.displacementMap||t.normalMap||t.bumpMap||t.roughnessMap||t.metalnessMap||t.alphaMap||t.emissiveMap||t.clearcoatMap||t.clearcoatNormalMap||t.clearcoatRoughnessMap||t.iridescenceMap||t.iridescenceThicknessMap||t.specularIntensityMap||t.specularColorMap||t.transmissionMap||t.thicknessMap||t.sheenColorMap||t.sheenRoughnessMap||null}(t):t[e]&&t[e].isTexture?t[e]:null,a){const t=a.matrix.elements;let e=0;n[r+e++]=t[0],n[r+e++]=t[3],n[r+e++]=t[6],e++,n[r+e++]=t[1],n[r+e++]=t[4],n[r+e++]=t[7],e++}return 8}let i=0;const o=45*t.length,s=Math.ceil(Math.sqrt(o)),{threeCompatibilityTransforms:l,image:c,features:u}=this,f=zn(e),h={};for(let m=0,p=f.length;m<p;m++)h[Bn(f[m])]=m;c.width!==s&&(this.dispose(),c.data=new Float32Array(s*s*4),c.width=s,c.height=s);const d=c.data;u.reset();for(let m=0,p=t.length;m<p;m++){const e=t[m];if(e.isFogVolumeMaterial){u.setUsed("FOG");for(let t=0;t<On;t++)d[i+t]=0;d[i+0+0]=e.color.r,d[i+0+1]=e.color.g,d[i+0+2]=e.color.b,d[i+8+3]=r(e,"emissiveIntensity",0),d[i+12+0]=e.emissive.r,d[i+12+1]=e.emissive.g,d[i+12+2]=e.emissive.b,d[i+52+1]=e.density,d[i+52+3]=0,d[i+56+2]=4,i+=On;continue}d[i++]=e.color.r,d[i++]=e.color.g,d[i++]=e.color.b,d[i++]=n(e,"map"),d[i++]=r(e,"metalness",0),d[i++]=n(e,"metalnessMap"),d[i++]=r(e,"roughness",0),d[i++]=n(e,"roughnessMap"),d[i++]=r(e,"ior",1.5),d[i++]=r(e,"transmission",0),d[i++]=n(e,"transmissionMap"),d[i++]=r(e,"emissiveIntensity",0),"emissive"in e?(d[i++]=e.emissive.r,d[i++]=e.emissive.g,d[i++]=e.emissive.b):(d[i++]=0,d[i++]=0,d[i++]=0),d[i++]=n(e,"emissiveMap"),d[i++]=n(e,"normalMap"),"normalScale"in e?(d[i++]=e.normalScale.x,d[i++]=e.normalScale.y):(d[i++]=1,d[i++]=1),d[i++]=r(e,"clearcoat",0),d[i++]=n(e,"clearcoatMap"),d[i++]=r(e,"clearcoatRoughness",0),d[i++]=n(e,"clearcoatRoughnessMap"),d[i++]=n(e,"clearcoatNormalMap"),"clearcoatNormalScale"in e?(d[i++]=e.clearcoatNormalScale.x,d[i++]=e.clearcoatNormalScale.y):(d[i++]=1,d[i++]=1),i++,d[i++]=r(e,"sheen",0),"sheenColor"in e?(d[i++]=e.sheenColor.r,d[i++]=e.sheenColor.g,d[i++]=e.sheenColor.b):(d[i++]=0,d[i++]=0,d[i++]=0),d[i++]=n(e,"sheenColorMap"),d[i++]=r(e,"sheenRoughness",0),d[i++]=n(e,"sheenRoughnessMap"),d[i++]=n(e,"iridescenceMap"),d[i++]=n(e,"iridescenceThicknessMap"),d[i++]=r(e,"iridescence",0),d[i++]=r(e,"iridescenceIOR",1.3);const o=r(e,"iridescenceThicknessRange",[100,400]);d[i++]=o[0],d[i++]=o[1],"specularColor"in e?(d[i++]=e.specularColor.r,d[i++]=e.specularColor.g,d[i++]=e.specularColor.b):(d[i++]=1,d[i++]=1,d[i++]=1),d[i++]=n(e,"specularColorMap"),d[i++]=r(e,"specularIntensity",1),d[i++]=n(e,"specularIntensityMap");const s=0===r(e,"thickness",0)&&r(e,"attenuationDistance",1/0)===1/0;if(d[i++]=Number(s),i++,"attenuationColor"in e?(d[i++]=e.attenuationColor.r,d[i++]=e.attenuationColor.g,d[i++]=e.attenuationColor.b):(d[i++]=1,d[i++]=1,d[i++]=1),d[i++]=r(e,"attenuationDistance",1/0),d[i++]=n(e,"alphaMap"),d[i++]=e.opacity,d[i++]=e.alphaTest,!s&&e.transmission>0)d[i++]=0;else switch(e.side){case P:d[i++]=1;break;case S:d[i++]=-1;break;case I:d[i++]=0}i++,i++,d[i++]=Number(e.vertexColors)|Number(e.flatShading)<<1,d[i++]=Number(e.transparent),i+=a(e,"map",d,i),i+=a(e,"metalnessMap",d,i),i+=a(e,"roughnessMap",d,i),i+=a(e,"transmissionMap",d,i),i+=a(e,"emissiveMap",d,i),i+=a(e,"normalMap",d,i),i+=a(e,"clearcoatMap",d,i),i+=a(e,"clearcoatNormalMap",d,i),i+=a(e,"clearcoatRoughnessMap",d,i),i+=a(e,"sheenColorMap",d,i),i+=a(e,"sheenRoughnessMap",d,i),i+=a(e,"iridescenceMap",d,i),i+=a(e,"iridescenceThicknessMap",d,i),i+=a(e,"specularColorMap",d,i),i+=a(e,"specularIntensityMap",d,i)}this.needsUpdate=!0}}const kn=new p;class Wn extends Y{constructor(...t){super(...t);const e=this.texture;e.format=f,e.type=C,e.minFilter=j,e.magFilter=j,e.wrapS=q,e.wrapT=q,e.setTextures=(...t)=>{this.setTextures(...t)};const n=new gt(new $);this.fsQuad=n}setTextures(t,e,n,r){const a=zn(r),i=t.getRenderTarget(),o=t.toneMapping,s=t.getClearAlpha();t.getClearColor(kn);const l=a.length||1;this.setSize(e,n,l),t.setClearColor(0,0),t.toneMapping=X;const c=this.fsQuad;for(let u=0,f=l;u<f;u++){const e=a[u];e&&(e.matrixAutoUpdate=!1,e.matrix.identity(),c.material.map=e,c.material.transparent=!0,t.setRenderTarget(this,u),c.render(t),e.updateMatrix(),e.matrixAutoUpdate=!0)}c.material.map=null,t.setClearColor(kn,s),t.setRenderTarget(i),t.toneMapping=o}dispose(){super.dispose(),this.fsQuad.dispose()}}function Un(t,e,n=0,r=t.length){let a=n,i=n+r-1;for(;a<i;){const n=a+i>>1;t[n]<e?a=n+1:i=n}return a-n}function Ln(t,e,n){return.2126*t+.7152*e+.0722*n}class Vn{constructor(){const t=new A(new Float32Array([1,1,1,1]),1,1);t.type=u,t.format=f,t.minFilter=j,t.magFilter=j,t.wrapS=q,t.wrapT=q,t.generateMipmaps=!1,t.needsUpdate=!0;const e=new A(new Float32Array([0,1]),1,2);e.type=u,e.format=N,e.minFilter=j,e.magFilter=j,e.generateMipmaps=!1,e.needsUpdate=!0;const n=new A(new Float32Array([0,0,1,1]),2,2);n.type=u,n.format=N,n.minFilter=j,n.magFilter=j,n.generateMipmaps=!1,n.needsUpdate=!0,this.map=t,this.marginalWeights=e,this.conditionalWeights=n,this.totalSum=1}dispose(){this.marginalWeights.dispose(),this.conditionalWeights.dispose(),this.map.dispose()}updateFrom(t){const e=function(t){const e=t.clone();e.source=new Q({...e.image});const{width:n,height:r,data:a}=e.image;let i=a;if(e.type===Z){i=new Float32Array(a.length);for(const t in a)i[t]=K.fromHalfFloat(a[t]);e.image.data=i,e.type=u}if(e.flipY){const t=i;i=i.slice();for(let e=0;e<r;e++)for(let a=0;a<n;a++){const o=4*(e*n+a),s=4*((r-e-1)*n+a);i[s+0]=t[o+0],i[s+1]=t[o+1],i[s+2]=t[o+2],i[s+3]=t[o+3]}e.flipY=!1,e.image.data=i}return e}(t);e.wrapS=q,e.wrapT=q;const{width:n,height:r,data:a}=e.image,i=new Float32Array(n*r),o=new Float32Array(n*r),s=new Float32Array(r),l=new Float32Array(r);let c=0,f=0;for(let u=0;u<r;u++){let t=0;for(let e=0;e<n;e++){const r=u*n+e,s=Ln(a[4*r+0],a[4*r+1],a[4*r+2]);t+=s,c+=s,i[r]=s,o[r]=t}if(0!==t)for(let e=u*n,r=u*n+n;e<r;e++)i[e]/=t,o[e]/=t;f+=t,s[u]=t,l[u]=f}if(0!==f)for(let u=0,g=s.length;u<g;u++)s[u]/=f,l[u]/=f;const h=new Float32Array(r),d=new Float32Array(n*r);for(let u=0;u<r;u++){const t=Un(l,(u+1)/r);h[u]=(t+.5)/r}for(let u=0;u<r;u++)for(let t=0;t<n;t++){const e=u*n+t,r=Un(o,(t+1)/n,u*n,n);d[e]=(r+.5)/n}this.dispose();const{marginalWeights:m,conditionalWeights:p}=this;m.image={width:r,height:1,data:h},m.needsUpdate=!0,p.image={width:n,height:r,data:d},p.needsUpdate=!0,this.totalSum=c,this.map=e}}class qn{constructor(){this.bokehSize=0,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=10,this.anamorphicRatio=1}updateFrom(t){t instanceof Mn?(this.bokehSize=t.bokehSize,this.apertureBlades=t.apertureBlades,this.apertureRotation=t.apertureRotation,this.focusDistance=t.focusDistance,this.anamorphicRatio=t.anamorphicRatio):(this.bokehSize=0,this.apertureRotation=0,this.apertureBlades=0,this.focusDistance=10,this.anamorphicRatio=1)}}class Gn{constructor(){const t=new A(new Float32Array(4),1,1);t.format=f,t.type=u,t.wrapS=G,t.wrapT=G,t.generateMipmaps=!1,this.tex=t,this.count=0}updateFrom(t,e=[]){const n=this.tex,r=Math.max(6*t.length,1),a=Math.ceil(Math.sqrt(r));n.image.width!==a&&(n.dispose(),n.image.data=new Float32Array(a*a*4),n.image.width=a,n.image.height=a);const i=n.image.data,o=new x,s=new x,l=new R,c=new J,u=new x,f=new x,h=new x;for(let d=0,m=t.length;d<m;d++){const n=t[d],r=6*d*4;let a=0;n.getWorldPosition(s),i[r+a++]=s.x,i[r+a++]=s.y,i[r+a++]=s.z;let m=0;if(n.isRectAreaLight&&n.isCircular?m=1:n.isSpotLight?m=2:n.isDirectionalLight?m=3:n.isPointLight&&(m=4),i[r+a++]=m,i[r+a++]=n.color.r,i[r+a++]=n.color.g,i[r+a++]=n.color.b,i[r+a++]=n.intensity,n.getWorldQuaternion(c),n.isRectAreaLight)o.set(n.width,0,0).applyQuaternion(c),i[r+a++]=o.x,i[r+a++]=o.y,i[r+a++]=o.z,a++,s.set(0,n.height,0).applyQuaternion(c),i[r+a++]=s.x,i[r+a++]=s.y,i[r+a++]=s.z,i[r+a++]=o.cross(s).length()*(n.isCircular?Math.PI/4:1);else if(n.isSpotLight){const t=n.radius;u.setFromMatrixPosition(n.matrixWorld),f.setFromMatrixPosition(n.target.matrixWorld),l.lookAt(u,f,h),c.setFromRotationMatrix(l),o.set(1,0,0).applyQuaternion(c),i[r+a++]=o.x,i[r+a++]=o.y,i[r+a++]=o.z,a++,s.set(0,1,0).applyQuaternion(c),i[r+a++]=s.x,i[r+a++]=s.y,i[r+a++]=s.z,i[r+a++]=Math.PI*t*t,i[r+a++]=t,i[r+a++]=n.shadow.camera.near,i[r+a++]=n.decay,i[r+a++]=n.distance,i[r+a++]=Math.cos(n.angle),i[r+a++]=Math.cos(n.angle*(1-n.penumbra)),i[r+a++]=e.indexOf(n.iesTexture)}else if(n.isPointLight){const t=o.setFromMatrixPosition(n.matrixWorld);i[r+a++]=t.x,i[r+a++]=t.y,i[r+a++]=t.z,a++,a+=4,a+=2,i[r+a++]=n.decay,i[r+a++]=n.distance}else if(n.isDirectionalLight){const t=o.setFromMatrixPosition(n.matrixWorld),e=s.setFromMatrixPosition(n.target.matrixWorld);f.subVectors(t,e).normalize(),i[r+a++]=f.x,i[r+a++]=f.y,i[r+a++]=f.z}}n.needsUpdate=!0,this.count=t.length}}function jn(t){const e=this,n=t.split("\n");let r,a=0;function i(t){return(t=(t=(t=t.trim()).replace(/,/g," ")).replace(/\s\s+/g," ")).split(" ")}function o(t,e){for(;;){const r=i(n[a++]);for(let t=0;t<r.length;++t)e.push(Number(r[t]));if(e.length===t)break}}for(e.verAngles=[],e.horAngles=[],e.candelaValues=[],e.tiltData={},e.tiltData.angles=[],e.tiltData.mulFactors=[];r=n[a++],!r.includes("TILT"););r.includes("NONE")||r.includes("INCLUDE")&&function(){let t=n[a++],r=i(t);e.tiltData.lampToLumGeometry=Number(r[0]),t=n[a++],r=i(t),e.tiltData.numAngles=Number(r[0]),o(e.tiltData.numAngles,e.tiltData.angles),o(e.tiltData.numAngles,e.tiltData.mulFactors)}(),function(){const t=[];o(10,t),e.count=Number(t[0]),e.lumens=Number(t[1]),e.multiplier=Number(t[2]),e.numVerAngles=Number(t[3]),e.numHorAngles=Number(t[4]),e.gonioType=Number(t[5]),e.units=Number(t[6]),e.width=Number(t[7]),e.length=Number(t[8]),e.height=Number(t[9])}(),function(){const t=[];o(3,t),e.ballFactor=Number(t[0]),e.blpFactor=Number(t[1]),e.inputWatts=Number(t[2])}();for(let l=0;l<e.numHorAngles;++l)e.candelaValues.push([]);o(e.numVerAngles,e.verAngles),o(e.numHorAngles,e.horAngles);for(let l=0;l<e.numHorAngles;++l)o(e.numVerAngles,e.candelaValues[l]);for(let l=0;l<e.numHorAngles;++l)for(let t=0;t<e.numVerAngles;++t)e.candelaValues[l][t]*=e.candelaValues[l][t]*e.multiplier*e.ballFactor*e.blpFactor;let s=-1;for(let l=0;l<e.numHorAngles;++l)for(let t=0;t<e.numVerAngles;++t){const n=e.candelaValues[l][t];s=s<n?n:s}if(s>0)for(let l=0;l<e.numHorAngles;++l)for(let t=0;t<e.numVerAngles;++t)e.candelaValues[l][t]/=s}class Yn extends tt{_getIESValues(t){const e=new Float32Array(64800);function n(e,n){let r=0,a=0,i=0,o=0,s=0,l=0;for(let g=0;g<t.numHorAngles-1;++g)if(n<t.horAngles[g+1]||g==t.numHorAngles-2){a=g,i=t.horAngles[g],o=t.horAngles[g+1];break}for(let g=0;g<t.numVerAngles-1;++g)if(e<t.verAngles[g+1]||g==t.numVerAngles-2){r=g,s=t.verAngles[g],l=t.verAngles[g+1];break}const c=o-i,u=l-s;if(0===u)return 0;const f=0===c?0:(n-i)/c,h=(e-s)/u,d=0===c?a:a+1,m=nt.lerp(t.candelaValues[a][r],t.candelaValues[d][r],f),p=nt.lerp(t.candelaValues[a][r+1],t.candelaValues[d][r+1],f);return nt.lerp(m,p,h)}const r=t.horAngles[0],a=t.horAngles[t.numHorAngles-1];for(let i=0;i<64800;++i){let t=i%360;const o=Math.floor(i/360);a-r!=0&&(t<r||t>=a)&&(t%=2*a,t>a&&(t=2*a-t)),e[i]=n(o,t)}return e}load(t,e,n,r){const a=new et(this.manager);a.setResponseType("text"),a.setCrossOrigin(this.crossOrigin),a.setWithCredentials(this.withCredentials),a.setPath(this.path),a.setRequestHeader(this.requestHeader);const i=new A(null,360,180,N,u);return i.minFilter=j,i.magFilter=j,a.load(t,(t=>{const n=new jn(t);i.image.data=this._getIESValues(n),i.needsUpdate=!0,void 0!==e&&e(i)}),n,r),i}parse(t){const e=new jn(t),n=new A(null,360,180,N,u);return n.minFilter=j,n.magFilter=j,n.image.data=this._getIESValues(e),n.needsUpdate=!0,n}}const $n=new p;class Xn extends Y{constructor(...t){super(...t);const e=this.texture;e.format=f,e.type=u,e.minFilter=j,e.magFilter=j,e.wrapS=G,e.wrapT=G,e.generateMipmaps=!1,e.updateFrom=(...t)=>{this.updateFrom(...t)};const n=new gt(new $);this.fsQuad=n,this.iesLoader=new Yn}async updateFrom(t,e){const n=t.getRenderTarget(),r=t.toneMapping,a=t.getClearAlpha();t.getClearColor($n);const i=e.length||1;this.setSize(360,180,i),t.setClearColor(0,0),t.toneMapping=X;const o=this.fsQuad;for(let s=0,l=i;s<l;s++){const n=e[s];n&&(n.matrixAutoUpdate=!1,n.matrix.identity(),o.material.map=n,o.material.transparent=!0,t.setRenderTarget(this,s),o.render(t),n.updateMatrix(),n.matrixAutoUpdate=!0)}o.material.map=null,t.setClearColor($n,a),t.setRenderTarget(n),t.toneMapping=r,o.dispose()}dispose(){super.dispose(),this.fsQuad.dispose()}}class Qn extends vt{constructor(t){super({blending:l,transparent:!1,depthWrite:!1,depthTest:!1,defines:{USE_SLIDER:0},uniforms:{sigma:{value:5},threshold:{value:.03},kSigma:{value:1},map:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:"\n\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\t\t//  Copyright (c) 2018-2019 Michele Morrone\n\t\t\t\t//  All rights reserved.\n\t\t\t\t//\n\t\t\t\t//  https://michelemorrone.eu - https://BrutPitt.com\n\t\t\t\t//\n\t\t\t\t//  me@michelemorrone.eu - brutpitt@gmail.com\n\t\t\t\t//  twitter: @BrutPitt - github: BrutPitt\n\t\t\t\t//\n\t\t\t\t//  https://github.com/BrutPitt/glslSmartDeNoise/\n\t\t\t\t//\n\t\t\t\t//  This software is distributed under the terms of the BSD 2-Clause license\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tuniform float sigma;\n\t\t\t\tuniform float threshold;\n\t\t\t\tuniform float kSigma;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439\n\t\t\t\t#define INV_PI 0.31830988618379067153776752674503\n\n\t\t\t\t// Parameters:\n\t\t\t\t//\t sampler2D tex\t - sampler image / texture\n\t\t\t\t//\t vec2 uv\t\t   - actual fragment coord\n\t\t\t\t//\t float sigma  >  0 - sigma Standard Deviation\n\t\t\t\t//\t float kSigma >= 0 - sigma coefficient\n\t\t\t\t//\t\t kSigma * sigma  --\x3e  radius of the circular kernel\n\t\t\t\t//\t float threshold   - edge sharpening threshold\n\t\t\t\tvec4 smartDeNoise( sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold ) {\n\n\t\t\t\t\tfloat radius = round( kSigma * sigma );\n\t\t\t\t\tfloat radQ = radius * radius;\n\n\t\t\t\t\tfloat invSigmaQx2 = 0.5 / ( sigma * sigma );\n\t\t\t\t\tfloat invSigmaQx2PI = INV_PI * invSigmaQx2;\n\n\t\t\t\t\tfloat invThresholdSqx2 = 0.5 / ( threshold * threshold );\n\t\t\t\t\tfloat invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;\n\n\t\t\t\t\tvec4 centrPx = texture2D( tex, uv );\n\t\t\t\t\tcentrPx.rgb *= centrPx.a;\n\n\t\t\t\t\tfloat zBuff = 0.0;\n\t\t\t\t\tvec4 aBuff = vec4( 0.0 );\n\t\t\t\t\tvec2 size = vec2( textureSize( tex, 0 ) );\n\n\t\t\t\t\tvec2 d;\n\t\t\t\t\tfor ( d.x = - radius; d.x <= radius; d.x ++ ) {\n\n\t\t\t\t\t\tfloat pt = sqrt( radQ - d.x * d.x );\n\n\t\t\t\t\t\tfor ( d.y = - pt; d.y <= pt; d.y ++ ) {\n\n\t\t\t\t\t\t\tfloat blurFactor = exp( - dot( d, d ) * invSigmaQx2 ) * invSigmaQx2PI;\n\n\t\t\t\t\t\t\tvec4 walkPx = texture2D( tex, uv + d / size );\n\t\t\t\t\t\t\twalkPx.rgb *= walkPx.a;\n\n\t\t\t\t\t\t\tvec4 dC = walkPx - centrPx;\n\t\t\t\t\t\t\tfloat deltaFactor = exp( - dot( dC.rgba, dC.rgba ) * invThresholdSqx2 ) * invThresholdSqrt2PI * blurFactor;\n\n\t\t\t\t\t\t\tzBuff += deltaFactor;\n\t\t\t\t\t\t\taBuff += deltaFactor * walkPx;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn aBuff / zBuff;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = smartDeNoise( map, vec2( vUv.x, vUv.y ), sigma, kSigma, threshold );\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <encodings_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\n\t\t\t"}),this.setValues(t)}}function Zn(t,e,n,r,a){if(e>r)throw new Error;const i=t.length/e,o=8*t.constructor.BYTES_PER_ELEMENT;let s=1;switch(t.constructor){case Uint8Array:case Uint16Array:case Uint32Array:s=2**o-1;break;case Int8Array:case Int16Array:case Int32Array:s=2**(o-1)-1}for(let l=0;l<i;l++){const i=4*l,o=e*l;for(let l=0;l<r;l++)n[a+i+l]=e>=l+1?t[o+l]/s:0}}class Kn extends rt{constructor(){super(),this._textures=[],this.type=u,this.format=f,this.internalFormat="RGBA32F"}updateAttribute(t,e){const n=this._textures[t];n.updateFrom(e);const r=n.image,a=this.image;if(r.width!==a.width||r.height!==a.height)throw new Error("FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.");const{width:i,height:o,data:s}=a,l=i*o*4*t;let c=e.itemSize;3===c&&(c=4),Zn(n.image.data,c,s,4,l),this.dispose(),this.needsUpdate=!0}setAttributes(t){const e=t[0].count,n=t.length;for(let c=0,u=n;c<u;c++)if(t[c].count!==e)throw new Error("FloatAttributeTextureArray: All attributes must have the same item count.");const r=this._textures;for(;r.length<n;){const t=new tn;r.push(t)}for(;r.length>n;)r.pop();for(let c=0,u=n;c<u;c++)r[c].updateFrom(t[c]);const a=r[0].image,i=this.image;a.width===i.width&&a.height===i.height&&a.depth===n||(i.width=a.width,i.height=a.height,i.depth=n,i.data=new Float32Array(i.width*i.height*i.depth*4));const{data:o,width:s,height:l}=i;for(let c=0,u=n;c<u;c++){const e=r[c],n=s*l*4*c;let a=t[c].itemSize;3===a&&(a=4),Zn(e.image.data,a,o,4,n)}this.dispose(),this.needsUpdate=!0}}class Jn extends Kn{updateNormalAttribute(t){this.updateAttribute(0,t)}updateTangentAttribute(t){this.updateAttribute(1,t)}updateUvAttribute(t){this.updateAttribute(2,t)}updateColorAttribute(t){this.updateAttribute(3,t)}updateFrom(t,e,n,r){this.setAttributes([t,e,n,r])}}class tr extends vt{onBeforeRender(){this.setDefine("FEATURE_DOF",0===this.physicalCamera.bokehSize?0:1),this.setDefine("FEATURE_BACKGROUND_MAP",this.backgroundMap?1:0),this.setDefine("FEATURE_FOG",this.materials.features.isUsed("FOG")?1:0)}constructor(t){super({transparent:!0,depthWrite:!1,defines:{FEATURE_MIS:1,FEATURE_RUSSIAN_ROULETTE:1,FEATURE_DOF:1,FEATURE_BACKGROUND_MAP:0,FEATURE_FOG:1,CAMERA_TYPE:0,DEBUG_MODE:0,ATTR_NORMAL:0,ATTR_TANGENT:1,ATTR_UV:2,ATTR_COLOR:3},uniforms:{resolution:{value:new d},bounces:{value:10},transmissiveBounces:{value:10},physicalCamera:{value:new qn},bvh:{value:new en},attributesArray:{value:new Jn},materialIndexAttribute:{value:new Je},materials:{value:new Hn},textures:{value:(new Wn).texture},lights:{value:new Gn},iesProfiles:{value:(new Xn).texture},cameraWorldMatrix:{value:new R},invProjectionMatrix:{value:new R},backgroundBlur:{value:0},environmentIntensity:{value:1},environmentRotation:{value:new R},envMapInfo:{value:new Vn},backgroundMap:{value:null},seed:{value:0},opacity:{value:1},filterGlossyFactor:{value:0},backgroundAlpha:{value:1},sobolTexture:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\t\t\t\t#define INFINITY 1e20\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t// bvh intersection\n\t\t\t\t\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n\n\t\t\t\t\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\n// Raycasting\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\n\n\t\t\t\t// random\n\t\t\t\t\n\n\t// https://www.shadertoy.com/view/wltcRS\n\tuvec4 WHITE_NOISE_SEED;\n\n\tvoid rng_initialize( vec2 p, int frame ) {\n\n\t\t// white noise seed\n\t\tWHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\n\n\t}\n\n\t// https://www.pcg-random.org/\n\tvoid pcg4d( inout uvec4 v ) {\n\n\t\tv = v * 1664525u + 1013904223u;\n\t\tv.x += v.y * v.w;\n\t\tv.y += v.z * v.x;\n\t\tv.z += v.x * v.y;\n\t\tv.w += v.y * v.z;\n\t\tv = v ^ ( v >> 16u );\n\t\tv.x += v.y*v.w;\n\t\tv.y += v.z*v.x;\n\t\tv.z += v.x*v.y;\n\t\tv.w += v.y*v.z;\n\n\t}\n\n\t// returns [ 0, 1 ]\n\tfloat rand() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );\n\n\t}\n\n\tvec2 rand2() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);\n\n\t}\n\n\tvec3 rand3() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );\n\n\t}\n\n\tvec4 rand4() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );\n\n\t}\n\n\t\t\t\t${wt}\n\t\t\t\t${Tt}\n\n\t\t\t\t// common\n\t\t\t\t\n\n\t// add texel fetch functions for texture arrays\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\n\n\t\tuint width = uint( textureSize( tex, 0 ).x );\n\t\tuvec2 uv;\n\t\tuv.x = index % width;\n\t\tuv.y = index / width;\n\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\n\n\t}\n\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\n\n\t\treturn\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\n\n\t}\n\n\n\t\t\t\t\n\n\tbool totalInternalReflection( float cosTheta, float eta ) {\n\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\t\treturn eta * sinTheta > 1.0;\n\n\t}\n\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\n\tfloat schlickFresnel( float cosine, float f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\n\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat ni = eta;\n\t\tfloat nt = 1.0;\n\n\t\t// Check for total internal reflection\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\n\t\tif( sinThetaTSq >= 1.0 ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\n\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\n\n\t}\n\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\n\tfloat iorRatioToF0( float eta ) {\n\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\n\n\t}\n\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\n\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t\t\treturn f90;\n\n\t\t}\n\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\n\n\t}\n\n\tfloat evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\n\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\treturn schlickFresnel( cosTheta, f0 );\n\n\t}\n\n\t/*\n\t// https://schuttejoe.github.io/post/disneybsdf/\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\n\n\t\tfloat dotHV = dot( wo, wh );\n\t\tfloat dotHL = dot( wi, wh );\n\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\n\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\n\n\t}\n\t*/\n\n\t\t\t\t\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n\n\t\t\t\t\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n\n\t\t\t\t\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the rectangle on that same plane.\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, out float dist ) {\n\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = p - center;\n\n\t\t\t// check if p falls inside the rectangle\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\n\n\t\t\t\tfloat a2 = dot( v, vi );\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\n\n\t\t\t\t\tdist = t;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, out float dist ) {\n\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = hit - position;\n\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tfloat a2 = dot( v, vi );\n\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\n\n\t\t\t\tdist = t;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\n\t\t\t\t// uniform structs\n\t\t\t\t\n\n\tstruct PhysicalCamera {\n\n\t\tfloat focusDistance;\n\t\tfloat anamorphicRatio;\n\t\tfloat bokehSize;\n\t\tint apertureBlades;\n\t\tfloat apertureRotation;\n\n\t};\n\n\n\t\t\t\t\n\n\t#define RECT_AREA_LIGHT_TYPE 0\n\t#define CIRC_AREA_LIGHT_TYPE 1\n\t#define SPOT_LIGHT_TYPE 2\n\t#define DIR_LIGHT_TYPE 3\n\t#define POINT_LIGHT_TYPE 4\n\n\tstruct LightsInfo {\n\n\t\tsampler2D tex;\n\t\tuint count;\n\n\t};\n\n\tstruct Light {\n\n\t\tvec3 position;\n\t\tint type;\n\n\t\tvec3 color;\n\t\tfloat intensity;\n\n\t\tvec3 u;\n\t\tvec3 v;\n\t\tfloat area;\n\n\t\t// spot light fields\n\t\tfloat radius;\n\t\tfloat near;\n\t\tfloat decay;\n\t\tfloat distance;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint iesProfile;\n\n\t};\n\n\tLight readLightInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 6u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\n\t\tLight l;\n\t\tl.position = s0.rgb;\n\t\tl.type = int( round( s0.a ) );\n\n\t\tl.color = s1.rgb;\n\t\tl.intensity = s1.a;\n\n\t\tl.u = s2.rgb;\n\t\tl.v = s3.rgb;\n\t\tl.area = s3.a;\n\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\t\tl.radius = s4.r;\n\t\t\tl.near = s4.g;\n\t\t\tl.decay = s4.b;\n\t\t\tl.distance = s4.a;\n\n\t\t\tl.coneCos = s5.r;\n\t\t\tl.penumbraCos = s5.g;\n\t\t\tl.iesProfile = int( round ( s5.b ) );\n\n\t\t}\n\n\t\treturn l;\n\n\t}\n\n\n\t\t\t\t\n\n\tstruct EquirectHdrInfo {\n\n\t\tsampler2D marginalWeights;\n\t\tsampler2D conditionalWeights;\n\t\tsampler2D map;\n\n\t\tfloat totalSum;\n\n\t};\n\n\n\t\t\t\t\n\n\tstruct Material {\n\n\t\tvec3 color;\n\t\tint map;\n\n\t\tfloat metalness;\n\t\tint metalnessMap;\n\n\t\tfloat roughness;\n\t\tint roughnessMap;\n\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tint transmissionMap;\n\n\t\tfloat emissiveIntensity;\n\t\tvec3 emissive;\n\t\tint emissiveMap;\n\n\t\tint normalMap;\n\t\tvec2 normalScale;\n\n\t\tfloat clearcoat;\n\t\tint clearcoatMap;\n\t\tint clearcoatNormalMap;\n\t\tvec2 clearcoatNormalScale;\n\t\tfloat clearcoatRoughness;\n\t\tint clearcoatRoughnessMap;\n\n\t\tint iridescenceMap;\n\t\tint iridescenceThicknessMap;\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThicknessMinimum;\n\t\tfloat iridescenceThicknessMaximum;\n\n\t\tvec3 specularColor;\n\t\tint specularColorMap;\n\n\t\tfloat specularIntensity;\n\t\tint specularIntensityMap;\n\t\tbool thinFilm;\n\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\tint alphaMap;\n\n\t\tbool castShadow;\n\t\tfloat opacity;\n\t\tfloat alphaTest;\n\n\t\tfloat side;\n\t\tbool matte;\n\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tint sheenColorMap;\n\t\tfloat sheenRoughness;\n\t\tint sheenRoughnessMap;\n\n\t\tbool vertexColors;\n\t\tbool flatShading;\n\t\tbool transparent;\n\t\tbool fogVolume;\n\n\t\tmat3 mapTransform;\n\t\tmat3 metalnessMapTransform;\n\t\tmat3 roughnessMapTransform;\n\t\tmat3 transmissionMapTransform;\n\t\tmat3 emissiveMapTransform;\n\t\tmat3 normalMapTransform;\n\t\tmat3 clearcoatMapTransform;\n\t\tmat3 clearcoatNormalMapTransform;\n\t\tmat3 clearcoatRoughnessMapTransform;\n\t\tmat3 sheenColorMapTransform;\n\t\tmat3 sheenRoughnessMapTransform;\n\t\tmat3 iridescenceMapTransform;\n\t\tmat3 iridescenceThicknessMapTransform;\n\t\tmat3 specularColorMapTransform;\n\t\tmat3 specularIntensityMapTransform;\n\n\t};\n\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\n\n\t\tmat3 textureTransform;\n\n\t\tvec4 row1 = texelFetch1D( tex, index );\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\n\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\n\n\t\treturn textureTransform;\n\n\t}\n\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 45u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\n\t\tvec4 s9 = texelFetch1D( tex, i + 9u );\n\t\tvec4 s10 = texelFetch1D( tex, i + 10u );\n\t\tvec4 s11 = texelFetch1D( tex, i + 11u );\n\t\tvec4 s12 = texelFetch1D( tex, i + 12u );\n\t\tvec4 s13 = texelFetch1D( tex, i + 13u );\n\t\tvec4 s14 = texelFetch1D( tex, i + 14u );\n\n\t\tMaterial m;\n\t\tm.color = s0.rgb;\n\t\tm.map = int( round( s0.a ) );\n\n\t\tm.metalness = s1.r;\n\t\tm.metalnessMap = int( round( s1.g ) );\n\t\tm.roughness = s1.b;\n\t\tm.roughnessMap = int( round( s1.a ) );\n\n\t\tm.ior = s2.r;\n\t\tm.transmission = s2.g;\n\t\tm.transmissionMap = int( round( s2.b ) );\n\t\tm.emissiveIntensity = s2.a;\n\n\t\tm.emissive = s3.rgb;\n\t\tm.emissiveMap = int( round( s3.a ) );\n\n\t\tm.normalMap = int( round( s4.r ) );\n\t\tm.normalScale = s4.gb;\n\n\t\tm.clearcoat = s4.a;\n\t\tm.clearcoatMap = int( round( s5.r ) );\n\t\tm.clearcoatRoughness = s5.g;\n\t\tm.clearcoatRoughnessMap = int( round( s5.b ) );\n\t\tm.clearcoatNormalMap = int( round( s5.a ) );\n\t\tm.clearcoatNormalScale = s6.rg;\n\n\t\tm.sheen = s6.a;\n\t\tm.sheenColor = s7.rgb;\n\t\tm.sheenColorMap = int( round( s7.a ) );\n\t\tm.sheenRoughness = s8.r;\n\t\tm.sheenRoughnessMap = int( round( s8.g ) );\n\n\t\tm.iridescenceMap = int( round( s8.b ) );\n\t\tm.iridescenceThicknessMap = int( round( s8.a ) );\n\t\tm.iridescence = s9.r;\n\t\tm.iridescenceIor = s9.g;\n\t\tm.iridescenceThicknessMinimum = s9.b;\n\t\tm.iridescenceThicknessMaximum = s9.a;\n\n\t\tm.specularColor = s10.rgb;\n\t\tm.specularColorMap = int( round( s10.a ) );\n\n\t\tm.specularIntensity = s11.r;\n\t\tm.specularIntensityMap = int( round( s11.g ) );\n\t\tm.thinFilm = bool( s11.b );\n\n\t\tm.attenuationColor = s12.rgb;\n\t\tm.attenuationDistance = s12.a;\n\n\t\tm.alphaMap = int( round( s13.r ) );\n\n\t\tm.opacity = s13.g;\n\t\tm.alphaTest = s13.b;\n\t\tm.side = s13.a;\n\n\t\tm.matte = bool( s14.r );\n\t\tm.castShadow = ! bool( s14.g );\n\t\tm.vertexColors = bool( int( s14.b ) & 1 );\n\t\tm.flatShading = bool( int( s14.b ) & 2 );\n\t\tm.fogVolume = bool( int( s14.b ) & 4 );\n\t\tm.transparent = bool( s14.a );\n\n\t\tuint firstTextureTransformIdx = i + 15u;\n\n\t\tm.mapTransform = m.map == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx );\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\n\t\tm.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );\n\t\tm.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );\n\t\tm.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );\n\t\tm.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );\n\t\tm.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );\n\t\tm.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );\n\t\tm.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );\n\t\tm.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );\n\t\tm.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );\n\n\t\treturn m;\n\n\t}\n\n\n\t\t\t\t\n\n#ifndef FOG_CHECK_ITERATIONS\n#define FOG_CHECK_ITERATIONS 30\n#endif\n\n// returns whether the given material is a fog material or not\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\n\n\tuint i = materialIndex * 45u;\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\n\treturn bool( int( s14.b ) & 4 );\n\n}\n\n// returns true if we're within the first fog volume we hit\nbool bvhIntersectFogVolumeHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\tusampler2D materialIndexAttribute, sampler2D materials,\n\tout Material material\n) {\n\n\tmaterial.fogVolume = false;\n\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\n\n\t\t// find nearest hit\n\t\tuvec4 faceIndices = uvec4( 0u );\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\tvec3 barycoord = vec3( 0.0 );\n\t\tfloat side = 1.0;\n\t\tfloat dist = 0.0;\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\tif ( hit ) {\n\n\t\t\t// if it's a fog volume return whether we hit the front or back face\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\n\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\n\t\t\t\treturn side == - 1.0;\n\n\t\t\t} else {\n\n\t\t\t\t// move the ray forward\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n\n\n\t\t\t\t// sampling\n\t\t\t\t\n\n\tvec3 sampleHemisphere( vec3 n, vec2 uv ) {\n\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\n\t\tfloat a = - 1.0 / ( sign + n.z );\n\t\tfloat b = n.x * n.y * a;\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\n\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat theta = 2.0 * PI * uv.y;\n\t\tfloat x = r * cos( theta );\n\t\tfloat y = r * sin( theta );\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\n\n\t}\n\n\tvec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {\n\n\t\t// get the edges of the triangle and the diagonal across the\n\t\t// center of the parallelogram\n\t\tvec2 e1 = a - b;\n\t\tvec2 e2 = c - b;\n\t\tvec2 diag = normalize( e1 + e2 );\n\n\t\t// pick the point in the parallelogram\n\t\tif ( r.x + r.y > 1.0 ) {\n\n\t\t\tr = vec2( 1.0 ) - r;\n\n\t\t}\n\n\t\treturn e1 * r.x + e2 * r.y;\n\n\t}\n\n\tvec2 sampleCircle( vec2 uv ) {\n\n\t\tfloat angle = 2.0 * PI * uv.x;\n\t\tfloat radius = sqrt( uv.y );\n\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\n\n\t}\n\n\tvec3 sampleSphere( vec2 uv ) {\n\n\t\tfloat u = ( uv.x - 0.5 ) * 2.0;\n\t\tfloat t = uv.y * PI * 2.0;\n\t\tfloat f = sqrt( 1.0 - u * u );\n\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\n\n\t}\n\n\tvec2 sampleRegularPolygon( int sides, vec3 uvw ) {\n\n\t\tsides = max( sides, 3 );\n\n\t\tvec3 r = uvw;\n\t\tfloat anglePerSegment = 2.0 * PI / float( sides );\n\t\tfloat segment = floor( float( sides ) * r.x );\n\n\t\tfloat angle1 = anglePerSegment * segment;\n\t\tfloat angle2 = angle1 + anglePerSegment;\n\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\n\t\tvec2 b = vec2( 0.0, 0.0 );\n\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\n\n\t\treturn sampleTriangle( a, b, c, r.yz );\n\n\t}\n\n\t// samples an aperture shape with the given number of sides. 0 means circle\n\tvec2 sampleAperture( int blades, vec3 uvw ) {\n\n\t\treturn blades == 0 ?\n\t\t\tsampleCircle( uvw.xy ) :\n\t\t\tsampleRegularPolygon( blades, uvw );\n\n\t}\n\n\n\n\t\t\t\t\n\n\tstruct SurfaceRecord {\n\n\t\t// surface type\n\t\tbool volumeParticle;\n\n\t\t// geometry\n\t\tvec3 faceNormal;\n\t\tbool frontFace;\n\t\tvec3 normal;\n\t\tmat3 normalBasis;\n\t\tmat3 normalInvBasis;\n\n\t\t// cached properties\n\t\tfloat eta;\n\t\tfloat f0;\n\n\t\t// material\n\t\tfloat roughness;\n\t\tfloat filteredRoughness;\n\t\tfloat metalness;\n\t\tvec3 color;\n\t\tvec3 emission;\n\n\t\t// transmission\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tbool thinFilm;\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\t// clearcoat\n\t\tvec3 clearcoatNormal;\n\t\tmat3 clearcoatBasis;\n\t\tmat3 clearcoatInvBasis;\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tfloat filteredClearcoatRoughness;\n\n\t\t// sheen\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\n\t\t// iridescence\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThickness;\n\n\t\t// specular\n\t\tvec3 specularColor;\n\t\tfloat specularIntensity;\n\t};\n\n\tstruct ScatterRecord {\n\t\tfloat specularPdf;\n\t\tfloat pdf;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\t\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n\n\t\n\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetD( float cosThetaH, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat invAlpha = 1.0 / alpha;\n\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\n\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\n\n\t}\n\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\n\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\n\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\n\n\t}\n\n\tfloat velvetL( float x, float alpha ) {\n\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\n\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\n\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\n\n\t}\n\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetLambda( float cosTheta, float alpha ) {\n\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\n\n\t}\n\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\n\n\t}\n\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\n\n\t\tcosTheta = saturate( cosTheta );\n\n\t\tfloat c = 1.0 - cosTheta;\n\t\tfloat c3 = c * c * c;\n\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\n\n\t}\n\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\n\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\n\n\t}\n\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\n\t\treturn 1.0 - maxSheenColor * eWo;\n\n\t}\n\n\n\t\n\n\t// XYZ to sRGB color space\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\n\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n\t}\n\n\t// Conversion FO/IOR\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n\t}\n\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\n\n\t}\n\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\n\t\txyz /= 1.0685e-7;\n\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\n\t\treturn srgb;\n\n\t}\n\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\t\tvec3 I;\n\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\n\n\t\t// Handle TIR:\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\t\treturn vec3( 1.0 );\n\n\t\t}\n\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t\t// First interface\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIor < outsideIOR ) {\n\n\t\t\tphi12 = PI;\n\n\t\t}\n\n\t\tfloat phi21 = PI - phi12;\n\n\t\t// Second interface\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[0] < iridescenceIor ) {\n\n\t\t\tphi23[ 0 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[1] < iridescenceIor ) {\n\n\t\t\tphi23[ 1 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[2] < iridescenceIor ) {\n\n\t\t\tphi23[ 2 ] = PI;\n\n\t\t}\n\n\t\t// Phase shift\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t\t// Compound terms\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t\t// Reflectance term for m = 0 (DC term amplitude)\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\n\t\t// Reflectance term for m > 0 (pairs of diracs)\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\n\t\t}\n\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\t\treturn max( I, vec3( 0.0 ) );\n\n\t}\n\n\n\n\t// diffuse\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\n\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\n\n\t\t// TODO: subsurface approx?\n\n\t\tfloat F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\n\t\treturn wi.z / PI;\n\n\t}\n\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tvec3 lightDirection = sampleSphere( sobol2( 11 ) );\n\t\tlightDirection.z += 1.0;\n\t\tlightDirection = normalize( lightDirection );\n\n\t\treturn lightDirection;\n\n\t}\n\n\t// specular\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\n\t\tfloat metalness = surf.metalness;\n\t\tfloat roughness = surf.filteredRoughness;\n\n\t\tfloat eta = surf.eta;\n\t\tfloat f0 = surf.f0;\n\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\n\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\n\n\t\t// PDF\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\n\t\tfloat incidentTheta = acos( wo.z );\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\n\n\t\tcolor = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\t\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\n\n\t}\n\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\tsobol2( 12 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\n\t// transmission\n\t/*\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\t\tbool thinFilm = surf.thinFilm;\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( filteredRoughness ),\n\t\t\tsobol2( 13 )\n\t\t);\n\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\n\t\treturn normalize( lightDirection );\n\n\t}\n\t*/\n\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\t// PDF\n\t\tfloat F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tif ( F >= 1.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 1.0 - F );\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( sobol2( 13 ) ) * roughness );\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\t\treturn normalize( lightDirection );\n\n\t}\n\n\t// clearcoat\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tfloat ior = 1.5;\n\t\tfloat f0 = iorRatioToF0( ior );\n\t\tbool frontFace = surf.frontFace;\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\n\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\n\n\t\t// PDF\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\n\n\t}\n\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\tsobol2( 14 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\t// sheen\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\n\n\t\tfloat cosThetaO = saturateCos( wo.z );\n\t\tfloat cosThetaI = saturateCos( wi.z );\n\t\tfloat cosThetaH = wh.z;\n\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\n\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\t\tvec3 color = surf.sheenColor;\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\n\t\tcolor *= wi.z;\n\n\t\treturn color;\n\n\t}\n\n\t// bsdf\n\tvoid getLobeWeights(\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\n\t\tout float diffuseWeight, out float specularWeight, out float transmissionWeight, out float clearcoatWeight\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\t\tfloat fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\n\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\n\t\tdiffuseWeight /= totalWeight;\n\t\tspecularWeight /= totalWeight;\n\t\ttransmissionWeight /= totalWeight;\n\t\tclearcoatWeight /= totalWeight;\n\t}\n\n\tfloat bsdfEval(\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, out float specularPdf, out vec3 color\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\n\t\tfloat spdf = 0.0;\n\t\tfloat dpdf = 0.0;\n\t\tfloat tpdf = 0.0;\n\t\tfloat cpdf = 0.0;\n\t\tcolor = vec3( 0.0 );\n\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\n\n\t\t// diffuse\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\n\t\t\tcolor *= 1.0 - surf.transmission;\n\n\t\t}\n\n\t\t// ggx specular\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tvec3 outColor;\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\n\t\t\tcolor += outColor;\n\n\t\t}\n\n\t\t// transmission\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\n\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\n\n\t\t}\n\n\t\t// sheen\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\n\n\t\t// clearcoat\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\n\n\t\t}\n\n\t\tfloat pdf =\n\t\t\tdpdf * diffuseWeight\n\t\t\t+ spdf * specularWeight\n\t\t\t+ tpdf * transmissionWeight\n\t\t\t+ cpdf * clearcoatWeight;\n\n\t\t// retrieve specular rays for the shadows flag\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\n\n\t\treturn pdf;\n\n\t}\n\n\tfloat bsdfResult( vec3 worldWo, vec3 worldWi, SurfaceRecord surf, out vec3 color ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tcolor = surf.color / ( 4.0 * PI );\n\t\t\treturn 1.0 / ( 4.0 * PI );\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 wi = normalize( surf.normalInvBasis * worldWi );\n\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tvec3 clearcoatWi = normalize( surf.clearcoatInvBasis * worldWi );\n\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat specularPdf;\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\n\n\t}\n\n\tScatterRecord bsdfSample( vec3 worldWo, SurfaceRecord surf ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tScatterRecord sampleRec;\n\t\t\tsampleRec.specularPdf = 0.0;\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\n\t\t\tsampleRec.direction = sampleSphere( sobol2( 16 ) );\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\n\t\t\treturn sampleRec;\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tmat3 normalBasis = surf.normalBasis;\n\t\tmat3 invBasis = surf.normalInvBasis;\n\t\tmat3 clearcoatNormalBasis = surf.clearcoatBasis;\n\t\tmat3 clearcoatInvBasis = surf.clearcoatInvBasis;\n\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat pdf[4];\n\t\tpdf[0] = diffuseWeight;\n\t\tpdf[1] = specularWeight;\n\t\tpdf[2] = transmissionWeight;\n\t\tpdf[3] = clearcoatWeight;\n\n\t\tfloat cdf[4];\n\t\tcdf[0] = pdf[0];\n\t\tcdf[1] = pdf[1] + cdf[0];\n\t\tcdf[2] = pdf[2] + cdf[1];\n\t\tcdf[3] = pdf[3] + cdf[2];\n\n\t\tif( cdf[3] != 0.0 ) {\n\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\n\t\t\tcdf[0] *= invMaxCdf;\n\t\t\tcdf[1] *= invMaxCdf;\n\t\t\tcdf[2] *= invMaxCdf;\n\t\t\tcdf[3] *= invMaxCdf;\n\n\t\t} else {\n\n\t\t\tcdf[0] = 1.0;\n\t\t\tcdf[1] = 0.0;\n\t\t\tcdf[2] = 0.0;\n\t\t\tcdf[3] = 0.0;\n\n\t\t}\n\n\t\tvec3 wi;\n\t\tvec3 clearcoatWi;\n\n\t\tfloat r = sobol( 15 );\n\t\tif ( r <= cdf[0] ) { // diffuse\n\n\t\t\twi = diffuseDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[1] ) { // specular\n\n\t\t\twi = specularDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\n\n\t\t\twi = transmissionDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\n\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\n\n\t\t}\n\n\t\tScatterRecord result;\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\n\t\tresult.direction = normalize( surf.normalBasis * wi );\n\n\t\treturn result;\n\n\t}\n\n\n\t\t\t\t\n\n\t// samples the the given environment map in the given direction\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\n\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\n\n\t}\n\n\t// gets the pdf of the given direction to sample\n\tfloat equirectDirectionPdf( vec3 direction ) {\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tfloat theta = uv.y * PI;\n\t\tfloat sinTheta = sin( theta );\n\t\tif ( sinTheta == 0.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n\t}\n\n\t// samples the color given env map with CDF and returns the pdf of the direction\n\tfloat sampleEquirect( EquirectHdrInfo info, vec3 direction, out vec3 color ) {\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tcolor = texture2D( info.map, uv ).rgb;\n\n\t\tfloat totalSum = info.totalSum;\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( info.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n\t// samples a direction of the envmap with color and retrieves pdf\n\tfloat sampleEquirectProbability( EquirectHdrInfo info, vec2 r, out vec3 color, out vec3 direction ) {\n\n\t\t// sample env map cdf\n\t\tfloat v = texture2D( info.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\t\tfloat u = texture2D( info.conditionalWeights, vec2( r.y, v ) ).x;\n\t\tvec2 uv = vec2( u, v );\n\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\n\t\tdirection = derivedDirection;\n\t\tcolor = texture2D( info.map, uv ).rgb;\n\n\t\tfloat totalSum = info.totalSum;\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( info.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n\n\t\t\t\t\n\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n\t}\n\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t}\n\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\n\n\t\tfloat cosTheta = dot( posToLight, lightDir );\n\t\tfloat angle = acos( cosTheta ) * ( 1.0 / PI );\n\n\t\treturn texture2D( iesProfiles, vec3( 0.0, angle, iesProfile ) ).r;\n\n\t}\n\n\tstruct LightRecord {\n\n\t\tfloat dist;\n\t\tvec3 direction;\n\t\tfloat pdf;\n\t\tvec3 emission;\n\t\tint type;\n\n\t};\n\n\tbool lightsClosestHit( sampler2D lights, uint lightCount, vec3 rayOrigin, vec3 rayDirection, out LightRecord lightRec ) {\n\n\t\tbool didHit = false;\n\t\tuint l;\n\t\tfor ( l = 0u; l < lightCount; l ++ ) {\n\n\t\t\tLight light = readLightInfo( lights, l );\n\n\t\t\tvec3 u = light.u;\n\t\t\tvec3 v = light.v;\n\n\t\t\t// check for backface\n\t\t\tvec3 normal = normalize( cross( u, v ) );\n\t\t\tif ( dot( normal, rayDirection ) < 0.0 ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tu *= 1.0 / dot( u, u );\n\t\t\tv *= 1.0 / dot( v, v );\n\n\t\t\tfloat dist;\n\n\t\t\t// MIS / light intersection is not supported for punctual lights.\n\t\t\tif(\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\n\t\t\t) {\n\n\t\t\t\tif ( ! didHit || dist < lightRec.dist ) {\n\n\t\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\n\t\t\t\t\tdidHit = true;\n\t\t\t\t\tlightRec.dist = dist;\n\t\t\t\t\tlightRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\n\t\t\t\t\tlightRec.emission = light.color * light.intensity;\n\t\t\t\t\tlightRec.direction = rayDirection;\n\t\t\t\t\tlightRec.type = light.type;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn didHit;\n\n\t}\n\n\tLightRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\n\t\tlightRec.emission = light.color * light.intensity;\n\n\t\tvec3 randomPos;\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\n\n\t\t\t// rectangular area light\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\n\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\n\n\t\t\t// circular area light\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\t\tfloat x = r * cos( theta );\n\t\t\tfloat y = r * sin( theta );\n\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\n\n\t\t}\n\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tlightRec.dist = sqrt( lightDistSq );\n\n\t\tvec3 direction = toLight / lightRec.dist;\n\t\tlightRec.direction = direction;\n\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\n\t\tlightRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tfloat radius = light.radius * sqrt( ruv.x );\n\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\tfloat x = radius * cos( theta );\n\t\tfloat y = radius * sin( theta );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\t\tvec3 normal = normalize( cross( u, v ) );\n\n\t\tfloat angle = acos( light.coneCos );\n\t\tfloat angleTan = tan( angle );\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\n\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tfloat dist = sqrt( lightDistSq );\n\n\t\tvec3 direction = toLight / max( dist, EPSILON );\n\t\tfloat cosTheta = dot( direction, normal );\n\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\n\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\t\tlightRec.dist = dist;\n\t\tlightRec.direction = direction;\n\t\tlightRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\n\t\tlightRec.pdf = 1.0;\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\n\n\t\t// pick a random light\n\t\tuint l = uint( ruv.x * float( lightCount ) );\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\n\n\t\t\treturn randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\n\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec3 lightRay = light.u - rayOrigin;\n\t\t\tfloat lightDist = length( lightRay );\n\t\t\tfloat cutoffDistance = light.distance;\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\n\t\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\n\n\t\t\t}\n\n\t\t\tLightRecord rec;\n\t\t\trec.direction = normalize( lightRay );\n\t\t\trec.dist = length( lightRay );\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\n\t\t\trec.type = light.type;\n\t\t\treturn rec;\n\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\n\n\t\t\tLightRecord rec;\n\t\t\trec.dist = 1e10;\n\t\t\trec.direction = light.u;\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity;\n\t\t\trec.type = light.type;\n\n\t\t\treturn rec;\n\n\t\t} else {\n\n\t\t\t// sample the light\n\t\t\treturn randomAreaLightSample( light, rayOrigin, ruv.yz );\n\n\t\t}\n\n\t}\n\n\n\t\t\t\t\n\n\t// returns the hit distance given the material density\n\tfloat intersectFogVolume( Material material, float u ) {\n\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\n\n\t}\n\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\n\n\t\tScatterRecord sampleRec;\n\t\tsampleRec.specularPdf = 0.0;\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\n\t\tsampleRec.direction = sampleSphere( uv );\n\t\tsampleRec.color = surf.color;\n\t\treturn sampleRec;\n\n\t}\n\n\n\n\t\t\t\t// environment\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\t\t\t\tuniform mat4 environmentRotation;\n\t\t\t\tuniform float environmentIntensity;\n\n\t\t\t\t// lighting\n\t\t\t\tuniform sampler2DArray iesProfiles;\n\t\t\t\tuniform LightsInfo lights;\n\n\t\t\t\t// background\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\tuniform sampler2D backgroundMap;\n\n\t\t\t\t#endif\n\n\t\t\t\t// camera\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\t// geometry\n\t\t\t\tuniform sampler2DArray attributesArray;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform sampler2D materials;\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tuniform BVH bvh;\n\n\t\t\t\t// path tracer\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform int transmissiveBounces;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\n\t\t\t\t// image\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t// globals\n\t\t\t\tmat3 envRotation3x3;\n\t\t\t\tmat3 invEnvRotation3x3;\n\t\t\t\tfloat lightsDenom;\n\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\n\n\t\t\t\t\treturn clamp(\n\t\t\t\t\t\tmax(\n\t\t\t\t\t\t\troughness,\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t1.0\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\n\n\t\t\t\t\tvec3 sampleDir = normalize( direction + sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur );\n\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\t\treturn sampleEquirectColor( backgroundMap, sampleDir );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\treturn environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t\n\n\tstruct Ray {\n\n\t\tvec3 origin;\n\t\tvec3 direction;\n\n\t};\n\n\tstruct SurfaceHit {\n\n\t\tuvec4 faceIndices;\n\t\tvec3 barycoord;\n\t\tvec3 faceNormal;\n\t\tfloat side;\n\t\tfloat dist;\n\n\t};\n\n\tstruct RenderState {\n\n\t\tbool firstRay;\n\t\tbool transmissiveRay;\n\t\tbool isShadowRay;\n\t\tfloat accumulatedRoughness;\n\t\tint transmissiveTraversals;\n\t\tint traversals;\n\t\tuint depth;\n\t\tvec3 throughputColor;\n\t\tMaterial fogMaterial;\n\n\t};\n\n\tRenderState initRenderState() {\n\n\t\tRenderState result;\n\t\tresult.firstRay = true;\n\t\tresult.transmissiveRay = true;\n\t\tresult.isShadowRay = false;\n\t\tresult.accumulatedRoughness = 0.0;\n\t\tresult.transmissiveTraversals = 0;\n\t\tresult.traversals = 0;\n\t\tresult.throughputColor = vec3( 1.0 );\n\t\tresult.depth = 0u;\n\t\tresult.fogMaterial.fogVolume = false;\n\t\treturn result;\n\n\t}\n\n\n\t\t\t\t\n\n\tvec3 ndcToRayOrigin( vec2 coord ) {\n\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\n\t}\n\n\tRay getCameraRay() {\n\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\n\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\n\t\t// around this pixel's UV coordinate for AA\n\t\tvec2 ruv = sobol2( 0 );\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\n\t\tRay ray;\n\n\t\t#if CAMERA_TYPE == 2\n\n\t\t\t// Equirectangular projection\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\n\n\t\t\tray.direction = normalize( rayDirection4.xyz );\n\t\t\tray.origin = rayOrigin4.xyz / rayOrigin4.w;\n\n\t\t#else\n\n\t\t\t// get [- 1, 1] normalized device coordinates\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\n\t\t\tray.origin = ndcToRayOrigin( ndc );\n\n\t\t\t#if CAMERA_TYPE == 1\n\n\t\t\t\t// Orthographic projection\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\n\t\t\t\tray.direction = normalize( ray.direction );\n\n\t\t\t#else\n\n\t\t\t\t// Perspective projection\n\t\t\t\tray.direction = normalize( mat3( cameraWorldMatrix ) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#if FEATURE_DOF\n\t\t{\n\n\t\t\t// depth of field\n\t\t\tvec3 focalPoint = ray.origin + normalize( ray.direction ) * physicalCamera.focusDistance;\n\n\t\t\t// get the aperture sample\n\t\t\t// if blades === 0 then we assume a circle\n\t\t\tvec3 shapeUVW= sobol3( 1 );\n\t\t\tint blades = physicalCamera.apertureBlades;\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\n\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t// rotate the aperture shape\n\t\t\tapertureSample =\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\n\n\t\t\t// create the new ray\n\t\t\tray.origin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\tray.direction = focalPoint - ray.origin;\n\n\t\t}\n\t\t#endif\n\n\t\tray.direction = normalize( ray.direction );\n\n\t\treturn ray;\n\n\t}\n\n\n\t\t\t\t\n\n\t#define NO_HIT 0\n\t#define SURFACE_HIT 1\n\t#define LIGHT_HIT 2\n\t#define FOG_HIT 3\n\n\tint traceScene(\n\n\t\tRay ray, BVH bvh, LightsInfo lights, Material fogMaterial,\n\t\tout SurfaceHit surfaceHit, out LightRecord lightRec\n\n\t) {\n\n\t\tbool hit = bvhIntersectFirstHit( bvh, ray.origin, ray.direction, surfaceHit.faceIndices, surfaceHit.faceNormal, surfaceHit.barycoord, surfaceHit.side, surfaceHit.dist );\n\t\tbool lightHit = lightsClosestHit( lights.tex, lights.count, ray.origin, ray.direction, lightRec );\n\n\t\t#if FEATURE_FOG\n\n\t\tif ( fogMaterial.fogVolume ) {\n\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, sobol( 1 ) );\n\t\t\tif ( particleDist + 1e-4 < surfaceHit.dist && ( particleDist + 1e-4 < lightRec.dist || ! lightHit ) ) {\n\n\t\t\t\tsurfaceHit.side = 1.0;\n\t\t\t\tsurfaceHit.faceNormal = normalize( - ray.direction );\n\t\t\t\tsurfaceHit.dist = particleDist;\n\t\t\t\treturn FOG_HIT;\n\n\t\t\t}\n\n\t\t}\n\n\t\t#endif\n\n\t\tif ( lightHit && ( lightRec.dist < surfaceHit.dist || ! hit ) ) {\n\n\t\t\treturn LIGHT_HIT;\n\n\t\t}\n\n\t\tif ( hit ) {\n\n\t\t\treturn SURFACE_HIT;\n\n\t\t}\n\n\t\treturn NO_HIT;\n\n\t}\n\n\n\t\t\t\t\n\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t// returns true if a solid surface was hit\n\tbool attenuateHit(\n\t\tBVH bvh, RenderState state,\n\t\tRay ray, float rayDist,\n\t\tout vec3 color\n\t) {\n\n\t\tint traversals = state.traversals;\n\t\tint transmissiveTraversals = state.transmissiveTraversals;\n\t\tbool isShadowRay = state.isShadowRay;\n\t\tMaterial fogMaterial = state.fogMaterial;\n\n\t\tvec3 startPoint = ray.origin;\n\n\t\t// hit results\n\t\tSurfaceHit surfaceHit;\n\t\tLightRecord lightRec;\n\n\t\tcolor = vec3( 1.0 );\n\n\t\t// TODO: we should be using sobol sampling here instead of rand but the sobol bounce and path indices need to be incremented\n\t\t// and then reset.\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\tint hitType = traceScene(\n\t\t\t\tray, bvh, lights, fogMaterial,\n\t\t\t\tsurfaceHit, lightRec\n\t\t\t);\n\n\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( hitType == LIGHT_HIT ) {\n\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * lightRec.dist );\n\t\t\t\treturn totalDist < rayDist - max( totalDist, rayDist ) * 1e-4;\n\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\n\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * surfaceHit.dist );\n\t\t\t\tif ( totalDist > rayDist ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t// adjust the ray to the new surface\n\t\t\t\tbool isEntering = surfaceHit.side == 1.0;\n\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\tif ( material.fogVolume ) {\n\n\t\t\t\t\tfogMaterial = material;\n\t\t\t\t\tfogMaterial.fogVolume = surfaceHit.side == 1.0;\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t\t\t// albedo\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.vertexColors ) {\n\n\t\t\t\t\talbedo *= vertexColor;\n\n\t\t\t\t}\n\n\t\t\t\t// alphaMap\n\t\t\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t}\n\n\t\t\t\t// transmission\n\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t}\n\n\t\t\t\t// metalness\n\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t}\n\n\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\tif (\n\t\t\t\t\ttransmissionFactor < rand() && ! (\n\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\tmaterial.side != 0.0 && surfaceHit.side == material.side\n\n\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t)\n\t\t\t\t) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( surfaceHit.side == 1.0 && isEntering ) {\n\n\t\t\t\t\t// only attenuate by surface color on the way in\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\n\n\t\t\t\t} else if ( surfaceHit.side == - 1.0 ) {\n\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\n\t\t\t\t\tcolor *= transmissionAttenuation( surfaceHit.dist, material.attenuationColor, material.attenuationDistance );\n\n\t\t\t\t}\n\n\t\t\t\tbool isTransmissiveRay = dot( ray.direction, surfaceHit.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\n\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\n\t\t\t\t\n\n\tvec3 directLightContribution( vec3 worldWo, SurfaceRecord surf, RenderState state, vec3 rayOrigin ) {\n\n\t\t// uniformly pick a light or environment map\n\t\tif( lightsDenom != 0.0 && sobol( 5 ) < float( lights.count ) / lightsDenom ) {\n\n\t\t\t// sample a light or environment\n\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, sobol3( 6 ) );\n\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, lightRec.direction ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tlightRec.pdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the light area\n\t\t\tRay lightRay;\n\t\t\tlightRay.origin = rayOrigin;\n\t\t\tlightRay.direction = lightRec.direction;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tlightRec.pdf > 0.0 &&\n\t\t\t\tisDirectionValid( lightRec.direction, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( bvh, state, lightRay, lightRec.dist, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat lightMaterialPdf = bsdfResult( worldWo, lightRec.direction, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tfloat lightPdf = lightRec.pdf / lightsDenom;\n\t\t\t\t\tfloat misWeight = lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\n\t\t\t\t\treturn attenuatedColor * lightRec.emission * state.throughputColor * sampleColor * misWeight / lightPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\tvec3 envColor, envDirection;\n\t\t\tfloat envPdf = sampleEquirectProbability( envMapInfo, sobol2( 7 ), envColor, envDirection );\n\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\n\n\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t// results so we ignore the sample in this case.\n\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, envDirection ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tenvPdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the surface\n\t\t\tRay envRay;\n\t\t\tenvRay.origin = rayOrigin;\n\t\t\tenvRay.direction = envDirection;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\tisDirectionValid( envDirection, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( bvh, state, envRay, INFINITY, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat envMaterialPdf = bsdfResult( worldWo, envDirection, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tenvPdf /= lightsDenom;\n\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\treturn attenuatedColor * environmentIntensity * envColor * state.throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn vec3( 0.0 );\n\n\t}\n\n\n\t\t\t\t\n\n\t#define SKIP_SURFACE 0\n\t#define HIT_SURFACE 1\n\tint getSurfaceRecord(\n\t\tMaterial material, SurfaceHit surfaceHit, sampler2DArray attributesArray,\n\t\tfloat accumulatedRoughness,\n\t\tout SurfaceRecord surf\n\t) {\n\n\t\tif ( material.fogVolume ) {\n\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\n\n\t\t\tSurfaceRecord fogSurface;\n\t\t\tfogSurface.volumeParticle = true;\n\t\t\tfogSurface.color = material.color;\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\n\t\t\tfogSurface.normal = normal;\n\t\t\tfogSurface.faceNormal = normal;\n\t\t\tfogSurface.clearcoatNormal = normal;\n\n\t\t\tsurf = fogSurface;\n\t\t\treturn HIT_SURFACE;\n\n\t\t}\n\n\t\t// uv coord for textures\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t// albedo\n\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\tif ( material.map != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\t\t}\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\talbedo *= vertexColor;\n\n\t\t}\n\n\t\t// alphaMap\n\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t}\n\n\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t// and it's single sided.\n\t\t// - alpha test is disabled when it === 0\n\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\tfloat alphaTest = material.alphaTest;\n\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\tif (\n\t\t\t// material sidedness\n\t\t\tmaterial.side != 0.0 && surfaceHit.side != material.side\n\n\t\t\t// alpha test\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t// opacity\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < sobol( 3 )\n\t\t) {\n\n\t\t\treturn SKIP_SURFACE;\n\n\t\t}\n\n\t\t// fetch the interpolated smooth normal\n\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\tattributesArray,\n\t\t\tATTR_NORMAL,\n\t\t\tsurfaceHit.barycoord,\n\t\t\tsurfaceHit.faceIndices.xyz\n\t\t).xyz );\n\n\t\t// roughness\n\t\tfloat roughness = material.roughness;\n\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\n\n\t\t}\n\n\t\t// metalness\n\t\tfloat metalness = material.metalness;\n\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t}\n\n\t\t// emission\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\n\n\t\t}\n\n\t\t// transmission\n\t\tfloat transmission = material.transmission;\n\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t}\n\n\t\t// normal\n\t\tif ( material.flatShading ) {\n\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\n\t\t\t// interpolated vertex normals.\n\t\t\tnormal = surfaceHit.faceNormal * surfaceHit.side;\n\n\t\t}\n\n\t\tvec3 baseNormal = normal;\n\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tnormal *= surfaceHit.side;\n\n\t\t// clearcoat\n\t\tfloat clearcoat = material.clearcoat;\n\t\tif ( material.clearcoatMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\n\n\t\t}\n\n\t\t// clearcoatRoughness\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\n\n\t\t}\n\n\t\t// clearcoatNormal\n\t\tvec3 clearcoatNormal = baseNormal;\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tclearcoatNormal *= surfaceHit.side;\n\n\t\t// sheenColor\n\t\tvec3 sheenColor = material.sheenColor;\n\t\tif ( material.sheenColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// sheenRoughness\n\t\tfloat sheenRoughness = material.sheenRoughness;\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\n\n\t\t}\n\n\t\t// iridescence\n\t\tfloat iridescence = material.iridescence;\n\t\tif ( material.iridescenceMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\n\n\t\t}\n\n\t\t// iridescence thickness\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\n\n\t\t}\n\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\n\n\t\t// specular color\n\t\tvec3 specularColor = material.specularColor;\n\t\tif ( material.specularColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// specular intensity\n\t\tfloat specularIntensity = material.specularIntensity;\n\t\tif ( material.specularIntensityMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\n\n\t\t}\n\n\t\tsurf.volumeParticle = false;\n\n\t\tsurf.faceNormal = surfaceHit.faceNormal;\n\t\tsurf.normal = normal;\n\n\t\tsurf.metalness = metalness;\n\t\tsurf.color = albedo.rgb;\n\t\tsurf.emission = emission;\n\n\t\tsurf.ior = material.ior;\n\t\tsurf.transmission = transmission;\n\t\tsurf.thinFilm = material.thinFilm;\n\t\tsurf.attenuationColor = material.attenuationColor;\n\t\tsurf.attenuationDistance = material.attenuationDistance;\n\n\t\tsurf.clearcoatNormal = clearcoatNormal;\n\t\tsurf.clearcoat = clearcoat;\n\n\t\tsurf.sheen = material.sheen;\n\t\tsurf.sheenColor = sheenColor;\n\n\t\tsurf.iridescence = iridescence;\n\t\tsurf.iridescenceIor = material.iridescenceIor;\n\t\tsurf.iridescenceThickness = iridescenceThickness;\n\n\t\tsurf.specularColor = specularColor;\n\t\tsurf.specularIntensity = specularIntensity;\n\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\n\t\t// applied by its brdf function\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\n\t\tsurf.roughness = roughness * roughness;\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\n\t\tsurf.sheenRoughness = sheenRoughness;\n\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t// then we can just always assume this is a front face.\n\t\tsurf.frontFace = surfaceHit.side == 1.0 || transmission == 0.0;\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\n\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\n\t\t// The accumulated roughness value is scaled by a user setting and a "magic value" of 5.0.\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t// sharp internal reflections\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\n\n\t\t// get the normal frames\n\t\tsurf.normalBasis = getBasisFromNormal( surf.normal );\n\t\tsurf.normalInvBasis = inverse( surf.normalBasis );\n\n\t\tsurf.clearcoatBasis = getBasisFromNormal( surf.clearcoatNormal );\n\t\tsurf.clearcoatInvBasis = inverse( surf.clearcoatBasis );\n\n\t\treturn HIT_SURFACE;\n\n\t}\n\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// init\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) |  uint( gl_FragCoord.y );\n\t\t\t\t\tsobolPathIndex = uint( seed );\n\n\t\t\t\t\t// get camera ray\n\t\t\t\t\tRay ray = getCameraRay();\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tenvRotation3x3 = mat3( environmentRotation );\n\t\t\t\t\tinvEnvRotation3x3 = inverse( envRotation3x3 );\n\t\t\t\t\tlightsDenom = environmentIntensity == 0.0 && lights.count != 0u ? float( lights.count ) : float( lights.count + 1u );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0, 0, 0, 1 );\n\n\t\t\t\t\t// surface results\n\t\t\t\t\tSurfaceHit surfaceHit;\n\t\t\t\t\tLightRecord lightRec;\n\t\t\t\t\tScatterRecord scatterRec;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tRenderState state = initRenderState();\n\t\t\t\t\tstate.transmissiveTraversals = transmissiveBounces;\n\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\tstate.fogMaterial.fogVolume = bvhIntersectFogVolumeHit(\n\t\t\t\t\t\tbvh, ray.origin, - ray.direction,\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\n\t\t\t\t\t\tstate.fogMaterial\n\t\t\t\t\t);\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfor ( int i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tsobolBounceIndex ++;\n\n\t\t\t\t\t\tstate.depth ++;\n\t\t\t\t\t\tstate.traversals = bounces - i;\n\t\t\t\t\t\tstate.firstRay = i == 0 && state.transmissiveTraversals == transmissiveBounces;\n\n\t\t\t\t\t\tint hitType = traceScene(\n\t\t\t\t\t\t\tray, bvh, lights, state.fogMaterial,\n\t\t\t\t\t\t\tsurfaceHit, lightRec\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( hitType == LIGHT_HIT ) {\n\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// NOTE: we skip MIS for punctual lights since they are not supported in forward PT case\n\t\t\t\t\t\t\t\tif ( lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ) {\n\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// weight the contribution\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, lightRec.pdf / lightsDenom );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( hitType == NO_HIT ) {\n\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( envRotation3x3 * ray.direction, sobol2( 2 ) ) * state.throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envMapInfo, envRotation3x3 * ray.direction, envColor );\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectColor( envMapInfo.map, envRotation3x3 * ray.direction ) *\n\t\t\t\t\t\t\t\t\tstate.throughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\t\t\t\tmaterial = state.fogMaterial;\n\t\t\t\t\t\t\tstate.accumulatedRoughness += 0.2;\n\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\n\n\t\t\t\t\t\t\tstate.fogMaterial = material;\n\t\t\t\t\t\t\tstate.fogMaterial.fogVolume = surfaceHit.side == 1.0;\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// early out if this is a matte material\n\t\t\t\t\t\tif ( material.matte && state.firstRay ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && state.isShadowRay ) {\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSurfaceRecord surf;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgetSurfaceRecord(\n\t\t\t\t\t\t\t\tmaterial, surfaceHit, attributesArray, state.accumulatedRoughness,\n\t\t\t\t\t\t\t\tsurf\n\t\t\t\t\t\t\t) == SKIP_SURFACE\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscatterRec = bsdfSample( - ray.direction, surf );\n\t\t\t\t\t\tstate.isShadowRay = scatterRec.specularPdf < sobol( 4 );\n\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal ) < 0.0;\n\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, isBelowSurface ? - surf.faceNormal : surf.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t// next event estimation\n\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\tgl_FragColor.rgb += directLightContribution( - ray.direction, surf, state, hitPoint );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\t// TODO: handle transmissive surfaces\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( - ray.direction + scatterRec.direction );\n\t\t\t\t\t\t\tstate.accumulatedRoughness += max(\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.normal ) ) ),\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.clearcoatNormal ) ) )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tstate.transmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate emissive color\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * state.throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( scatterRec.pdf <= 0.0 || ! isDirectionValid( scatterRec.direction, surf.normal, surf.faceNormal ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\n\t\t\t\t\t\t// perform this separate from a bounce\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && state.transmissiveTraversals > 0 ) {\n\n\t\t\t\t\t\t\tstate.transmissiveTraversals --;\n\t\t\t\t\t\t\ti --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// handle throughput color transformation\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\n\t\t\t\t\t\tif ( ! surf.frontFace ) {\n\n\t\t\t\t\t\t\tstate.throughputColor *= transmissionAttenuation( surfaceHit.dist, surf.attenuationColor, surf.attenuationDistance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\n\n\t\t\t\t\t\t// russian roulette path termination\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\n\t\t\t\t\t\tuint minBounces = 3u;\n\t\t\t\t\t\tfloat depthProb = float( state.depth < minBounces );\n\n\t\t\t\t\t\tfloat rrProb = luminance( state.throughputColor * scatterRec.color / scatterRec.pdf );\n\t\t\t\t\t\trrProb /= luminance( state.throughputColor );\n\t\t\t\t\t\trrProb = sqrt( rrProb );\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\n\t\t\t\t\t\tif ( sobol( 8 ) > rrProb ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\n\t\t\t\t\t\tstate.throughputColor *= min( 1.0 / rrProb, 20.0 );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// adjust the throughput and discard and exit if we find discard the sample if there are any NaNs\n\t\t\t\t\t\tstate.throughputColor *= scatterRec.color / scatterRec.pdf;\n\t\t\t\t\t\tif ( any( isnan( state.throughputColor ) ) || any( isinf( state.throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// prepare for next ray\n\t\t\t\t\t\tray.direction = scatterRec.direction;\n\t\t\t\t\t\tray.origin = hitPoint;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t\t#if DEBUG_MODE == 1\n\n\t\t\t\t\t// output the number of rays checked in the path and number of\n\t\t\t\t\t// transmissive rays encountered.\n\t\t\t\t\tgl_FragColor.rgb = vec3(\n\t\t\t\t\t\tfloat( state.depth ),\n\t\t\t\t\t\ttransmissiveBounces - state.transmissiveTraversals,\n\t\t\t\t\t\t0.0\n\t\t\t\t\t);\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t`}),this.setValues(t)}}const er=new r(-1,1,1,-1,0,1),nr=new a;nr.setAttribute("position",new i([-1,3,0,-1,-1,0,3,-1,0],3)),nr.setAttribute("uv",new i([0,2,0,0,2,0],2));class rr{constructor(t){this._mesh=new o(nr,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,er)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}let ar=!0,ir=2.5,or=.1,sr=1;window.devicePixelRatio;const lr=e.createContext(null);function cr({alpha:e=1,samples:r=1,frames:a=1/0,tiles:i=2,bounces:o=1,enabled:s=!0,resolutionFactor:l=1,backgroundBlur:c=0,backgroundIntensity:u=1,children:f}){const h=n.useRef(null),m=ot((t=>t.gl)),g=ot((t=>t.size)),v=ot((t=>t.viewport)),x=ot((t=>t.camera)),y=ot((t=>t.scene)),b=n.useMemo((()=>new In),[]),w=n.useMemo((()=>new tr),[]),T=n.useMemo((()=>{const t=new At(m);return t.frames=0,t.alpha=!0,t}),[m]);n.useEffect((()=>{if(w.envMapInfo=new Vn,w.backgroundMap=null,y.background instanceof A)w.envMapInfo.updateFrom(y.background);else{if(y.environment instanceof A){w.envMapInfo.updateFrom(y.environment);const t=new En;t.topColor.set(0),t.bottomColor.set(0),t.update(),w.backgroundMap=t}if(y.background instanceof p){const t=new En;t.topColor.set(y.background.getHex()),t.bottomColor.set(y.background.getHex()),t.update(),w.backgroundMap=t}else y.background instanceof En&&(w.backgroundMap=y.background)}}),[w,y.background,y.environment]);const R=n.useMemo((()=>new rr(new Qn({map:T.target.texture,blending:at,premultipliedAlpha:m.getContextAttributes().premultipliedAlpha}))),[]);n.useEffect((()=>{w.bounces=o}),[w,o]),n.useEffect((()=>{w.backgroundBlur=c}),[w,c]),n.useEffect((()=>{w.backgroundAlpha=e}),[w,e]),n.useEffect((()=>{w.environmentIntensity=u}),[w,u]),n.useEffect((()=>{T.setSize(g.width*l*v.dpr,g.height*l*v.dpr),T.reset()}),[T,g,l]),n.useEffect((()=>{T.camera=x}),[T,x]),n.useEffect((()=>{T.material=w}),[T,w]),n.useEffect((()=>{T.alpha=e<1}),[T,e]),n.useEffect((()=>{const t=(e=i,Array.isArray(e)?e:e instanceof d?[e.x,e.y]:"number"==typeof e?[e,e]:[e.x,e.y]);var e;T.tiles.set(t[0],t[1]),T.stableNoise=ar,R.material.sigma=ir,R.material.threshold=or,R.material.kSigma=sr}),[T,i]);const S=n.useMemo((()=>({update:()=>{const t=h.current,{bvh:e,textures:n,materials:r,lights:a}=b.generate(t);console.log(r,a);const i=e.geometry,o=T.material;w.bvh.updateFrom(e),o.bvh.updateFrom(e),o.attributesArray.updateFrom(i.attributes.normal,i.attributes.tangent,i.attributes.uv,i.attributes.color),o.materialIndexAttribute.updateFrom(i.attributes.materialIndex),o.textures.setTextures(m,2048,2048,n),o.materials.updateFrom(r,n),w.lights.updateFrom(a),T.material.lights.updateFrom(a)},reset:()=>{T.reset(),T.frames=0},renderer:T})),[w,b,m]);return n.useEffect((()=>{y.updateMatrixWorld(),S.update(),S.reset()}),[]),st((({camera:t,gl:e,scene:n})=>{if(t.updateMatrixWorld(),s&&T.frames<a){for(let t=0;t<r;t++)T.update();T.frames++}T.samples<1&&e.render(n,t),e.autoClear=!1,R.material.map=T.target.texture,R.render(e),e.autoClear=!0}),1),t.jsx(lr.Provider,{value:S,children:t.jsx("group",{ref:h,children:f})})}function ur(){const t=n.useContext(lr);if(!t)throw new Error("usePathtracer must be used within a Pathtracing");return t}const fr=()=>{const{reset:e}=ur();return t.jsxs(t.Fragment,{children:[t.jsx(lt,{onChange:()=>e(),makeDefault:!0}),t.jsx(hr,{})]})};function hr(){return t.jsxs("group",{position:[0,-.25,0],children:[t.jsx(dr,{position:[0,-.5,0]}),t.jsxs("mesh",{position:[0,0,-1],scale:.5,children:[t.jsx("sphereGeometry",{args:[1,64,64]}),t.jsx(ct,{transmission:1,resolution:1024,distortion:.25,color:"#fff",thickness:0,roughness:0})]}),t.jsxs("mesh",{castShadow:!0,receiveShadow:!0,position:[1,.25,1],children:[t.jsx("sphereGeometry",{args:[.75,32,32]}),t.jsx(ct,{color:"red",transmission:1,thickness:2,roughness:0})]}),t.jsx("directionalLight",{intensity:3,color:"#fff"}),t.jsx("pointLight",{args:[0,0,3],color:"#f00"}),t.jsx("rectAreaLight",{args:["white",3],width:5,height:5,position:[-3,4,1],target:[0,0,0],visible:!1})]})}function dr(e){const{nodes:n,materials:r}=ut("/models/ruby.glb");return t.jsx("group",{...e,dispose:null,children:t.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:n.Ruby_0.geometry,rotation:[-Math.PI/2,0,0],children:t.jsx(ct,{transmission:1,roughness:0,clearcoat:1,clearcoatRoughness:0,color:"orange"})})})}function mr({infoRef:t}){const{renderer:e}=ur();return st((()=>{t.current&&(t.current.children[0].textContent=`${e.frames} frames`,t.current.children[1].textContent=`${e.samples} samples`)}),[]),null}const pr=()=>{const e=n.useRef();return t.jsxs("div",{className:"page",children:[t.jsx(ft,{shadows:!0,camera:{position:[0,.1,5],fov:45,near:1,far:20},gl:{toneMapping:it},children:t.jsxs(cr,{samples:1,bounces:2,resolutionFactor:1,tiles:1,enabled:!0,frames:20,backgroundIntensity:1,backgroundBlur:.2,children:[t.jsx(fr,{}),t.jsx(mr,{infoRef:e})]})}),t.jsxs("div",{className:"info",ref:e,style:{position:"absolute",left:"0",top:"0",zIndex:"111",color:"red"},children:[t.jsx("p",{children:"0 frames"}),t.jsx("p",{children:"0 samples"})]})]})};export{pr as default};
