import{r as e,G as n,aB as o}from"./vendor-89444a7f.js";import{bb as r,bR as t,a as s,V as a,aZ as i,l,a_ as u,az as h,a0 as c,aF as d,bh as m,aw as g}from"./vendor_three-3a2bdf96.js";/* empty css                    */function f(o){const{nodes:t,materials:s}=r("/models/spaceship.glb"),a=e.useRef(),i=e.useRef();return n.jsx("group",{ref:a,...o,dispose:null,children:n.jsxs("group",{position:[10,10,-80],rotation:[.1*Math.PI,0*Math.PI,.03*Math.PI],scale:4e-4,children:[n.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.mesh_0.geometry,material:s.ferrari}),n.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.mesh_0_1.geometry,material:s.raggi}),n.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.mesh_0_2.geometry,material:s.ammenita}),n.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.mesh_0_3.geometry,material:s.motore}),n.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.mesh_0_4.geometry,material:s.glow_motore}),n.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.mesh_0_5.geometry,material:s["BURCIA GLOW_int"]}),n.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.mesh_0_6.geometry,material:s["BURCIA GLOW est"]}),n.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.mesh_0_7.geometry,material:s["luce post"]}),n.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.mesh_0_8.geometry,material:s.fire,ref:i})]})})}r.preload("/models/spaceship.glb");const v={uFreq:new t(new s(2,3)),uAmp:new t(new s(35,10))},p=(e,n)=>{let o=.0125,r=v.uFreq.value,t=v.uAmp.value,s=new a(Math.sin(e*Math.PI*r.x+n)*t.x-Math.sin(o*Math.PI*r.x+n)*t.x,Math.sin(e*Math.PI*r.y+n)*t.y-Math.sin(o*Math.PI*r.y+n)*t.y,0),i=new a(1,1,0),l=new a(0,0,-5);return s.multiply(i).add(l)},L={length:400,roadWidth:10,islandWidth:5,lanesPerRoad:2,fov:90,fovSpeedUp:150,speedUp:2,carLightsFade:.4,totalSideLightSticks:50,lightPairsPerRoadWay:70,shoulderLinesWidthPercentage:.05,brokenLinesWidthPercentage:.1,brokenLinesLengthPercentage:.5,lightStickWidth:[.12,.5],lightStickHeight:[1.3,1.7],movingAwaySpeed:[60,80],movingCloserSpeed:[-120,-160],carLightsLength:[20,60],carLightsRadius:[.05,.14],carWidthPercentage:[.3,.5],carShiftX:[-.2,.2],carFloorSeparation:[.05,1],colors:{roadColor:526344,islandColor:657930,background:0,shoulderLines:1250072,brokenLines:1250072,leftCars:[16736115,15158624,16715818],rightCars:[10806246,8442324,5489350],sticks:10806246}};u({RoadWayMaterial:i({uColor:new l(L.colors.roadColor),uTime:0,uTravelLength:L.length,uFreq:new s(4,8),uAmp:new s(10,20),uPowY:new s(20,2),uLanes:L.lanesPerRoad,uBrokenLinesColor:new l(L.colors.brokenLines),uShoulderLinesColor:new l(L.colors.shoulderLines),uShoulderLinesWidthPercentage:L.shoulderLinesWidthPercentage,uBrokenLinesLengthPercentage:L.brokenLinesLengthPercentage,uBrokenLinesWidthPercentage:L.brokenLinesWidthPercentage},"\nuniform float uTime;\nuniform float uTravelLength;\n\nvarying vec2 vUv; \n\n//   #include <getDistortion_vertex>\nuniform vec4 uFreq;\nuniform vec4 uAmp;\nuniform vec2 uPowY;\nfloat nsin(float val){\n    return sin(val) * 0.5+0.5;\n}\n\n#define PI 3.14159265358979\nfloat getDistortionX(float progress){\n    return \n            (\n                sin(progress * PI * uFreq.x + uTime) * uAmp.x\n            \n            );\n}\nfloat getDistortionY(float progress){\n    return \n            (\n                pow(abs(progress * uPowY.x),uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n            );\n}\nvec3 getDistortion(float progress){\n    return vec3(\n        getDistortionX(progress)-getDistortionX(0.02) ,\n        getDistortionY(progress)- getDistortionY(0.02),\n        0.\n    );\n}\n\nvoid main() {\n    vec3 transformed = position.xyz;\n\n    vec3 distortion  = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n    transformed.x += distortion.x;\n    transformed.z += distortion.y;\n    transformed.y += -1.*distortion.z;  \n    \n    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}\n","\nvarying vec2 vUv; \nuniform vec3 uColor;\nuniform float uTime;\n\n// start #include <roadMarkings_vars>\nuniform float uLanes;\nuniform vec3 uBrokenLinesColor;\nuniform vec3 uShoulderLinesColor;\nuniform float uShoulderLinesWidthPercentage;\nuniform float uBrokenLinesWidthPercentage;\nuniform float uBrokenLinesLengthPercentage;\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n// end #include <roadMarkings_vars>\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 color = vec3(uColor);\n    \n    // #include <roadMarkings_fragment>\n\n    uv.y = mod(uv.y + uTime * 0.1,1.);\n    float brokenLineWidth = 1. / uLanes * uBrokenLinesWidthPercentage;\n    // How much % of the lane's space is empty\n    float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n    // Horizontal * vertical offset\n    float brokenLines = step(1.-brokenLineWidth * uLanes,fract(uv.x * uLanes)) * step(laneEmptySpace, fract(uv.y * 100.)) ;\n    // Remove right-hand lines on the right-most lane\n    brokenLines *= step(uv.x * uLanes,uLanes-1.);\n    color = mix(color, uBrokenLinesColor, brokenLines);\n\n\n    float shoulderLinesWidth = 1. / uLanes * uShoulderLinesWidthPercentage;\n    float shoulderLines = step(1.-shoulderLinesWidth, uv.x) + step(uv.x, shoulderLinesWidth);\n    color = mix(color, uBrokenLinesColor, shoulderLines);\n\n    vec2 noiseFreq = vec2(4., 7000.);\n    float roadNoise = random( floor(uv * noiseFreq)/noiseFreq ) * 0.02 - 0.01; \n    color += roadNoise;\n\n    gl_FragColor = vec4(color,1.);\n}\n")});u({IslandMaterial:i({uColor:new l(L.colors.islandColor),uTime:0,uTravelLength:L.length,uFreq:new s(4,8),uAmp:new s(10,20),uPowY:new s(20,2)},"\nuniform float uTime;\nuniform float uTravelLength;\n\nvarying vec2 vUv; \n\n//   #include <getDistortion_vertex>\nuniform vec4 uFreq;\nuniform vec4 uAmp;\nuniform vec2 uPowY;\nfloat nsin(float val){\n    return sin(val) * 0.5+0.5;\n}\n\n#define PI 3.14159265358979\nfloat getDistortionX(float progress){\n    return \n            (\n                sin(progress * PI * uFreq.x + uTime) * uAmp.x\n            \n            );\n}\nfloat getDistortionY(float progress){\n    return \n            (\n                pow(abs(progress * uPowY.x),uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n            );\n}\nvec3 getDistortion(float progress){\n    return vec3(\n        getDistortionX(progress)-getDistortionX(0.02) ,\n        getDistortionY(progress)- getDistortionY(0.02),\n        0.\n    );\n}\n\nvoid main() {\n    vec3 transformed = position.xyz;\n\n    vec3 distortion  = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n    transformed.x += distortion.x;\n    transformed.z += distortion.y;\n    transformed.y += -1.*distortion.z;  \n    \n    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}\n","\nvarying vec2 vUv; \nuniform vec3 uColor;\nuniform float uTime;\n\n// start #include <roadMarkings_vars>\nuniform float uLanes;\nuniform vec3 uBrokenLinesColor;\nuniform vec3 uShoulderLinesColor;\nuniform float uShoulderLinesWidthPercentage;\nuniform float uBrokenLinesWidthPercentage;\nuniform float uBrokenLinesLengthPercentage;\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n// end #include <roadMarkings_vars>\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 color = vec3(uColor);\n    \n    // #include <roadMarkings_fragment>\n\n    uv.y = mod(uv.y + uTime * 0.1,1.);\n    float brokenLineWidth = 1. / uLanes * uBrokenLinesWidthPercentage;\n    // How much % of the lane's space is empty\n    float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n    // Horizontal * vertical offset\n    float brokenLines = step(1.-brokenLineWidth * uLanes,fract(uv.x * uLanes)) * step(laneEmptySpace, fract(uv.y * 100.)) ;\n    // Remove right-hand lines on the right-most lane\n    brokenLines *= step(uv.x * uLanes,uLanes-1.);\n    color = mix(color, uBrokenLinesColor, brokenLines);\n\n\n    float shoulderLinesWidth = 1. / uLanes * uShoulderLinesWidthPercentage;\n    float shoulderLines = step(1.-shoulderLinesWidth, uv.x) + step(uv.x, shoulderLinesWidth);\n    color = mix(color, uBrokenLinesColor, shoulderLines);\n\n    vec2 noiseFreq = vec2(4., 7000.);\n    float roadNoise = random( floor(uv * noiseFreq)/noiseFreq ) * 0.02 - 0.01; \n    color += roadNoise;\n\n    gl_FragColor = vec4(color,1.);\n}\n")});const y=e=>Array.isArray(e)?Math.random()*(e[1]-e[0])+e[0]:Math.random()*e,x=e=>Array.isArray(e)?e[Math.floor(Math.random()*e.length)]:e,P=(e,n,o=.1,r=.001)=>{let t=(n-e)*o;return Math.abs(t)<r&&(t=n-e),t};function w(o){const{options:r,pColor:t,pSpeed:s,isLeftSide:i}=o,u=e.useRef();let d=t;console.log(r,t,s,i),h(((e,n)=>{const o=e.clock.getElapsedTime();u.current.uTime=o}));let m=new c(new a(0,0,0),new a(0,0,-1)),g=r.roadWidth/r.lanesPerRoad,f=[],v=[],p=[];d=Array.isArray(d)?d.map((e=>new l(e))):new l(d);for(let e=0;e<r.lightPairsPerRoadWay;e++){let n=y(r.carLightsRadius),o=y(r.carLightsLength),t=y(s),a=e%3*g-r.roadWidth/2+g/2,i=y(r.carWidthPercentage)*g;a+=y(r.carShiftX)*g;let l=y(r.carFloorSeparation)+1.3*n,u=-y(r.length);f.push(a-i/2),f.push(l),f.push(u),f.push(a+i/2),f.push(l),f.push(u),v.push(n),v.push(o),v.push(t),v.push(n),v.push(o),v.push(t);let h=x(d);p.push(h.r),p.push(h.g),p.push(h.b),p.push(h.r),p.push(h.g),p.push(h.b)}const L=new Float32Array(f),P=new Float32Array(v),w=new Float32Array(p),S=e.useRef(),b=i?-r.roadWidth/2-r.islandWidth/2:r.roadWidth/2+r.islandWidth/2;return e.useEffect((()=>{console.log(S.current),console.log(u.current)}),[]),n.jsx("group",{ref:S,rotation:[0,0,0],position:[b,0,0],children:n.jsxs("instancedMesh",{args:[null,null,2*r.lightPairsPerRoadWay],children:[n.jsxs("tubeGeometry",{args:[m,40,1,8,!1],children:[n.jsx("instancedBufferAttribute",{attach:"attributes-aOffset",args:[L,3]}),n.jsx("instancedBufferAttribute",{attach:"attributes-aMetrics",args:[P,3]}),n.jsx("instancedBufferAttribute",{attach:"attributes-aColor",args:[w,3]})]}),n.jsx("flyLineMaterial",{ref:u})]})})}function S(){return n.jsx("section",{className:"lab_show",children:n.jsxs(d,{shadows:!0,dpr:[1,1.5],camera:{position:[0,8,-5],fov:45,near:.1,far:1e4},children:[n.jsx("color",{attach:"background",args:["#000"]}),n.jsx(b,{}),n.jsx(k,{}),n.jsx(f,{}),n.jsx(w,{color:"#f00",pSpeed:L.movingCloserSpeed,options:L,pColor:L.colors.leftCars,isLeftSide:!0}),n.jsx(w,{color:"#00f",pSpeed:L.movingCloserSpeed,options:L,pColor:L.colors.rightCars,isLeftSide:!1}),n.jsx(m,{})]})})}function b(){return n.jsxs(n.Fragment,{children:[n.jsx("color",{attach:"background",args:["#15151a"]}),n.jsx("ambientLight",{intensity:.7}),n.jsx("directionalLight",{intensity:.5,position:[-5,5,5],castShadow:!0,"shadow-mapSize":1024}),n.jsx("pointLight",{intensity:1,position:[-.15,1,0]}),n.jsx("pointLight",{intensity:1,position:[2,1,0]})]})}function k({children:r}){const{gl:t,camera:s}=g(),a=e.useRef();let i=0,l=0;const u=L.fov;console.log(t,s);const{x:c,y:d,z:m}=o({x:{value:0,min:-100,max:10,step:.01},y:{value:5,min:-10,max:100,step:.01},z:{value:10,min:-100,max:100,step:.01}});return h(((e,n)=>{let o=Math.exp(60*Math.log2(.9)*n),r=P(s.fov,u,o);i+=P(i,0,o,1e-5),l+=i*n;let t=e.clock.getElapsedTime()+l;0!==r&&(s.fov+=r*n*6),s.position.x=c,s.position.y=d,s.position.z=m,p(.025,t)})),n.jsx("group",{ref:a,children:r})}u({FlyLineMaterial:i({uTime:0,uTravelLength:L.length,uFade:new s(0,1-L.carLightsFade),uFreq:new s(2,3),uAmp:new s(35,10)},"\nattribute vec3 aOffset;\nattribute vec3 aMetrics;\nattribute vec3 aColor;\n\n\n\nuniform float uTravelLength;\nuniform float uTime;\nuniform float uSpeed;\n\nvarying vec2 vUv; \nvarying vec3 vColor; \n\n\nuniform vec2 uFreq;\nuniform vec2 uAmp;\n#define PI 3.14159265358979\n\nvec3 getDistortion(float progress){\n\n        float camProgress = 0.0125;\n        return vec3( \n            sin(progress * PI * uFreq.x +uTime) * uAmp.x - sin(camProgress * PI * uFreq.x+uTime ) * uAmp.x,\n            sin(progress * PI * uFreq.y +uTime) * uAmp.y - sin(camProgress * PI * uFreq.y+uTime ) * uAmp.y,\n            0.\n        );\n    }\n\nvoid main() {\n    vec3 transformed = position.xyz;\n    float radius = aMetrics.r;\n    float myLength = aMetrics.g;\n    float speed = aMetrics.b;\n\n    transformed.xy *= radius ;\n    transformed.z *= myLength;\n  \n    // Add my length to make sure it loops after the lights hits the end\n    transformed.z += myLength-mod( uTime *speed + aOffset.z, uTravelLength);\n    transformed.xy += aOffset.xy;\n\n\n    float progress = abs(transformed.z / uTravelLength);\n    transformed.xyz += getDistortion(progress);\n\n    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n    vColor = aColor;\n}\n","\nvarying vec3 vColor;\nvarying vec2 vUv; \nuniform vec2 uFade;\nvoid main() {\n    vec3 color = vec3(vColor);\n    float fadeStart = 0.4;\n    float maxFade = 0.;\n    float alpha = 1.;\n\n    alpha = smoothstep(uFade.x, uFade.y, vUv.x);\n    gl_FragColor = vec4(color,alpha);\n    if (gl_FragColor.a < 0.0001) discard;\n}\n")});export{S as default};
