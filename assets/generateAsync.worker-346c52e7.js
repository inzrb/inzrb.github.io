!function(){"use strict";
/**
   * @license
   * Copyright 2010-2023 Three.js Authors
   * SPDX-License-Identifier: MIT
   */const t=1,e=2,s=1001;class i{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const s=this._listeners;void 0===s[t]&&(s[t]=[]),-1===s[t].indexOf(e)&&s[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const s=this._listeners;return void 0!==s[t]&&-1!==s[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const s=this._listeners[t];if(void 0!==s){const t=s.indexOf(e);-1!==t&&s.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const s=e.slice(0);for(let e=0,i=s.length;e<i;e++)s[e].call(this,t);t.target=null}}}const r=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];function n(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,s=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(r[255&t]+r[t>>8&255]+r[t>>16&255]+r[t>>24&255]+"-"+r[255&e]+r[e>>8&255]+"-"+r[e>>16&15|64]+r[e>>24&255]+"-"+r[63&s|128]+r[s>>8&255]+"-"+r[s>>16&255]+r[s>>24&255]+r[255&i]+r[i>>8&255]+r[i>>16&255]+r[i>>24&255]).toLowerCase()}function o(t,e,s){return Math.max(e,Math.min(s,t))}function a(t,e){switch(e.constructor){case Float32Array:return t;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function h(t,e){switch(e.constructor){case Float32Array:return t;case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}class c{constructor(t=0,e=0){c.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,s=this.y,i=t.elements;return this.x=i[0]*e+i[3]*s+i[6],this.y=i[1]*e+i[4]*s+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(t,Math.min(e,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const s=Math.cos(e),i=Math.sin(e),r=this.x-t.x,n=this.y-t.y;return this.x=r*s-n*i+t.x,this.y=r*i+n*s+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class u{constructor(){u.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(t,e,s,i,r,n,o,a,h){const c=this.elements;return c[0]=t,c[1]=i,c[2]=o,c[3]=e,c[4]=r,c[5]=a,c[6]=s,c[7]=n,c[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}extractBasis(t,e,s){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,n=s[0],o=s[3],a=s[6],h=s[1],c=s[4],u=s[7],l=s[2],d=s[5],m=s[8],y=i[0],p=i[3],x=i[6],f=i[1],g=i[4],b=i[7],w=i[2],M=i[5],_=i[8];return r[0]=n*y+o*f+a*w,r[3]=n*p+o*g+a*M,r[6]=n*x+o*b+a*_,r[1]=h*y+c*f+u*w,r[4]=h*p+c*g+u*M,r[7]=h*x+c*b+u*_,r[2]=l*y+d*f+m*w,r[5]=l*p+d*g+m*M,r[8]=l*x+d*b+m*_,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],n=t[4],o=t[5],a=t[6],h=t[7],c=t[8];return e*n*c-e*o*h-s*r*c+s*o*a+i*r*h-i*n*a}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],n=t[4],o=t[5],a=t[6],h=t[7],c=t[8],u=c*n-o*h,l=o*a-c*r,d=h*r-n*a,m=e*u+s*l+i*d;if(0===m)return this.set(0,0,0,0,0,0,0,0,0);const y=1/m;return t[0]=u*y,t[1]=(i*h-c*s)*y,t[2]=(o*s-i*n)*y,t[3]=l*y,t[4]=(c*e-i*a)*y,t[5]=(i*r-o*e)*y,t[6]=d*y,t[7]=(s*a-h*e)*y,t[8]=(n*e-s*r)*y,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,s,i,r,n,o){const a=Math.cos(r),h=Math.sin(r);return this.set(s*a,s*h,-s*(a*n+h*o)+n+t,-i*h,i*a,-i*(-h*n+a*o)+o+e,0,0,1),this}scale(t,e){return this.premultiply(l.makeScale(t,e)),this}rotate(t){return this.premultiply(l.makeRotation(-t)),this}translate(t,e){return this.premultiply(l.makeTranslation(t,e)),this}makeTranslation(t,e){return this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,s,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<9;i++)if(e[i]!==s[i])return!1;return!0}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const l=new u;function d(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function m(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}let y;class p{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===y&&(y=d("canvas")),y.width=t.width,y.height=t.height;const s=y.getContext("2d");t instanceof ImageData?s.putImageData(t,0,0):s.drawImage(t,0,0,t.width,t.height),e=y}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=d("canvas");e.width=t.width,e.height=t.height;const s=e.getContext("2d");s.drawImage(t,0,0,t.width,t.height);const i=s.getImageData(0,0,t.width,t.height),r=i.data;for(let t=0;t<r.length;t++)r[t]=255*m(r[t]/255);return s.putImageData(i,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*m(e[t]/255)):e[t]=m(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}class x{constructor(t=null){this.isSource=!0,this.uuid=n(),this.data=t,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(null!==i){let t;if(Array.isArray(i)){t=[];for(let e=0,s=i.length;e<s;e++)i[e].isDataTexture?t.push(f(i[e].image)):t.push(f(i[e]))}else t=f(i);s.url=t}return e||(t.images[this.uuid]=s),s}}function f(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?p.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let g=0;class b extends i{constructor(t=b.DEFAULT_IMAGE,e=b.DEFAULT_MAPPING,s=1001,i=1001,r=1006,o=1008,a=1023,h=1009,l=b.DEFAULT_ANISOTROPY,d=3e3){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:g++}),this.uuid=n(),this.name="",this.source=new x(t),this.mipmaps=[],this.mapping=e,this.wrapS=s,this.wrapT=i,this.magFilter=r,this.minFilter=o,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=h,this.offset=new c(0,0),this.repeat=new c(1,1),this.center=new c(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new u,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=d,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const s={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),e||(t.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case s:t.x=t.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case s:t.y=t.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}}b.DEFAULT_IMAGE=null,b.DEFAULT_MAPPING=300,b.DEFAULT_ANISOTROPY=1;class w{constructor(t=0,e=0,s=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=s,this._w=i}static slerpFlat(t,e,s,i,r,n,o){let a=s[i+0],h=s[i+1],c=s[i+2],u=s[i+3];const l=r[n+0],d=r[n+1],m=r[n+2],y=r[n+3];if(0===o)return t[e+0]=a,t[e+1]=h,t[e+2]=c,void(t[e+3]=u);if(1===o)return t[e+0]=l,t[e+1]=d,t[e+2]=m,void(t[e+3]=y);if(u!==y||a!==l||h!==d||c!==m){let t=1-o;const e=a*l+h*d+c*m+u*y,s=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),n=Math.atan2(r,e*s);t=Math.sin(t*n)/r,o=Math.sin(o*n)/r}const r=o*s;if(a=a*t+l*r,h=h*t+d*r,c=c*t+m*r,u=u*t+y*r,t===1-o){const t=1/Math.sqrt(a*a+h*h+c*c+u*u);a*=t,h*=t,c*=t,u*=t}}t[e]=a,t[e+1]=h,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,s,i,r,n){const o=s[i],a=s[i+1],h=s[i+2],c=s[i+3],u=r[n],l=r[n+1],d=r[n+2],m=r[n+3];return t[e]=o*m+c*u+a*d-h*l,t[e+1]=a*m+c*l+h*u-o*d,t[e+2]=h*m+c*d+o*l-a*u,t[e+3]=c*m-o*u-a*l-h*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,s,i){return this._x=t,this._y=e,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){const s=t._x,i=t._y,r=t._z,n=t._order,o=Math.cos,a=Math.sin,h=o(s/2),c=o(i/2),u=o(r/2),l=a(s/2),d=a(i/2),m=a(r/2);switch(n){case"XYZ":this._x=l*c*u+h*d*m,this._y=h*d*u-l*c*m,this._z=h*c*m+l*d*u,this._w=h*c*u-l*d*m;break;case"YXZ":this._x=l*c*u+h*d*m,this._y=h*d*u-l*c*m,this._z=h*c*m-l*d*u,this._w=h*c*u+l*d*m;break;case"ZXY":this._x=l*c*u-h*d*m,this._y=h*d*u+l*c*m,this._z=h*c*m+l*d*u,this._w=h*c*u-l*d*m;break;case"ZYX":this._x=l*c*u-h*d*m,this._y=h*d*u+l*c*m,this._z=h*c*m-l*d*u,this._w=h*c*u+l*d*m;break;case"YZX":this._x=l*c*u+h*d*m,this._y=h*d*u+l*c*m,this._z=h*c*m-l*d*u,this._w=h*c*u-l*d*m;break;case"XZY":this._x=l*c*u-h*d*m,this._y=h*d*u-l*c*m,this._z=h*c*m+l*d*u,this._w=h*c*u+l*d*m;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+n)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const s=e/2,i=Math.sin(s);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,s=e[0],i=e[4],r=e[8],n=e[1],o=e[5],a=e[9],h=e[2],c=e[6],u=e[10],l=s+o+u;if(l>0){const t=.5/Math.sqrt(l+1);this._w=.25/t,this._x=(c-a)*t,this._y=(r-h)*t,this._z=(n-i)*t}else if(s>o&&s>u){const t=2*Math.sqrt(1+s-o-u);this._w=(c-a)/t,this._x=.25*t,this._y=(i+n)/t,this._z=(r+h)/t}else if(o>u){const t=2*Math.sqrt(1+o-s-u);this._w=(r-h)/t,this._x=(i+n)/t,this._y=.25*t,this._z=(a+c)/t}else{const t=2*Math.sqrt(1+u-s-o);this._w=(n-i)/t,this._x=(r+h)/t,this._y=(a+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let s=t.dot(e)+1;return s<Number.EPSILON?(s=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=s):(this._x=0,this._y=-t.z,this._z=t.y,this._w=s)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=s),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(o(this.dot(t),-1,1)))}rotateTowards(t,e){const s=this.angleTo(t);if(0===s)return this;const i=Math.min(1,e/s);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const s=t._x,i=t._y,r=t._z,n=t._w,o=e._x,a=e._y,h=e._z,c=e._w;return this._x=s*c+n*o+i*h-r*a,this._y=i*c+n*a+r*o-s*h,this._z=r*c+n*h+s*a-i*o,this._w=n*c-s*o-i*a-r*h,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const s=this._x,i=this._y,r=this._z,n=this._w;let o=n*t._w+s*t._x+i*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=n,this._x=s,this._y=i,this._z=r,this;const a=1-o*o;if(a<=Number.EPSILON){const t=1-e;return this._w=t*n+e*this._w,this._x=t*s+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(a),c=Math.atan2(h,o),u=Math.sin((1-e)*c)/h,l=Math.sin(e*c)/h;return this._w=n*u+this._w*l,this._x=s*u+this._x*l,this._y=i*u+this._y*l,this._z=r*u+this._z*l,this._onChangeCallback(),this}slerpQuaternions(t,e,s){return this.copy(t).slerp(e,s)}random(){const t=Math.random(),e=Math.sqrt(1-t),s=Math.sqrt(t),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(i),s*Math.sin(r),s*Math.cos(r),e*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class M{constructor(t=0,e=0,s=0){M.prototype.isVector3=!0,this.x=t,this.y=e,this.z=s}set(t,e,s){return void 0===s&&(s=this.z),this.x=t,this.y=e,this.z=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(z.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(z.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*s+r[6]*i,this.y=r[1]*e+r[4]*s+r[7]*i,this.z=r[2]*e+r[5]*s+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,r=t.elements,n=1/(r[3]*e+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*s+r[8]*i+r[12])*n,this.y=(r[1]*e+r[5]*s+r[9]*i+r[13])*n,this.z=(r[2]*e+r[6]*s+r[10]*i+r[14])*n,this}applyQuaternion(t){const e=this.x,s=this.y,i=this.z,r=t.x,n=t.y,o=t.z,a=t.w,h=a*e+n*i-o*s,c=a*s+o*e-r*i,u=a*i+r*s-n*e,l=-r*e-n*s-o*i;return this.x=h*a+l*-r+c*-o-u*-n,this.y=c*a+l*-n+u*-r-h*-o,this.z=u*a+l*-o+h*-n-c*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*s+r[8]*i,this.y=r[1]*e+r[5]*s+r[9]*i,this.z=r[2]*e+r[6]*s+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(t,Math.min(e,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const s=t.x,i=t.y,r=t.z,n=e.x,o=e.y,a=e.z;return this.x=i*a-r*o,this.y=r*n-s*a,this.z=s*o-i*n,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const s=t.dot(this)/e;return this.copy(t).multiplyScalar(s)}projectOnPlane(t){return _.copy(this).projectOnVector(t),this.sub(_)}reflect(t){return this.sub(_.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(o(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y,i=this.z-t.z;return e*e+s*s+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,s){const i=Math.sin(e)*t;return this.x=i*Math.sin(s),this.y=Math.cos(e)*t,this.z=i*Math.cos(s),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,s){return this.x=t*Math.sin(e),this.y=s,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),s=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=s,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,s=Math.sqrt(1-t**2);return this.x=s*Math.cos(e),this.y=s*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _=new M,z=new w;class A{constructor(t=new M(1/0,1/0,1/0),e=new M(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,s=1/0,i=1/0,r=-1/0,n=-1/0,o=-1/0;for(let a=0,h=t.length;a<h;a+=3){const h=t[a],c=t[a+1],u=t[a+2];h<e&&(e=h),c<s&&(s=c),u<i&&(i=u),h>r&&(r=h),c>n&&(n=c),u>o&&(o=u)}return this.min.set(e,s,i),this.max.set(r,n,o),this}setFromBufferAttribute(t){let e=1/0,s=1/0,i=1/0,r=-1/0,n=-1/0,o=-1/0;for(let a=0,h=t.count;a<h;a++){const h=t.getX(a),c=t.getY(a),u=t.getZ(a);h<e&&(e=h),c<s&&(s=c),u<i&&(i=u),h>r&&(r=h),c>n&&(n=c),u>o&&(o=u)}return this.min.set(e,s,i),this.max.set(r,n,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const s=S.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const s=t.geometry;if(void 0!==s)if(e&&null!=s.attributes&&void 0!==s.attributes.position){const e=s.attributes.position;for(let s=0,i=e.count;s<i;s++)S.fromBufferAttribute(e,s).applyMatrix4(t.matrixWorld),this.expandByPoint(S)}else null===s.boundingBox&&s.computeBoundingBox(),T.copy(s.boundingBox),T.applyMatrix4(t.matrixWorld),this.union(T);const i=t.children;for(let r=0,n=i.length;r<n;r++)this.expandByObject(i[r],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,S),S.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,s;return t.normal.x>0?(e=t.normal.x*this.min.x,s=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,s=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,s+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,s+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,s+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,s+=t.normal.z*this.min.z),e<=-t.constant&&s>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(U),V.subVectors(this.max,U),v.subVectors(t.a,U),P.subVectors(t.b,U),F.subVectors(t.c,U),E.subVectors(P,v),C.subVectors(F,P),k.subVectors(v,F);let e=[0,-E.z,E.y,0,-C.z,C.y,0,-k.z,k.y,E.z,0,-E.x,C.z,0,-C.x,k.z,0,-k.x,-E.y,E.x,0,-C.y,C.x,0,-k.y,k.x,0];return!!q(e,v,P,F,V)&&(e=[1,0,0,0,1,0,0,0,1],!!q(e,v,P,F,V)&&(R.crossVectors(E,C),e=[R.x,R.y,R.z],q(e,v,P,F,V)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return S.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(S).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(B[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),B[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),B[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),B[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),B[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),B[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),B[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),B[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(B)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const B=[new M,new M,new M,new M,new M,new M,new M,new M],S=new M,T=new A,v=new M,P=new M,F=new M,E=new M,C=new M,k=new M,U=new M,V=new M,R=new M,O=new M;function q(t,e,s,i,r){for(let n=0,o=t.length-3;n<=o;n+=3){O.fromArray(t,n);const o=r.x*Math.abs(O.x)+r.y*Math.abs(O.y)+r.z*Math.abs(O.z),a=e.dot(O),h=s.dot(O),c=i.dot(O);if(Math.max(-Math.max(a,h,c),Math.min(a,h,c))>o)return!1}return!0}const I=new A,N=new M,D=new M;class X{constructor(t=new M,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const s=this.center;void 0!==e?s.copy(e):I.setFromPoints(t).getCenter(s);let i=0;for(let r=0,n=t.length;r<n;r++)i=Math.max(i,s.distanceToSquared(t[r]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const s=this.center.distanceToSquared(t);return e.copy(t),s>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;N.subVectors(t,this.center);const e=N.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),s=.5*(t-this.radius);this.center.addScaledVector(N,s/t),this.radius+=s}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(D.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(N.copy(t.center).add(D)),this.expandByPoint(N.copy(t.center).sub(D))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}class L{constructor(){L.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(t,e,s,i,r,n,o,a,h,c,u,l,d,m,y,p){const x=this.elements;return x[0]=t,x[4]=e,x[8]=s,x[12]=i,x[1]=r,x[5]=n,x[9]=o,x[13]=a,x[2]=h,x[6]=c,x[10]=u,x[14]=l,x[3]=d,x[7]=m,x[11]=y,x[15]=p,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new L).fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,s){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,s=t.elements,i=1/W.setFromMatrixColumn(t,0).length(),r=1/W.setFromMatrixColumn(t,1).length(),n=1/W.setFromMatrixColumn(t,2).length();return e[0]=s[0]*i,e[1]=s[1]*i,e[2]=s[2]*i,e[3]=0,e[4]=s[4]*r,e[5]=s[5]*r,e[6]=s[6]*r,e[7]=0,e[8]=s[8]*n,e[9]=s[9]*n,e[10]=s[10]*n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,s=t.x,i=t.y,r=t.z,n=Math.cos(s),o=Math.sin(s),a=Math.cos(i),h=Math.sin(i),c=Math.cos(r),u=Math.sin(r);if("XYZ"===t.order){const t=n*c,s=n*u,i=o*c,r=o*u;e[0]=a*c,e[4]=-a*u,e[8]=h,e[1]=s+i*h,e[5]=t-r*h,e[9]=-o*a,e[2]=r-t*h,e[6]=i+s*h,e[10]=n*a}else if("YXZ"===t.order){const t=a*c,s=a*u,i=h*c,r=h*u;e[0]=t+r*o,e[4]=i*o-s,e[8]=n*h,e[1]=n*u,e[5]=n*c,e[9]=-o,e[2]=s*o-i,e[6]=r+t*o,e[10]=n*a}else if("ZXY"===t.order){const t=a*c,s=a*u,i=h*c,r=h*u;e[0]=t-r*o,e[4]=-n*u,e[8]=i+s*o,e[1]=s+i*o,e[5]=n*c,e[9]=r-t*o,e[2]=-n*h,e[6]=o,e[10]=n*a}else if("ZYX"===t.order){const t=n*c,s=n*u,i=o*c,r=o*u;e[0]=a*c,e[4]=i*h-s,e[8]=t*h+r,e[1]=a*u,e[5]=r*h+t,e[9]=s*h-i,e[2]=-h,e[6]=o*a,e[10]=n*a}else if("YZX"===t.order){const t=n*a,s=n*h,i=o*a,r=o*h;e[0]=a*c,e[4]=r-t*u,e[8]=i*u+s,e[1]=u,e[5]=n*c,e[9]=-o*c,e[2]=-h*c,e[6]=s*u+i,e[10]=t-r*u}else if("XZY"===t.order){const t=n*a,s=n*h,i=o*a,r=o*h;e[0]=a*c,e[4]=-u,e[8]=h*c,e[1]=t*u+r,e[5]=n*c,e[9]=s*u-i,e[2]=i*u-s,e[6]=o*c,e[10]=r*u+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Z,t,j)}lookAt(t,e,s){const i=this.elements;return J.subVectors(t,e),0===J.lengthSq()&&(J.z=1),J.normalize(),H.crossVectors(s,J),0===H.lengthSq()&&(1===Math.abs(s.z)?J.x+=1e-4:J.z+=1e-4,J.normalize(),H.crossVectors(s,J)),H.normalize(),G.crossVectors(J,H),i[0]=H.x,i[4]=G.x,i[8]=J.x,i[1]=H.y,i[5]=G.y,i[9]=J.y,i[2]=H.z,i[6]=G.z,i[10]=J.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,n=s[0],o=s[4],a=s[8],h=s[12],c=s[1],u=s[5],l=s[9],d=s[13],m=s[2],y=s[6],p=s[10],x=s[14],f=s[3],g=s[7],b=s[11],w=s[15],M=i[0],_=i[4],z=i[8],A=i[12],B=i[1],S=i[5],T=i[9],v=i[13],P=i[2],F=i[6],E=i[10],C=i[14],k=i[3],U=i[7],V=i[11],R=i[15];return r[0]=n*M+o*B+a*P+h*k,r[4]=n*_+o*S+a*F+h*U,r[8]=n*z+o*T+a*E+h*V,r[12]=n*A+o*v+a*C+h*R,r[1]=c*M+u*B+l*P+d*k,r[5]=c*_+u*S+l*F+d*U,r[9]=c*z+u*T+l*E+d*V,r[13]=c*A+u*v+l*C+d*R,r[2]=m*M+y*B+p*P+x*k,r[6]=m*_+y*S+p*F+x*U,r[10]=m*z+y*T+p*E+x*V,r[14]=m*A+y*v+p*C+x*R,r[3]=f*M+g*B+b*P+w*k,r[7]=f*_+g*S+b*F+w*U,r[11]=f*z+g*T+b*E+w*V,r[15]=f*A+g*v+b*C+w*R,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[4],i=t[8],r=t[12],n=t[1],o=t[5],a=t[9],h=t[13],c=t[2],u=t[6],l=t[10],d=t[14];return t[3]*(+r*a*u-i*h*u-r*o*l+s*h*l+i*o*d-s*a*d)+t[7]*(+e*a*d-e*h*l+r*n*l-i*n*d+i*h*c-r*a*c)+t[11]*(+e*h*u-e*o*d-r*n*u+s*n*d+r*o*c-s*h*c)+t[15]*(-i*o*c-e*a*u+e*o*l+i*n*u-s*n*l+s*a*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,s){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=s),this}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],n=t[4],o=t[5],a=t[6],h=t[7],c=t[8],u=t[9],l=t[10],d=t[11],m=t[12],y=t[13],p=t[14],x=t[15],f=u*p*h-y*l*h+y*a*d-o*p*d-u*a*x+o*l*x,g=m*l*h-c*p*h-m*a*d+n*p*d+c*a*x-n*l*x,b=c*y*h-m*u*h+m*o*d-n*y*d-c*o*x+n*u*x,w=m*u*a-c*y*a-m*o*l+n*y*l+c*o*p-n*u*p,M=e*f+s*g+i*b+r*w;if(0===M)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const _=1/M;return t[0]=f*_,t[1]=(y*l*r-u*p*r-y*i*d+s*p*d+u*i*x-s*l*x)*_,t[2]=(o*p*r-y*a*r+y*i*h-s*p*h-o*i*x+s*a*x)*_,t[3]=(u*a*r-o*l*r-u*i*h+s*l*h+o*i*d-s*a*d)*_,t[4]=g*_,t[5]=(c*p*r-m*l*r+m*i*d-e*p*d-c*i*x+e*l*x)*_,t[6]=(m*a*r-n*p*r-m*i*h+e*p*h+n*i*x-e*a*x)*_,t[7]=(n*l*r-c*a*r+c*i*h-e*l*h-n*i*d+e*a*d)*_,t[8]=b*_,t[9]=(m*u*r-c*y*r-m*s*d+e*y*d+c*s*x-e*u*x)*_,t[10]=(n*y*r-m*o*r+m*s*h-e*y*h-n*s*x+e*o*x)*_,t[11]=(c*o*r-n*u*r-c*s*h+e*u*h+n*s*d-e*o*d)*_,t[12]=w*_,t[13]=(c*y*i-m*u*i+m*s*l-e*y*l-c*s*p+e*u*p)*_,t[14]=(m*o*i-n*y*i-m*s*a+e*y*a+n*s*p-e*o*p)*_,t[15]=(n*u*i-c*o*i+c*s*a-e*u*a-n*s*l+e*o*l)*_,this}scale(t){const e=this.elements,s=t.x,i=t.y,r=t.z;return e[0]*=s,e[4]*=i,e[8]*=r,e[1]*=s,e[5]*=i,e[9]*=r,e[2]*=s,e[6]*=i,e[10]*=r,e[3]*=s,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,i))}makeTranslation(t,e,s){return this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),i=Math.sin(e),r=1-s,n=t.x,o=t.y,a=t.z,h=r*n,c=r*o;return this.set(h*n+s,h*o-i*a,h*a+i*o,0,h*o+i*a,c*o+s,c*a-i*n,0,h*a-i*o,c*a+i*n,r*a*a+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,i,r,n){return this.set(1,s,r,0,t,1,n,0,e,i,1,0,0,0,0,1),this}compose(t,e,s){const i=this.elements,r=e._x,n=e._y,o=e._z,a=e._w,h=r+r,c=n+n,u=o+o,l=r*h,d=r*c,m=r*u,y=n*c,p=n*u,x=o*u,f=a*h,g=a*c,b=a*u,w=s.x,M=s.y,_=s.z;return i[0]=(1-(y+x))*w,i[1]=(d+b)*w,i[2]=(m-g)*w,i[3]=0,i[4]=(d-b)*M,i[5]=(1-(l+x))*M,i[6]=(p+f)*M,i[7]=0,i[8]=(m+g)*_,i[9]=(p-f)*_,i[10]=(1-(l+y))*_,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,s){const i=this.elements;let r=W.set(i[0],i[1],i[2]).length();const n=W.set(i[4],i[5],i[6]).length(),o=W.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],Y.copy(this);const a=1/r,h=1/n,c=1/o;return Y.elements[0]*=a,Y.elements[1]*=a,Y.elements[2]*=a,Y.elements[4]*=h,Y.elements[5]*=h,Y.elements[6]*=h,Y.elements[8]*=c,Y.elements[9]*=c,Y.elements[10]*=c,e.setFromRotationMatrix(Y),s.x=r,s.y=n,s.z=o,this}makePerspective(t,e,s,i,r,n){const o=this.elements,a=2*r/(e-t),h=2*r/(s-i),c=(e+t)/(e-t),u=(s+i)/(s-i),l=-(n+r)/(n-r),d=-2*n*r/(n-r);return o[0]=a,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=h,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=l,o[14]=d,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,s,i,r,n){const o=this.elements,a=1/(e-t),h=1/(s-i),c=1/(n-r),u=(e+t)*a,l=(s+i)*h,d=(n+r)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*h,o[9]=0,o[13]=-l,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<16;i++)if(e[i]!==s[i])return!1;return!0}fromArray(t,e=0){for(let s=0;s<16;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}}const W=new M,Y=new L,Z=new M(0,0,0),j=new M(1,1,1),H=new M,G=new M,J=new M,Q=new L,$=new w;class K{constructor(t=0,e=0,s=0,i=K.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=s,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,s,i=this._order){return this._x=t,this._y=e,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,s=!0){const i=t.elements,r=i[0],n=i[4],a=i[8],h=i[1],c=i[5],u=i[9],l=i[2],d=i[6],m=i[10];switch(e){case"XYZ":this._y=Math.asin(o(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,m),this._z=Math.atan2(-n,r)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-o(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,m),this._z=Math.atan2(h,c)):(this._y=Math.atan2(-l,r),this._z=0);break;case"ZXY":this._x=Math.asin(o(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-l,m),this._z=Math.atan2(-n,c)):(this._y=0,this._z=Math.atan2(h,r));break;case"ZYX":this._y=Math.asin(-o(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(d,m),this._z=Math.atan2(h,r)):(this._x=0,this._z=Math.atan2(-n,c));break;case"YZX":this._z=Math.asin(o(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-l,r)):(this._x=0,this._y=Math.atan2(a,m));break;case"XZY":this._z=Math.asin(-o(n,-1,1)),Math.abs(n)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-u,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===s&&this._onChangeCallback(),this}setFromQuaternion(t,e,s){return Q.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Q,e,s)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return $.setFromEuler(this),this.setFromQuaternion($,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}K.DEFAULT_ORDER="XYZ";class tt{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}isEnabled(t){return 0!=(this.mask&(1<<t|0))}}let et=0;const st=new M,it=new w,rt=new L,nt=new M,ot=new M,at=new M,ht=new w,ct=new M(1,0,0),ut=new M(0,1,0),lt=new M(0,0,1),dt={type:"added"},mt={type:"removed"};class yt extends i{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:et++}),this.uuid=n(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=yt.DEFAULT_UP.clone();const t=new M,e=new K,s=new w,i=new M(1,1,1);e._onChange((function(){s.setFromEuler(e,!1)})),s._onChange((function(){e.setFromQuaternion(s,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new L},normalMatrix:{value:new u}}),this.matrix=new L,this.matrixWorld=new L,this.matrixAutoUpdate=yt.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new tt,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return it.setFromAxisAngle(t,e),this.quaternion.multiply(it),this}rotateOnWorldAxis(t,e){return it.setFromAxisAngle(t,e),this.quaternion.premultiply(it),this}rotateX(t){return this.rotateOnAxis(ct,t)}rotateY(t){return this.rotateOnAxis(ut,t)}rotateZ(t){return this.rotateOnAxis(lt,t)}translateOnAxis(t,e){return st.copy(t).applyQuaternion(this.quaternion),this.position.add(st.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(ct,t)}translateY(t){return this.translateOnAxis(ut,t)}translateZ(t){return this.translateOnAxis(lt,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(rt.copy(this.matrixWorld).invert())}lookAt(t,e,s){t.isVector3?nt.copy(t):nt.set(t,e,s);const i=this.parent;this.updateWorldMatrix(!0,!1),ot.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?rt.lookAt(ot,nt,this.up):rt.lookAt(nt,ot,this.up),this.quaternion.setFromRotationMatrix(rt),i&&(rt.extractRotation(i.matrixWorld),it.setFromRotationMatrix(rt),this.quaternion.premultiply(it.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(dt)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(mt)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(mt)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),rt.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),rt.multiply(t.parent.matrixWorld)),t.applyMatrix4(rt),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let s=0,i=this.children.length;s<i;s++){const i=this.children[s].getObjectByProperty(t,e);if(void 0!==i)return i}}getObjectsByProperty(t,e){let s=[];this[t]===e&&s.push(this);for(let i=0,r=this.children.length;i<r;i++){const r=this.children[i].getObjectsByProperty(t,e);r.length>0&&(s=s.concat(r))}return s}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ot,t,at),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ot,ht,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let s=0,i=e.length;s<i;s++){const i=e[s];!0!==i.matrixWorldAutoUpdate&&!0!==t||i.updateMatrixWorld(t)}}updateWorldMatrix(t,e){const s=this.parent;if(!0===t&&null!==s&&!0===s.matrixWorldAutoUpdate&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,s=t.length;e<s;e++){const s=t[e];!0===s.matrixWorldAutoUpdate&&s.updateWorldMatrix(!1,!0)}}}toJSON(t){const e=void 0===t||"string"==typeof t,s={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,s){return void 0===e[s.uuid]&&(e[s.uuid]=s.toJSON(t)),s.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(i.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const s=e.shapes;if(Array.isArray(s))for(let e=0,i=s.length;e<i;e++){const i=s[e];r(t.shapes,i)}else r(t.shapes,s)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let s=0,i=this.material.length;s<i;s++)e.push(r(t.materials,this.material[s]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++){const s=this.animations[e];i.animations.push(r(t.animations,s))}}if(e){const e=n(t.geometries),i=n(t.materials),r=n(t.textures),o=n(t.images),a=n(t.shapes),h=n(t.skeletons),c=n(t.animations),u=n(t.nodes);e.length>0&&(s.geometries=e),i.length>0&&(s.materials=i),r.length>0&&(s.textures=r),o.length>0&&(s.images=o),a.length>0&&(s.shapes=a),h.length>0&&(s.skeletons=h),c.length>0&&(s.animations=c),u.length>0&&(s.nodes=u)}return s.object=i,s;function n(t){const e=[];for(const s in t){const i=t[s];delete i.metadata,e.push(i)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let s=0;s<t.children.length;s++){const e=t.children[s];this.add(e.clone())}return this}}yt.DEFAULT_UP=new M(0,1,0),yt.DEFAULT_MATRIX_AUTO_UPDATE=!0,yt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const pt=new M,xt=new M,ft=new M,gt=new M,bt=new M,wt=new M,Mt=new M,_t=new M,zt=new M,At=new M;class Bt{constructor(t=new M,e=new M,s=new M){this.a=t,this.b=e,this.c=s}static getNormal(t,e,s,i){i.subVectors(s,e),pt.subVectors(t,e),i.cross(pt);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,s,i,r){pt.subVectors(i,e),xt.subVectors(s,e),ft.subVectors(t,e);const n=pt.dot(pt),o=pt.dot(xt),a=pt.dot(ft),h=xt.dot(xt),c=xt.dot(ft),u=n*h-o*o;if(0===u)return r.set(-2,-1,-1);const l=1/u,d=(h*a-o*c)*l,m=(n*c-o*a)*l;return r.set(1-d-m,m,d)}static containsPoint(t,e,s,i){return this.getBarycoord(t,e,s,i,gt),gt.x>=0&&gt.y>=0&&gt.x+gt.y<=1}static getUV(t,e,s,i,r,n,o,a){return this.getBarycoord(t,e,s,i,gt),a.set(0,0),a.addScaledVector(r,gt.x),a.addScaledVector(n,gt.y),a.addScaledVector(o,gt.z),a}static isFrontFacing(t,e,s,i){return pt.subVectors(s,e),xt.subVectors(t,e),pt.cross(xt).dot(i)<0}set(t,e,s){return this.a.copy(t),this.b.copy(e),this.c.copy(s),this}setFromPointsAndIndices(t,e,s,i){return this.a.copy(t[e]),this.b.copy(t[s]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,s,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,s),this.c.fromBufferAttribute(t,i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return pt.subVectors(this.c,this.b),xt.subVectors(this.a,this.b),.5*pt.cross(xt).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Bt.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Bt.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,s,i,r){return Bt.getUV(t,this.a,this.b,this.c,e,s,i,r)}containsPoint(t){return Bt.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Bt.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const s=this.a,i=this.b,r=this.c;let n,o;bt.subVectors(i,s),wt.subVectors(r,s),_t.subVectors(t,s);const a=bt.dot(_t),h=wt.dot(_t);if(a<=0&&h<=0)return e.copy(s);zt.subVectors(t,i);const c=bt.dot(zt),u=wt.dot(zt);if(c>=0&&u<=c)return e.copy(i);const l=a*u-c*h;if(l<=0&&a>=0&&c<=0)return n=a/(a-c),e.copy(s).addScaledVector(bt,n);At.subVectors(t,r);const d=bt.dot(At),m=wt.dot(At);if(m>=0&&d<=m)return e.copy(r);const y=d*h-a*m;if(y<=0&&h>=0&&m<=0)return o=h/(h-m),e.copy(s).addScaledVector(wt,o);const p=c*m-d*u;if(p<=0&&u-c>=0&&d-m>=0)return Mt.subVectors(r,i),o=(u-c)/(u-c+(d-m)),e.copy(i).addScaledVector(Mt,o);const x=1/(p+y+l);return n=y*x,o=l*x,e.copy(s).addScaledVector(bt,n).addScaledVector(wt,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const St=new M,Tt=new c;class vt{constructor(t,e,s=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=s,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,s){t*=this.itemSize,s*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[s+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,s=this.count;e<s;e++)Tt.fromBufferAttribute(this,e),Tt.applyMatrix3(t),this.setXY(e,Tt.x,Tt.y);else if(3===this.itemSize)for(let e=0,s=this.count;e<s;e++)St.fromBufferAttribute(this,e),St.applyMatrix3(t),this.setXYZ(e,St.x,St.y,St.z);return this}applyMatrix4(t){for(let e=0,s=this.count;e<s;e++)St.fromBufferAttribute(this,e),St.applyMatrix4(t),this.setXYZ(e,St.x,St.y,St.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)St.fromBufferAttribute(this,e),St.applyNormalMatrix(t),this.setXYZ(e,St.x,St.y,St.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)St.fromBufferAttribute(this,e),St.transformDirection(t),this.setXYZ(e,St.x,St.y,St.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=a(e,this.array)),e}setX(t,e){return this.normalized&&(e=h(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=a(e,this.array)),e}setY(t,e){return this.normalized&&(e=h(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=a(e,this.array)),e}setZ(t,e){return this.normalized&&(e=h(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=a(e,this.array)),e}setW(t,e){return this.normalized&&(e=h(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,s){return t*=this.itemSize,this.normalized&&(e=h(e,this.array),s=h(s,this.array)),this.array[t+0]=e,this.array[t+1]=s,this}setXYZ(t,e,s,i){return t*=this.itemSize,this.normalized&&(e=h(e,this.array),s=h(s,this.array),i=h(i,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this}setXYZW(t,e,s,i,r){return t*=this.itemSize,this.normalized&&(e=h(e,this.array),s=h(s,this.array),i=h(i,this.array),r=h(r,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),35044!==this.usage&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class Pt extends vt{constructor(t,e,s){super(new Uint16Array(t),e,s)}}class Ft extends vt{constructor(t,e,s){super(new Uint32Array(t),e,s)}}class Et extends vt{constructor(t,e,s){super(new Float32Array(t),e,s)}}let Ct=0;const kt=new L,Ut=new yt,Vt=new M,Rt=new A,Ot=new A,qt=new M;class It extends i{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Ct++}),this.uuid=n(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(function(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}(t)?Ft:Pt)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,s=0){this.groups.push({start:t,count:e,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const s=this.attributes.normal;if(void 0!==s){const e=(new u).getNormalMatrix(t);s.applyNormalMatrix(e),s.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return kt.makeRotationFromQuaternion(t),this.applyMatrix4(kt),this}rotateX(t){return kt.makeRotationX(t),this.applyMatrix4(kt),this}rotateY(t){return kt.makeRotationY(t),this.applyMatrix4(kt),this}rotateZ(t){return kt.makeRotationZ(t),this.applyMatrix4(kt),this}translate(t,e,s){return kt.makeTranslation(t,e,s),this.applyMatrix4(kt),this}scale(t,e,s){return kt.makeScale(t,e,s),this.applyMatrix4(kt),this}lookAt(t){return Ut.lookAt(t),Ut.updateMatrix(),this.applyMatrix4(Ut.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Vt).negate(),this.translate(Vt.x,Vt.y,Vt.z),this}setFromPoints(t){const e=[];for(let s=0,i=t.length;s<i;s++){const i=t[s];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new Et(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new A);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new M(-1/0,-1/0,-1/0),new M(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let s=0,i=e.length;s<i;s++){const t=e[s];Rt.setFromBufferAttribute(t),this.morphTargetsRelative?(qt.addVectors(this.boundingBox.min,Rt.min),this.boundingBox.expandByPoint(qt),qt.addVectors(this.boundingBox.max,Rt.max),this.boundingBox.expandByPoint(qt)):(this.boundingBox.expandByPoint(Rt.min),this.boundingBox.expandByPoint(Rt.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new X);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new M,1/0);if(t){const s=this.boundingSphere.center;if(Rt.setFromBufferAttribute(t),e)for(let t=0,r=e.length;t<r;t++){const s=e[t];Ot.setFromBufferAttribute(s),this.morphTargetsRelative?(qt.addVectors(Rt.min,Ot.min),Rt.expandByPoint(qt),qt.addVectors(Rt.max,Ot.max),Rt.expandByPoint(qt)):(Rt.expandByPoint(Ot.min),Rt.expandByPoint(Ot.max))}Rt.getCenter(s);let i=0;for(let e=0,r=t.count;e<r;e++)qt.fromBufferAttribute(t,e),i=Math.max(i,s.distanceToSquared(qt));if(e)for(let r=0,n=e.length;r<n;r++){const n=e[r],o=this.morphTargetsRelative;for(let e=0,r=n.count;e<r;e++)qt.fromBufferAttribute(n,e),o&&(Vt.fromBufferAttribute(t,e),qt.add(Vt)),i=Math.max(i,s.distanceToSquared(qt))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const s=t.array,i=e.position.array,r=e.normal.array,n=e.uv.array,o=i.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new vt(new Float32Array(4*o),4));const a=this.getAttribute("tangent").array,h=[],u=[];for(let c=0;c<o;c++)h[c]=new M,u[c]=new M;const l=new M,d=new M,m=new M,y=new c,p=new c,x=new c,f=new M,g=new M;function b(t,e,s){l.fromArray(i,3*t),d.fromArray(i,3*e),m.fromArray(i,3*s),y.fromArray(n,2*t),p.fromArray(n,2*e),x.fromArray(n,2*s),d.sub(l),m.sub(l),p.sub(y),x.sub(y);const r=1/(p.x*x.y-x.x*p.y);isFinite(r)&&(f.copy(d).multiplyScalar(x.y).addScaledVector(m,-p.y).multiplyScalar(r),g.copy(m).multiplyScalar(p.x).addScaledVector(d,-x.x).multiplyScalar(r),h[t].add(f),h[e].add(f),h[s].add(f),u[t].add(g),u[e].add(g),u[s].add(g))}let w=this.groups;0===w.length&&(w=[{start:0,count:s.length}]);for(let c=0,M=w.length;c<M;++c){const t=w[c],e=t.start;for(let i=e,r=e+t.count;i<r;i+=3)b(s[i+0],s[i+1],s[i+2])}const _=new M,z=new M,A=new M,B=new M;function S(t){A.fromArray(r,3*t),B.copy(A);const e=h[t];_.copy(e),_.sub(A.multiplyScalar(A.dot(e))).normalize(),z.crossVectors(B,e);const s=z.dot(u[t])<0?-1:1;a[4*t]=_.x,a[4*t+1]=_.y,a[4*t+2]=_.z,a[4*t+3]=s}for(let c=0,M=w.length;c<M;++c){const t=w[c],e=t.start;for(let i=e,r=e+t.count;i<r;i+=3)S(s[i+0]),S(s[i+1]),S(s[i+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let s=this.getAttribute("normal");if(void 0===s)s=new vt(new Float32Array(3*e.count),3),this.setAttribute("normal",s);else for(let t=0,e=s.count;t<e;t++)s.setXYZ(t,0,0,0);const i=new M,r=new M,n=new M,o=new M,a=new M,h=new M,c=new M,u=new M;if(t)for(let l=0,d=t.count;l<d;l+=3){const d=t.getX(l+0),m=t.getX(l+1),y=t.getX(l+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,m),n.fromBufferAttribute(e,y),c.subVectors(n,r),u.subVectors(i,r),c.cross(u),o.fromBufferAttribute(s,d),a.fromBufferAttribute(s,m),h.fromBufferAttribute(s,y),o.add(c),a.add(c),h.add(c),s.setXYZ(d,o.x,o.y,o.z),s.setXYZ(m,a.x,a.y,a.z),s.setXYZ(y,h.x,h.y,h.z)}else for(let t=0,l=e.count;t<l;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),n.fromBufferAttribute(e,t+2),c.subVectors(n,r),u.subVectors(i,r),c.cross(u),s.setXYZ(t+0,c.x,c.y,c.z),s.setXYZ(t+1,c.x,c.y,c.z),s.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),s.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,s=t.count;e<s;e++)qt.fromBufferAttribute(t,e),qt.normalize(),t.setXYZ(e,qt.x,qt.y,qt.z)}toNonIndexed(){function t(t,e){const s=t.array,i=t.itemSize,r=t.normalized,n=new s.constructor(e.length*i);let o=0,a=0;for(let h=0,c=e.length;h<c;h++){o=t.isInterleavedBufferAttribute?e[h]*t.data.stride+t.offset:e[h]*i;for(let t=0;t<i;t++)n[a++]=s[o++]}return new vt(n,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new It,s=this.index.array,i=this.attributes;for(const o in i){const r=t(i[o],s);e.setAttribute(o,r)}const r=this.morphAttributes;for(const o in r){const i=[],n=r[o];for(let e=0,r=n.length;e<r;e++){const r=t(n[e],s);i.push(r)}e.morphAttributes[o]=i}e.morphTargetsRelative=this.morphTargetsRelative;const n=this.groups;for(let o=0,a=n.length;o<a;o++){const t=n[o];e.addGroup(t.start,t.count,t.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const s in e)void 0!==e[s]&&(t[s]=e[s]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const s=this.attributes;for(const a in s){const e=s[a];t.data.attributes[a]=e.toJSON(t.data)}const i={};let r=!1;for(const a in this.morphAttributes){const e=this.morphAttributes[a],s=[];for(let i=0,r=e.length;i<r;i++){const r=e[i];s.push(r.toJSON(t.data))}s.length>0&&(i[a]=s,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const n=this.groups;n.length>0&&(t.data.groups=JSON.parse(JSON.stringify(n)));const o=this.boundingSphere;return null!==o&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const s=t.index;null!==s&&this.setIndex(s.clone(e));const i=t.attributes;for(const h in i){const t=i[h];this.setAttribute(h,t.clone(e))}const r=t.morphAttributes;for(const h in r){const t=[],s=r[h];for(let i=0,r=s.length;i<r;i++)t.push(s[i].clone(e));this.morphAttributes[h]=t}this.morphTargetsRelative=t.morphTargetsRelative;const n=t.groups;for(let h=0,c=n.length;h<c;h++){const t=n[h];this.addGroup(t.start,t.count,t.materialIndex)}const o=t.boundingBox;null!==o&&(this.boundingBox=o.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const Nt=new M,Dt=new M,Xt=new u;class Lt{constructor(t=new M(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,s,i){return this.normal.set(t,e,s),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,s){const i=Nt.subVectors(s,e).cross(Dt.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const s=t.delta(Nt),i=this.normal.dot(s);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(s).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),s=this.distanceToPoint(t.end);return e<0&&s>0||s<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const s=e||Xt.getNormalMatrix(t),i=this.coplanarPoint(Nt).applyMatrix4(t),r=this.normal.applyMatrix3(s).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const Wt=new M,Yt=new M;class Zt{constructor(t=new M,e=new M){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){Wt.subVectors(t,this.start),Yt.subVectors(this.end,this.start);const s=Yt.dot(Yt);let i=Yt.dot(Wt)/s;return e&&(i=o(i,0,1)),i}closestPointToPoint(t,e,s){const i=this.closestPointToPointParameter(t,e);return this.delta(s).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"149"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="149");const jt=0,Ht=1,Gt=2,Jt=1.25,Qt=1,$t=65535,Kt=Math.pow(2,-24);class te{constructor(){}}function ee(t,e,s){return s.min.x=e[t],s.min.y=e[t+1],s.min.z=e[t+2],s.max.x=e[t+3],s.max.y=e[t+4],s.max.z=e[t+5],s}function se(t){let e=-1,s=-1/0;for(let i=0;i<3;i++){const r=t[i+3]-t[i];r>s&&(s=r,e=i)}return e}function ie(t,e){e.set(t)}function re(t,e,s){let i,r;for(let n=0;n<3;n++){const o=n+3;i=t[n],r=e[n],s[n]=i<r?i:r,i=t[o],r=e[o],s[o]=i>r?i:r}}function ne(t,e,s){for(let i=0;i<3;i++){const r=e[t+2*i],n=e[t+2*i+1],o=r-n,a=r+n;o<s[i]&&(s[i]=o),a>s[i+3]&&(s[i+3]=a)}}function oe(t){const e=t[3]-t[0],s=t[4]-t[1],i=t[5]-t[2];return 2*(e*s+s*i+i*e)}function ae(t,e,s,i,r=null){let n=1/0,o=1/0,a=1/0,h=-1/0,c=-1/0,u=-1/0,l=1/0,d=1/0,m=1/0,y=-1/0,p=-1/0,x=-1/0;const f=null!==r;for(let g=6*e,b=6*(e+s);g<b;g+=6){const e=t[g+0],s=t[g+1],i=e-s,r=e+s;i<n&&(n=i),r>h&&(h=r),f&&e<l&&(l=e),f&&e>y&&(y=e);const b=t[g+2],w=t[g+3],M=b-w,_=b+w;M<o&&(o=M),_>c&&(c=_),f&&b<d&&(d=b),f&&b>p&&(p=b);const z=t[g+4],A=t[g+5],B=z-A,S=z+A;B<a&&(a=B),S>u&&(u=S),f&&z<m&&(m=z),f&&z>x&&(x=z)}i[0]=n,i[1]=o,i[2]=a,i[3]=h,i[4]=c,i[5]=u,f&&(r[0]=l,r[1]=d,r[2]=m,r[3]=y,r[4]=p,r[5]=x)}const he=32,ce=(t,e)=>t.candidate-e.candidate,ue=new Array(he).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),le=new Float32Array(6);function de(t,e){function s(t){d&&d(t/m)}function i(e,r,d,m=null,p=0){if(!y&&p>=h&&(y=!0,c&&(console.warn(`MeshBVH: Max depth of ${h} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),d<=u||p>=h)return s(r+d),e.offset=r,e.count=d,e;const x=function(t,e,s,i,r,n){let o=-1,a=0;if(n===jt)o=se(e),-1!==o&&(a=(e[o]+e[o+3])/2);else if(n===Ht)o=se(t),-1!==o&&(a=function(t,e,s,i){let r=0;for(let n=e,o=e+s;n<o;n++)r+=t[6*n+2*i];return r/s}(s,i,r,o));else if(n===Gt){const n=oe(t);let h=Jt*r;const c=6*i,u=6*(i+r);for(let t=0;t<3;t++){const i=e[t],l=(e[t+3]-i)/he;if(r<he/4){const e=[...ue];e.length=r;let i=0;for(let r=c;r<u;r+=6,i++){const n=e[i];n.candidate=s[r+2*t],n.count=0;const{bounds:o,leftCacheBounds:a,rightCacheBounds:h}=n;for(let t=0;t<3;t++)h[t]=1/0,h[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0;ne(r,s,o)}e.sort(ce);let l=r;for(let t=0;t<l;t++){const s=e[t];for(;t+1<l&&e[t+1].candidate===s.candidate;)e.splice(t+1,1),l--}for(let r=c;r<u;r+=6){const i=s[r+2*t];for(let t=0;t<l;t++){const n=e[t];i>=n.candidate?ne(r,s,n.rightCacheBounds):(ne(r,s,n.leftCacheBounds),n.count++)}}for(let s=0;s<l;s++){const i=e[s],c=i.count,u=r-i.count,l=i.leftCacheBounds,d=i.rightCacheBounds;let m=0;0!==c&&(m=oe(l)/n);let y=0;0!==u&&(y=oe(d)/n);const p=Qt+Jt*(m*c+y*u);p<h&&(o=t,h=p,a=i.candidate)}}else{for(let t=0;t<he;t++){const e=ue[t];e.count=0,e.candidate=i+l+t*l;const s=e.bounds;for(let t=0;t<3;t++)s[t]=1/0,s[t+3]=-1/0}for(let r=c;r<u;r+=6){let e=~~((s[r+2*t]-i)/l);e>=he&&(e=he-1);const n=ue[e];n.count++,ne(r,s,n.bounds)}const e=ue[he-1];ie(e.bounds,e.rightCacheBounds);for(let t=he-2;t>=0;t--){const e=ue[t],s=ue[t+1];re(e.bounds,s.rightCacheBounds,e.rightCacheBounds)}let d=0;for(let s=0;s<he-1;s++){const e=ue[s],i=e.count,c=e.bounds,u=ue[s+1].rightCacheBounds;0!==i&&(0===d?ie(c,le):re(c,le,le)),d+=i;let l=0,m=0;0!==d&&(l=oe(le)/n);const y=r-d;0!==y&&(m=oe(u)/n);const p=Qt+Jt*(l*d+m*y);p<h&&(o=t,h=p,a=e.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);return{axis:o,pos:a}}(e.boundingData,m,o,r,d,l);if(-1===x.axis)return s(r+d),e.offset=r,e.count=d,e;const f=function(t,e,s,i,r){let n=s,o=s+i-1;const a=r.pos,h=2*r.axis;for(;;){for(;n<=o&&e[6*n+h]<a;)n++;for(;n<=o&&e[6*o+h]>=a;)o--;if(!(n<o))return n;for(let s=0;s<3;s++){let i=t[3*n+s];t[3*n+s]=t[3*o+s],t[3*o+s]=i;let r=e[6*n+2*s+0];e[6*n+2*s+0]=e[6*o+2*s+0],e[6*o+2*s+0]=r;let a=e[6*n+2*s+1];e[6*n+2*s+1]=e[6*o+2*s+1],e[6*o+2*s+1]=a}n++,o--}}(a,o,r,d,x);if(f===r||f===r+d)s(r+d),e.offset=r,e.count=d;else{e.splitAxis=x.axis;const t=new te,s=r,a=f-r;e.left=t,t.boundingData=new Float32Array(6),ae(o,s,a,t.boundingData,n),i(t,s,a,n,p+1);const h=new te,c=f,u=d-a;e.right=h,h.boundingData=new Float32Array(6),ae(o,c,u,h.boundingData,n),i(h,c,u,n,p+1)}return e}!function(t,e){if(!t.index){const s=t.attributes.position.count,i=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let r;r=s>65535?new Uint32Array(new i(4*s)):new Uint16Array(new i(2*s)),t.setIndex(new vt(r,1));for(let t=0;t<s;t++)r[t]=t}}(t,e);const r=new Float32Array(6),n=new Float32Array(6),o=function(t,e){const s=t.attributes.position,i=t.index.array,r=i.length/3,n=new Float32Array(6*r),o=s.normalized,a=s.array,h=s.offset||0;let c=3;s.isInterleavedBufferAttribute&&(c=s.data.stride);const u=["getX","getY","getZ"];for(let l=0;l<r;l++){const t=3*l,r=6*l;let d,m,y;o?(d=i[t+0],m=i[t+1],y=i[t+2]):(d=i[t+0]*c+h,m=i[t+1]*c+h,y=i[t+2]*c+h);for(let i=0;i<3;i++){let t,h,c;o?(t=s[u[i]](d),h=s[u[i]](m),c=s[u[i]](y)):(t=a[d+i],h=a[m+i],c=a[y+i]);let l=t;h<l&&(l=h),c<l&&(l=c);let p=t;h>p&&(p=h),c>p&&(p=c);const x=(p-l)/2,f=2*i;n[r+f+0]=l+x,n[r+f+1]=x+(Math.abs(l)+x)*Kt,l<e[i]&&(e[i]=l),p>e[i+3]&&(e[i+3]=p)}}return n}(t,r),a=t.index.array,h=e.maxDepth,c=e.verbose,u=e.maxLeafTris,l=e.strategy,d=e.onProgress,m=t.index.count/3;let y=!1;const p=[],x=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],s=new Set;for(const r of t.groups)s.add(r.start),s.add(r.start+r.count);const i=Array.from(s.values()).sort(((t,e)=>t-e));for(let r=0;r<i.length-1;r++){const t=i[r],s=i[r+1];e.push({offset:t/3,count:(s-t)/3})}return e}(t);if(1===x.length){const t=x[0],e=new te;e.boundingData=r,function(t,e,s,i){let r=1/0,n=1/0,o=1/0,a=-1/0,h=-1/0,c=-1/0;for(let u=6*e,l=6*(e+s);u<l;u+=6){const e=t[u+0];e<r&&(r=e),e>a&&(a=e);const s=t[u+2];s<n&&(n=s),s>h&&(h=s);const i=t[u+4];i<o&&(o=i),i>c&&(c=i)}i[0]=r,i[1]=n,i[2]=o,i[3]=a,i[4]=h,i[5]=c}(o,t.offset,t.count,n),i(e,t.offset,t.count,n),p.push(e)}else for(let f of x){const t=new te;t.boundingData=new Float32Array(6),ae(o,f.offset,f.count,t.boundingData,n),i(t,f.offset,f.count,n),p.push(t)}return p}class me{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let r=0,n=t.length;r<n;r++){const n=t[r][e];s=n<s?n:s,i=n>i?n:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let r=0,n=e.length;r<n;r++){const n=e[r],o=t.dot(n);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}me.prototype.setFromBox=function(){const t=new M;return function(e,s){const i=s.min,r=s.max;let n=1/0,o=-1/0;for(let a=0;a<=1;a++)for(let s=0;s<=1;s++)for(let h=0;h<=1;h++){t.x=i.x*a+r.x*(1-a),t.y=i.y*s+r.y*(1-s),t.z=i.z*h+r.z*(1-h);const c=e.dot(t);n=Math.min(c,n),o=Math.max(c,o)}this.min=n,this.max=o}}();const ye=function(){const t=new M,e=new M,s=new M;return function(i,r,n){const o=i.start,a=t,h=r.start,c=e;s.subVectors(o,h),t.subVectors(i.end,i.start),e.subVectors(r.end,r.start);const u=s.dot(c),l=c.dot(a),d=c.dot(c),m=s.dot(a),y=a.dot(a)*d-l*l;let p,x;p=0!==y?(u*l-m*d)/y:0,x=(u+p*l)/d,n.x=p,n.y=x}}(),pe=function(){const t=new c,e=new M,s=new M;return function(i,r,n,o){ye(i,r,t);let a=t.x,h=t.y;if(a>=0&&a<=1&&h>=0&&h<=1)return i.at(a,n),void r.at(h,o);if(a>=0&&a<=1)return h<0?r.at(0,o):r.at(1,o),void i.closestPointToPoint(o,!0,n);if(h>=0&&h<=1)return a<0?i.at(0,n):i.at(1,n),void r.closestPointToPoint(n,!0,o);{let t,c;t=a<0?i.start:i.end,c=h<0?r.start:r.end;const u=e,l=s;return i.closestPointToPoint(c,!0,e),r.closestPointToPoint(t,!0,s),u.distanceToSquared(c)<=l.distanceToSquared(t)?(n.copy(u),void o.copy(c)):(n.copy(t),void o.copy(l))}}}(),xe=function(){const t=new M,e=new M,s=new Lt,i=new Zt;return function(r,n){const{radius:o,center:a}=r,{a:h,b:c,c:u}=n;i.start=h,i.end=c;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;i.start=h,i.end=u;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;i.start=c,i.end=u;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;const l=n.getPlane(s);if(Math.abs(l.distanceToPoint(a))<=o){const t=l.projectPoint(a,e);if(n.containsPoint(t))return!0}return!1}}();function fe(t){return Math.abs(t)<1e-15}class ge extends Bt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new M)),this.satBounds=new Array(4).fill().map((()=>new me)),this.points=[this.a,this.b,this.c],this.sphere=new X,this.plane=new Lt,this.needsUpdate=!0}intersectsSphere(t){return xe(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,r=this.satAxes,n=this.satBounds,o=r[0],a=n[0];this.getNormal(o),a.setFromPoints(o,i);const h=r[1],c=n[1];h.subVectors(t,e),c.setFromPoints(h,i);const u=r[2],l=n[2];u.subVectors(e,s),l.setFromPoints(u,i);const d=r[3],m=n[3];d.subVectors(s,t),m.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}ge.prototype.closestPointToSegment=function(){const t=new M,e=new M,s=new Zt;return function(i,r=null,n=null){const{start:o,end:a}=i,h=this.points;let c,u=1/0;for(let l=0;l<3;l++){const o=(l+1)%3;s.start.copy(h[l]),s.end.copy(h[o]),pe(s,i,t,e),c=t.distanceToSquared(e),c<u&&(u=c,r&&r.copy(t),n&&n.copy(e))}return this.closestPointToPoint(o,t),c=o.distanceToSquared(t),c<u&&(u=c,r&&r.copy(t),n&&n.copy(o)),this.closestPointToPoint(a,t),c=a.distanceToSquared(t),c<u&&(u=c,r&&r.copy(t),n&&n.copy(a)),Math.sqrt(u)}}(),ge.prototype.intersectsTriangle=function(){const t=new ge,e=new Array(3),s=new Array(3),i=new me,r=new me,n=new M,o=new M,a=new M,h=new M,c=new Zt,u=new Zt,l=new Zt;return function(d,m=null,y=!1){this.needsUpdate&&this.update(),d.isExtendedTriangle?d.needsUpdate&&d.update():(t.copy(d),t.update(),d=t);const p=this.plane,x=d.plane;if(Math.abs(p.normal.dot(x.normal))>1-1e-10){const t=this.satBounds,o=this.satAxes;s[0]=d.a,s[1]=d.b,s[2]=d.c;for(let e=0;e<4;e++){const r=t[e],n=o[e];if(i.setFromPoints(n,s),r.isSeparated(i))return!1}const a=d.satBounds,h=d.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let s=0;s<4;s++){const t=a[s],r=h[s];if(i.setFromPoints(r,e),t.isSeparated(i))return!1}for(let c=0;c<4;c++){const t=o[c];for(let o=0;o<4;o++){const a=h[o];if(n.crossVectors(t,a),i.setFromPoints(n,e),r.setFromPoints(n,s),i.isSeparated(r))return!1}}return m&&(y||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}{const t=this.points;let e=!1,s=0;for(let a=0;a<3;a++){const i=t[a],r=t[(a+1)%3];c.start.copy(i),c.end.copy(r),c.delta(o);const n=e?u.start:u.end,h=fe(x.distanceToPoint(i));if(fe(x.normal.dot(o))&&h){u.copy(c),s=2;break}if((x.intersectLine(c,n)||h)&&!fe(n.distanceTo(r))){if(s++,e)break;e=!0}}if(1===s&&d.containsPoint(u.end))return m&&(m.start.copy(u.end),m.end.copy(u.end)),!0;if(2!==s)return!1;const i=d.points;let r=!1,n=0;for(let o=0;o<3;o++){const t=i[o],e=i[(o+1)%3];c.start.copy(t),c.end.copy(e),c.delta(a);const s=r?l.start:l.end,h=fe(p.distanceToPoint(t));if(fe(p.normal.dot(a))&&h){l.copy(c),n=2;break}if((p.intersectLine(c,s)||h)&&!fe(s.distanceTo(e))){if(n++,r)break;r=!0}}if(1===n&&this.containsPoint(l.end))return m&&(m.start.copy(l.end),m.end.copy(l.end)),!0;if(2!==n)return!1;if(u.delta(o),l.delta(a),o.dot(a)<0){let t=l.start;l.start=l.end,l.end=t}const y=u.start.dot(o),f=u.end.dot(o),g=l.start.dot(o),b=l.end.dot(o);return(y===b||g===f||f<g!==y<b)&&(m&&(h.subVectors(u.start,l.start),h.dot(o)>0?m.start.copy(u.start):m.start.copy(l.start),h.subVectors(u.end,l.end),h.dot(o)<0?m.end.copy(u.end):m.end.copy(l.end)),!0)}}}(),ge.prototype.distanceToPoint=function(){const t=new M;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),ge.prototype.distanceToTriangle=function(){const t=new M,e=new M,s=["a","b","c"],i=new Zt,r=new Zt;return function(n,o=null,a=null){const h=o||a?i:null;if(this.intersectsTriangle(n,h))return(o||a)&&(o&&h.getCenter(o),a&&h.getCenter(a)),0;let c=1/0;for(let e=0;e<3;e++){let i;const r=s[e],h=n[r];this.closestPointToPoint(h,t),i=h.distanceToSquared(t),i<c&&(c=i,o&&o.copy(t),a&&a.copy(h));const u=this[r];n.closestPointToPoint(u,t),i=u.distanceToSquared(t),i<c&&(c=i,o&&o.copy(u),a&&a.copy(t))}for(let u=0;u<3;u++){const h=s[u],l=s[(u+1)%3];i.set(this[h],this[l]);for(let u=0;u<3;u++){const h=s[u],l=s[(u+1)%3];r.set(n[h],n[l]),pe(i,r,t,e);const d=t.distanceToSquared(e);d<c&&(c=d,o&&o.copy(t),a&&a.copy(e))}}return Math.sqrt(c)}}();class be{constructor(t,e,s){this.isOrientedBox=!0,this.min=new M,this.max=new M,this.matrix=new L,this.invMatrix=new L,this.points=new Array(8).fill().map((()=>new M)),this.satAxes=new Array(3).fill().map((()=>new M)),this.satBounds=new Array(3).fill().map((()=>new me)),this.alignedSatBounds=new Array(3).fill().map((()=>new me)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}be.prototype.update=function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let h=0;h<=1;h++)for(let r=0;r<=1;r++)for(let n=0;n<=1;n++){const o=i[1*h|2*r|4*n];o.x=h?s.x:e.x,o.y=r?s.y:e.y,o.z=n?s.z:e.z,o.applyMatrix4(t)}const r=this.satBounds,n=this.satAxes,o=i[0];for(let h=0;h<3;h++){const t=n[h],e=r[h],s=i[1<<h];t.subVectors(o,s),e.setFromPoints(t,i)}const a=this.alignedSatBounds;a[0].setFromPointsField(i,"x"),a[1].setFromPointsField(i,"y"),a[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},be.prototype.intersectsBox=function(){const t=new me;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,r=this.satBounds,n=this.satAxes,o=this.alignedSatBounds;if(t.min=s.x,t.max=i.x,o[0].isSeparated(t))return!1;if(t.min=s.y,t.max=i.y,o[1].isSeparated(t))return!1;if(t.min=s.z,t.max=i.z,o[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const s=n[a],i=r[a];if(t.setFromBox(s,e),i.isSeparated(t))return!1}return!0}}(),be.prototype.intersectsTriangle=function(){const t=new ge,e=new Array(3),s=new me,i=new me,r=new M;return function(n){this.needsUpdate&&this.update(),n.isExtendedTriangle?n.needsUpdate&&n.update():(t.copy(n),t.update(),n=t);const o=this.satBounds,a=this.satAxes;e[0]=n.a,e[1]=n.b,e[2]=n.c;for(let t=0;t<3;t++){const i=o[t],r=a[t];if(s.setFromPoints(r,e),i.isSeparated(s))return!1}const h=n.satBounds,c=n.satAxes,u=this.points;for(let t=0;t<3;t++){const e=h[t],i=c[t];if(s.setFromPoints(i,u),e.isSeparated(s))return!1}for(let t=0;t<3;t++){const n=a[t];for(let t=0;t<4;t++){const o=c[t];if(r.crossVectors(n,o),s.setFromPoints(r,e),i.setFromPoints(r,u),s.isSeparated(i))return!1}}return!0}}(),be.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},be.prototype.distanceToPoint=function(){const t=new M;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),be.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new Zt)),s=new Array(12).fill().map((()=>new Zt)),i=new M,r=new M;return function(n,o=0,a=null,h=null){if(this.needsUpdate&&this.update(),this.intersectsBox(n))return(a||h)&&(n.getCenter(r),this.closestPointToPoint(r,i),n.closestPointToPoint(i,r),a&&a.copy(i),h&&h.copy(r)),0;const c=o*o,u=n.min,l=n.max,d=this.points;let m=1/0;for(let t=0;t<8;t++){const e=d[t];r.copy(e).clamp(u,l);const s=e.distanceToSquared(r);if(s<m&&(m=s,a&&a.copy(e),h&&h.copy(r),s<c))return Math.sqrt(s)}let y=0;for(let i=0;i<3;i++)for(let r=0;r<=1;r++)for(let n=0;n<=1;n++){const o=(i+1)%3,a=(i+2)%3,h=1<<i|r<<o|n<<a,c=d[r<<o|n<<a],m=d[h];e[y].set(c,m);const p=t[i],x=t[o],f=t[a],g=s[y],b=g.start,w=g.end;b[p]=u[p],b[x]=r?u[x]:l[x],b[f]=n?u[f]:l[x],w[p]=l[p],w[x]=r?u[x]:l[x],w[f]=n?u[f]:l[x],y++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let s=0;s<=1;s++){r.x=t?l.x:u.x,r.y=e?l.y:u.y,r.z=s?l.z:u.z,this.closestPointToPoint(r,i);const n=r.distanceToSquared(i);if(n<m&&(m=n,a&&a.copy(i),h&&h.copy(r),n<c))return Math.sqrt(n)}for(let t=0;t<12;t++){const n=e[t];for(let t=0;t<12;t++){const e=s[t];pe(n,e,i,r);const o=i.distanceToSquared(r);if(o<m&&(m=o,a&&a.copy(i),h&&h.copy(r),o<c))return Math.sqrt(o)}}return Math.sqrt(m)}}();const we=new M,Me=new M,_e=new M,ze=new c,Ae=new c,Be=new c,Se=new M;function Te(s,i,r,n,o,a,h){we.fromBufferAttribute(i,n),Me.fromBufferAttribute(i,o),_e.fromBufferAttribute(i,a);const u=function(s,i,r,n,o,a){let h;return h=a===t?s.intersectTriangle(n,r,i,!0,o):s.intersectTriangle(i,r,n,a!==e,o),null===h?null:{distance:s.origin.distanceTo(o),point:o.clone()}}(s,we,Me,_e,Se,h);if(u){r&&(ze.fromBufferAttribute(r,n),Ae.fromBufferAttribute(r,o),Be.fromBufferAttribute(r,a),u.uv=Bt.getUV(Se,we,Me,_e,ze,Ae,Be,new c));const t={a:n,b:o,c:a,normal:new M,materialIndex:0};Bt.getNormal(we,Me,_e,t.normal),u.face=t,u.faceIndex=n}return u}function ve(t,e,s,i,r){const n=3*i,o=t.index.getX(n),a=t.index.getX(n+1),h=t.index.getX(n+2),c=Te(s,t.attributes.position,t.attributes.uv,o,a,h,e);return c?(c.faceIndex=i,r&&r.push(c),c):null}function Pe(t,e,s,i){const r=t.a,n=t.b,o=t.c;let a=e,h=e+1,c=e+2;s&&(a=s.getX(e),h=s.getX(e+1),c=s.getX(e+2)),r.x=i.getX(a),r.y=i.getY(a),r.z=i.getZ(a),n.x=i.getX(h),n.y=i.getY(h),n.z=i.getZ(h),o.x=i.getX(c),o.y=i.getY(c),o.z=i.getZ(c)}function Fe(t,e,s,i,r,n,o){const a=s.index,h=s.attributes.position;for(let c=t,u=e+t;c<u;c++)if(Pe(o,3*c,a,h),o.needsUpdate=!0,i(o,c,r,n))return!0;return!1}class Ee{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function Ce(t,e){return 65535===e[t+15]}function ke(t,e){return e[t+6]}function Ue(t,e){return e[t+14]}function Ve(t){return t+8}function Re(t,e){return e[t+6]}const Oe=new A,qe=new M,Ie=["x","y","z"];function Ne(t,e,s,i,r){let n=2*t,o=je,a=He,h=Ge;if(Ce(n,a)){!function(t,e,s,i,r,n){for(let o=i,a=i+r;o<a;o++)ve(t,e,s,o,n)}(e,s,i,ke(t,h),Ue(n,a),r)}else{const n=Ve(t);We(n,o,i,qe)&&Ne(n,e,s,i,r);const a=Re(t,h);We(a,o,i,qe)&&Ne(a,e,s,i,r)}}function De(t,e,s,i){let r=2*t,n=je,o=He,a=Ge;if(Ce(r,o)){return function(t,e,s,i,r){let n=1/0,o=null;for(let a=i,h=i+r;a<h;a++){const i=ve(t,e,s,a);i&&i.distance<n&&(o=i,n=i.distance)}return o}(e,s,i,ke(t,a),Ue(r,o))}{const r=function(t,e){return e[t+7]}(t,a),o=Ie[r],h=i.direction[o]>=0;let c,u;h?(c=Ve(t),u=Re(t,a)):(c=Re(t,a),u=Ve(t));const l=We(c,n,i,qe)?De(c,e,s,i):null;if(l){const t=l.point[o];if(h?t<=n[u+r]:t>=n[u+r+3])return l}const d=We(u,n,i,qe)?De(u,e,s,i):null;return l&&d?l.distance<=d.distance?l:d:l||d||null}}const Xe=function(){let t,e;const s=[],i=new Ee((()=>new A));return function(...n){t=i.getPrimitive(),e=i.getPrimitive(),s.push(t,e);const o=r(...n);i.releasePrimitive(t),i.releasePrimitive(e),s.pop(),s.pop();const a=s.length;return a>0&&(e=s[a-1],t=s[a-2]),o};function r(s,i,n,o,a=null,h=0,c=0){function u(t){let e=2*t,s=He,i=Ge;for(;!Ce(e,s);)e=2*(t=Ve(t));return ke(t,i)}function l(t){let e=2*t,s=He,i=Ge;for(;!Ce(e,s);)e=2*(t=Re(t,i));return ke(t,i)+Ue(e,s)}let d=2*s,m=je,y=He,p=Ge;if(Ce(d,y)){const e=ke(s,p),i=Ue(d,y);return ee(s,m,t),o(e,i,!1,c,h+s,t)}{const d=Ve(s),x=Re(s,p);let f,g,b,w,M=d,_=x;if(a&&(b=t,w=e,ee(M,m,b),ee(_,m,w),f=a(b),g=a(w),g<f)){M=x,_=d;const t=f;f=g,g=t,b=w}b||(b=t,ee(M,m,b));const z=n(b,Ce(2*M,y),f,c+1,h+M);let A;if(2===z){const t=u(M);A=o(t,l(M)-t,!0,c+1,h+M,b)}else A=z&&r(M,i,n,o,a,h,c+1);if(A)return!0;w=e,ee(_,m,w);const B=n(w,Ce(2*_,y),g,c+1,h+_);let S;if(2===B){const t=u(_);S=o(t,l(_)-t,!0,c+1,h+_,w)}else S=B&&r(_,i,n,o,a,h,c+1);return!!S}}}(),Le=function(){const t=new ge,e=new ge,s=new L,i=new be,r=new be;return function n(o,a,h,c,u=null){let l=2*o,d=je,m=He,y=Ge;null===u&&(h.boundingBox||h.computeBoundingBox(),i.set(h.boundingBox.min,h.boundingBox.max,c),u=i);if(!Ce(l,m)){const t=o+8,e=y[o+6];ee(t,d,Oe);if(u.intersectsBox(Oe)&&n(t,a,h,c,u))return!0;ee(e,d,Oe);return!!(u.intersectsBox(Oe)&&n(e,a,h,c,u))}{const i=a,n=i.index,u=i.attributes.position,p=h.index,x=h.attributes.position,f=ke(o,y),g=Ue(l,m);if(s.copy(c).invert(),h.boundsTree){ee(o,d,r),r.matrix.copy(s),r.needsUpdate=!0;return h.boundsTree.shapecast({intersectsBounds:t=>r.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(c),t.b.applyMatrix4(c),t.c.applyMatrix4(c),t.needsUpdate=!0;for(let s=3*f,i=3*(g+f);s<i;s+=3)if(Pe(e,s,n,u),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}})}for(let r=3*f,o=g+3*f;r<o;r+=3){Pe(t,r,n,u),t.a.applyMatrix4(s),t.b.applyMatrix4(s),t.c.applyMatrix4(s),t.needsUpdate=!0;for(let s=0,i=p.count;s<i;s+=3)if(Pe(e,s,p,x),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function We(t,e,s,i){return ee(t,e,Oe),s.intersectBox(Oe,i)}const Ye=[];let Ze,je,He,Ge;function Je(t){Ze&&Ye.push(Ze),Ze=t,je=new Float32Array(t),He=new Uint16Array(t),Ge=new Uint32Array(t)}function Qe(){Ze=null,je=null,He=null,Ge=null,Ye.length&&Je(Ye.pop())}const $e=Symbol("skip tree generation"),Ke=new A,ts=new A,es=new L,ss=new be,is=new be,rs=new M,ns=new M,os=new M,as=new M,hs=new M,cs=new A,us=new Ee((()=>new ge));class ls{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),ls.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,r=s.getIndex();let n;return n=e.cloneBuffers?{roots:i.map((t=>t.slice())),index:r.array.slice()}:{roots:i,index:r.array},n}static deserialize(t,e,s={}){if("boolean"==typeof s)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),ls.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});s={setIndex:!0,...s};const{index:i,roots:r}=t,n=new ls(e,{...s,[$e]:!0});if(n._roots=r,s.setIndex){const s=e.getIndex();if(null===s){const s=new vt(t.index,1,!1);e.setIndex(s)}else s.array!==i&&(s.array.set(i),s.needsUpdate=!0)}return n}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:jt,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[$e]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[$e]||(this._roots=function(t,e){const s=de(t,e);let i,r,n;const o=[],a=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<s.length;u++){const t=s[u],e=new a(32*h(t));i=new Float32Array(e),r=new Uint32Array(e),n=new Uint16Array(e),c(0,t),o.push(e)}return o;function h(t){return t.count?1:1+h(t.left)+h(t.right)}function c(t,e){const s=t/4,o=t/2,a=!!e.count,h=e.boundingData;for(let r=0;r<6;r++)i[s+r]=h[r];if(a){const i=e.offset,a=e.count;return r[s+6]=i,n[o+14]=a,n[o+15]=$t,t+32}{const i=e.left,n=e.right,o=e.splitAxis;let a;if(a=c(t+32,i),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return r[s+6]=a/4,a=c(a,n),r[s+7]=o,a}}}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new A))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,s=e.index.array,i=e.attributes.position;let r,n,o,a,h=0;const c=this._roots;for(let l=0,d=c.length;l<d;l++)r=c[l],n=new Uint32Array(r),o=new Uint16Array(r),a=new Float32Array(r),u(0,h),h+=r.byteLength;function u(e,r,h=!1){const c=2*e;if(o[c+15]===$t){const t=n[e+6];let r=1/0,h=1/0,u=1/0,l=-1/0,d=-1/0,m=-1/0;for(let e=3*t,n=3*(t+o[c+14]);e<n;e++){const t=s[e],n=i.getX(t),o=i.getY(t),a=i.getZ(t);n<r&&(r=n),n>l&&(l=n),o<h&&(h=o),o>d&&(d=o),a<u&&(u=a),a>m&&(m=a)}return(a[e+0]!==r||a[e+1]!==h||a[e+2]!==u||a[e+3]!==l||a[e+4]!==d||a[e+5]!==m)&&(a[e+0]=r,a[e+1]=h,a[e+2]=u,a[e+3]=l,a[e+4]=d,a[e+5]=m,!0)}{const s=e+8,i=n[e+6],o=s+r,c=i+r;let l=h,d=!1,m=!1;t?l||(d=t.has(o),m=t.has(c),l=!d&&!m):(d=!0,m=!0);const y=l||m;let p=!1;(l||d)&&(p=u(s,r,l));let x=!1;y&&(x=u(i,r,l));const f=p||x;if(f)for(let t=0;t<3;t++){const r=s+t,n=i+t,o=a[r],h=a[r+3],c=a[n],u=a[n+3];a[e+t]=o<c?o:c,a[e+t+3]=h>u?h:u}return f}}}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),r=new Uint16Array(s);!function e(n,o=0){const a=2*n,h=r[a+15]===$t;if(h){const e=i[n+6],c=r[a+14];t(o,h,new Float32Array(s,4*n,6),e,c)}else{const r=n+8,a=i[n+6],c=i[n+7];t(o,h,new Float32Array(s,4*n,6),c)||(e(r,o+1),e(a,o+1))}}(0)}raycast(t,e=0){const s=this._roots,i=this.geometry,r=[],n=e.isMaterial,o=Array.isArray(e),a=i.groups,h=n?e.side:e;for(let c=0,u=s.length;c<u;c++){const n=o?e[a[c].materialIndex].side:h,u=r.length;if(Je(s[c]),Ne(0,i,n,t,r),Qe(),o){const t=a[c].materialIndex;for(let e=u,s=r.length;e<s;e++)r[e].face.materialIndex=t}}return r}raycastFirst(t,e=0){const s=this._roots,i=this.geometry,r=e.isMaterial,n=Array.isArray(e);let o=null;const a=i.groups,h=r?e.side:e;for(let c=0,u=s.length;c<u;c++){const r=n?e[a[c].materialIndex].side:h;Je(s[c]);const u=De(0,i,r,t);Qe(),null!=u&&(null==o||u.distance<o.distance)&&(o=u,n&&(u.face.materialIndex=a[c].materialIndex))}return o}intersectsGeometry(t,e){const s=this.geometry;let i=!1;for(const r of this._roots)if(Je(r),i=Le(0,s,t,e),Qe(),i)break;return i}shapecast(t,e,s){const i=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,s,i,r)=>{const n=3*s;return t(e,n,n+1,n+2,i,r)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=us.getPrimitive();let{boundsTraverseOrder:n,intersectsBounds:o,intersectsRange:a,intersectsTriangle:h}=t;if(a&&h){const t=a;a=(e,s,n,o,a)=>!!t(e,s,n,o,a)||Fe(e,s,i,h,n,o,r)}else a||(a=h?(t,e,s,n)=>Fe(t,e,i,h,s,n,r):(t,e,s)=>s);let c=!1,u=0;for(const l of this._roots){if(Je(l),c=Xe(0,i,o,a,n,u),Qe(),c)break;u+=l.byteLength}return us.releasePrimitive(r),c}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const n=this.geometry.index,o=this.geometry.attributes.position,a=t.geometry.index,h=t.geometry.attributes.position;es.copy(e).invert();const c=us.getPrimitive(),u=us.getPrimitive();if(r){let t=function(t,s,i,l,d,m,y,p){for(let x=i,f=i+l;x<f;x++){Pe(u,3*x,a,h),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,i=t+s;e<i;e++)if(Pe(c,3*e,n,o),c.needsUpdate=!0,r(c,u,e,x,d,m,y,p))return!0}return!1};if(i){const e=i;i=function(s,i,r,n,o,a,h,c){return!!e(s,i,r,n,o,a,h,c)||t(s,i,r,n,o,a,h,c)}}else i=t}t.getBoundingBox(ts),ts.applyMatrix4(e);const l=this.shapecast({intersectsBounds:t=>ts.intersectsBox(t),intersectsRange:(e,s,r,n,o,a)=>(Ke.copy(a),Ke.applyMatrix4(es),t.shapecast({intersectsBounds:t=>Ke.intersectsBox(t),intersectsRange:(t,r,a,h,c)=>i(e,s,t,r,n,o,h,c)}))});return us.releasePrimitive(c),us.releasePrimitive(u),l}intersectsBox(t,e){return ss.set(t.min,t.max,e),ss.needsUpdate=!0,this.shapecast({intersectsBounds:t=>ss.intersectsBox(t),intersectsTriangle:t=>ss.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},r=0,n=1/0){t.boundingBox||t.computeBoundingBox(),ss.set(t.boundingBox.min,t.boundingBox.max,e),ss.needsUpdate=!0;const o=this.geometry,a=o.attributes.position,h=o.index,c=t.attributes.position,u=t.index,l=us.getPrimitive(),d=us.getPrimitive();let m=ns,y=os,p=null,x=null;i&&(p=as,x=hs);let f=1/0,g=null,b=null;return es.copy(e).invert(),is.matrix.copy(es),this.shapecast({boundsTraverseOrder:t=>ss.distanceToBox(t),intersectsBounds:(t,e,s)=>s<f&&s<n&&(e&&(is.min.copy(t.min),is.max.copy(t.max),is.needsUpdate=!0),!0),intersectsRange:(s,i)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>is.distanceToBox(t),intersectsBounds:(t,e,s)=>s<f&&s<n,intersectsRange:(t,n)=>{for(let o=3*t,w=3*(t+n);o<w;o+=3){Pe(d,o,u,c),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let t=3*s,e=3*(s+i);t<e;t+=3){Pe(l,t,h,a),l.needsUpdate=!0;const e=l.distanceToTriangle(d,m,p);if(e<f&&(y.copy(m),x&&x.copy(p),f=e,g=t/3,b=o/3),e<r)return!0}}}});for(let t=0,n=u?u.count:c.count;t<n;t+=3){Pe(d,t,u,c),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let e=3*s,n=3*(s+i);e<n;e+=3){Pe(l,e,h,a),l.needsUpdate=!0;const s=l.distanceToTriangle(d,m,p);if(s<f&&(y.copy(m),x&&x.copy(p),f=s,g=e/3,b=t/3),s<r)return!0}}}}),us.releasePrimitive(l),us.releasePrimitive(d),f===1/0?null:(s.point?s.point.copy(y):s.point=y.clone(),s.distance=f,s.faceIndex=g,i&&(i.point?i.point.copy(x):i.point=x.clone(),i.point.applyMatrix4(es),y.applyMatrix4(es),i.distance=y.sub(i.point).length(),i.faceIndex=b),s)}closestPointToPoint(t,e={},s=0,i=1/0){const r=s*s,n=i*i;let o=1/0,a=null;if(this.shapecast({boundsTraverseOrder:e=>(rs.copy(t).clamp(e.min,e.max),rs.distanceToSquared(t)),intersectsBounds:(t,e,s)=>s<o&&s<n,intersectsTriangle:(e,s)=>{e.closestPointToPoint(t,rs);const i=t.distanceToSquared(rs);return i<o&&(ns.copy(rs),o=i,a=s),i<r}}),o===1/0)return null;const h=Math.sqrt(o);return e.point?e.point.copy(ns):e.point=ns.clone(),e.distance=h,e.faceIndex=a,e}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{ee(0,new Float32Array(e),cs),t.union(cs)})),t}}onmessage=function({data:t}){let e=performance.now();const{index:s,position:i,options:r}=t;try{const t=new It;if(t.setAttribute("position",new vt(i,3,!1)),s&&t.setIndex(new vt(s,1,!1)),r.includedProgressCallback&&(r.onProgress=function(t){const s=performance.now();(s-e>=10||1===t)&&(postMessage({error:null,serialized:null,position:null,progress:t}),e=s)}),r.groups){const e=r.groups;for(const s in e){const i=e[s];t.addGroup(i.start,i.count,i.materialIndex)}}const n=new ls(t,r),o=ls.serialize(n,{copyIndexBuffer:!1});postMessage({error:null,serialized:o,position:i,progress:1},[o.index.buffer,i.buffer,...o.roots].filter((t=>"undefined"==typeof SharedArrayBuffer||!(t instanceof SharedArrayBuffer))))}catch(n){postMessage({error:n,serialized:null,position:null,progress:1})}}}();
