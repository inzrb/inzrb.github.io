import{j as e,u as n}from"./r3-other-vendor-2c8fc3cb.js";import{J as o,p as r,e as t,d as s,C as i,O as a,b as l}from"./r3-extend-vendor-ed1023dc.js";import{a as u}from"./react-vendor-670efa73.js";/* empty css                    */import{aU as c,V as h,b as d,C as m,bN as g}from"./three-vendor-6d04682c.js";function f(n){const{nodes:r,materials:t}=o("/models/spaceship.glb"),s=u.useRef(),i=u.useRef();return e.jsx("group",{ref:s,...n,dispose:null,children:e.jsxs("group",{position:[10,10,-80],rotation:[.1*Math.PI,0*Math.PI,.03*Math.PI],scale:4e-4,children:[e.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:r.mesh_0.geometry,material:t.ferrari}),e.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:r.mesh_0_1.geometry,material:t.raggi}),e.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:r.mesh_0_2.geometry,material:t.ammenita}),e.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:r.mesh_0_3.geometry,material:t.motore}),e.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:r.mesh_0_4.geometry,material:t.glow_motore}),e.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:r.mesh_0_5.geometry,material:t["BURCIA GLOW_int"]}),e.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:r.mesh_0_6.geometry,material:t["BURCIA GLOW est"]}),e.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:r.mesh_0_7.geometry,material:t["luce post"]}),e.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:r.mesh_0_8.geometry,material:t.fire,ref:i})]})})}o.preload("/models/spaceship.glb");const v={uFreq:new c(new h(2,3)),uAmp:new c(new h(35,10))},p=(e,n)=>{let o=.0125,r=v.uFreq.value,t=v.uAmp.value,s=new d(Math.sin(e*Math.PI*r.x+n)*t.x-Math.sin(o*Math.PI*r.x+n)*t.x,Math.sin(e*Math.PI*r.y+n)*t.y-Math.sin(o*Math.PI*r.y+n)*t.y,0),i=new d(1,1,0),a=new d(0,0,-5);return s.multiply(i).add(a)},L={length:400,roadWidth:10,islandWidth:5,lanesPerRoad:2,fov:90,fovSpeedUp:150,speedUp:2,carLightsFade:.4,totalSideLightSticks:50,lightPairsPerRoadWay:70,shoulderLinesWidthPercentage:.05,brokenLinesWidthPercentage:.1,brokenLinesLengthPercentage:.5,lightStickWidth:[.12,.5],lightStickHeight:[1.3,1.7],movingAwaySpeed:[60,80],movingCloserSpeed:[-120,-160],carLightsLength:[20,60],carLightsRadius:[.05,.14],carWidthPercentage:[.3,.5],carShiftX:[-.2,.2],carFloorSeparation:[.05,1],colors:{roadColor:526344,islandColor:657930,background:0,shoulderLines:1250072,brokenLines:1250072,leftCars:[16736115,15158624,16715818],rightCars:[10806246,8442324,5489350],sticks:10806246}};t({RoadWayMaterial:r({uColor:new m(L.colors.roadColor),uTime:0,uTravelLength:L.length,uFreq:new h(4,8),uAmp:new h(10,20),uPowY:new h(20,2),uLanes:L.lanesPerRoad,uBrokenLinesColor:new m(L.colors.brokenLines),uShoulderLinesColor:new m(L.colors.shoulderLines),uShoulderLinesWidthPercentage:L.shoulderLinesWidthPercentage,uBrokenLinesLengthPercentage:L.brokenLinesLengthPercentage,uBrokenLinesWidthPercentage:L.brokenLinesWidthPercentage},"\nuniform float uTime;\nuniform float uTravelLength;\n\nvarying vec2 vUv; \n\n//   #include <getDistortion_vertex>\nuniform vec4 uFreq;\nuniform vec4 uAmp;\nuniform vec2 uPowY;\nfloat nsin(float val){\n    return sin(val) * 0.5+0.5;\n}\n\n#define PI 3.14159265358979\nfloat getDistortionX(float progress){\n    return \n            (\n                sin(progress * PI * uFreq.x + uTime) * uAmp.x\n            \n            );\n}\nfloat getDistortionY(float progress){\n    return \n            (\n                pow(abs(progress * uPowY.x),uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n            );\n}\nvec3 getDistortion(float progress){\n    return vec3(\n        getDistortionX(progress)-getDistortionX(0.02) ,\n        getDistortionY(progress)- getDistortionY(0.02),\n        0.\n    );\n}\n\nvoid main() {\n    vec3 transformed = position.xyz;\n\n    vec3 distortion  = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n    transformed.x += distortion.x;\n    transformed.z += distortion.y;\n    transformed.y += -1.*distortion.z;  \n    \n    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}\n","\nvarying vec2 vUv; \nuniform vec3 uColor;\nuniform float uTime;\n\n// start #include <roadMarkings_vars>\nuniform float uLanes;\nuniform vec3 uBrokenLinesColor;\nuniform vec3 uShoulderLinesColor;\nuniform float uShoulderLinesWidthPercentage;\nuniform float uBrokenLinesWidthPercentage;\nuniform float uBrokenLinesLengthPercentage;\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n// end #include <roadMarkings_vars>\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 color = vec3(uColor);\n    \n    // #include <roadMarkings_fragment>\n\n    uv.y = mod(uv.y + uTime * 0.1,1.);\n    float brokenLineWidth = 1. / uLanes * uBrokenLinesWidthPercentage;\n    // How much % of the lane's space is empty\n    float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n    // Horizontal * vertical offset\n    float brokenLines = step(1.-brokenLineWidth * uLanes,fract(uv.x * uLanes)) * step(laneEmptySpace, fract(uv.y * 100.)) ;\n    // Remove right-hand lines on the right-most lane\n    brokenLines *= step(uv.x * uLanes,uLanes-1.);\n    color = mix(color, uBrokenLinesColor, brokenLines);\n\n\n    float shoulderLinesWidth = 1. / uLanes * uShoulderLinesWidthPercentage;\n    float shoulderLines = step(1.-shoulderLinesWidth, uv.x) + step(uv.x, shoulderLinesWidth);\n    color = mix(color, uBrokenLinesColor, shoulderLines);\n\n    vec2 noiseFreq = vec2(4., 7000.);\n    float roadNoise = random( floor(uv * noiseFreq)/noiseFreq ) * 0.02 - 0.01; \n    color += roadNoise;\n\n    gl_FragColor = vec4(color,1.);\n}\n")});t({IslandMaterial:r({uColor:new m(L.colors.islandColor),uTime:0,uTravelLength:L.length,uFreq:new h(4,8),uAmp:new h(10,20),uPowY:new h(20,2)},"\nuniform float uTime;\nuniform float uTravelLength;\n\nvarying vec2 vUv; \n\n//   #include <getDistortion_vertex>\nuniform vec4 uFreq;\nuniform vec4 uAmp;\nuniform vec2 uPowY;\nfloat nsin(float val){\n    return sin(val) * 0.5+0.5;\n}\n\n#define PI 3.14159265358979\nfloat getDistortionX(float progress){\n    return \n            (\n                sin(progress * PI * uFreq.x + uTime) * uAmp.x\n            \n            );\n}\nfloat getDistortionY(float progress){\n    return \n            (\n                pow(abs(progress * uPowY.x),uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n            );\n}\nvec3 getDistortion(float progress){\n    return vec3(\n        getDistortionX(progress)-getDistortionX(0.02) ,\n        getDistortionY(progress)- getDistortionY(0.02),\n        0.\n    );\n}\n\nvoid main() {\n    vec3 transformed = position.xyz;\n\n    vec3 distortion  = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n    transformed.x += distortion.x;\n    transformed.z += distortion.y;\n    transformed.y += -1.*distortion.z;  \n    \n    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}\n","\nvarying vec2 vUv; \nuniform vec3 uColor;\nuniform float uTime;\n\n// start #include <roadMarkings_vars>\nuniform float uLanes;\nuniform vec3 uBrokenLinesColor;\nuniform vec3 uShoulderLinesColor;\nuniform float uShoulderLinesWidthPercentage;\nuniform float uBrokenLinesWidthPercentage;\nuniform float uBrokenLinesLengthPercentage;\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n// end #include <roadMarkings_vars>\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 color = vec3(uColor);\n    \n    // #include <roadMarkings_fragment>\n\n    uv.y = mod(uv.y + uTime * 0.1,1.);\n    float brokenLineWidth = 1. / uLanes * uBrokenLinesWidthPercentage;\n    // How much % of the lane's space is empty\n    float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n    // Horizontal * vertical offset\n    float brokenLines = step(1.-brokenLineWidth * uLanes,fract(uv.x * uLanes)) * step(laneEmptySpace, fract(uv.y * 100.)) ;\n    // Remove right-hand lines on the right-most lane\n    brokenLines *= step(uv.x * uLanes,uLanes-1.);\n    color = mix(color, uBrokenLinesColor, brokenLines);\n\n\n    float shoulderLinesWidth = 1. / uLanes * uShoulderLinesWidthPercentage;\n    float shoulderLines = step(1.-shoulderLinesWidth, uv.x) + step(uv.x, shoulderLinesWidth);\n    color = mix(color, uBrokenLinesColor, shoulderLines);\n\n    vec2 noiseFreq = vec2(4., 7000.);\n    float roadNoise = random( floor(uv * noiseFreq)/noiseFreq ) * 0.02 - 0.01; \n    color += roadNoise;\n\n    gl_FragColor = vec4(color,1.);\n}\n")});const y=e=>Array.isArray(e)?Math.random()*(e[1]-e[0])+e[0]:Math.random()*e,x=e=>Array.isArray(e)?e[Math.floor(Math.random()*e.length)]:e,P=(e,n,o=.1,r=.001)=>{let t=(n-e)*o;return Math.abs(t)<r&&(t=n-e),t};function w(n){const{options:o,pColor:r,pSpeed:t,isLeftSide:i}=n,a=u.useRef();let l=r;console.log(o,r,t,i),s(((e,n)=>{const o=e.clock.getElapsedTime();a.current.uTime=o}));let c=new g(new d(0,0,0),new d(0,0,-1)),h=o.roadWidth/o.lanesPerRoad,f=[],v=[],p=[];l=Array.isArray(l)?l.map((e=>new m(e))):new m(l);for(let e=0;e<o.lightPairsPerRoadWay;e++){let n=y(o.carLightsRadius),r=y(o.carLightsLength),s=y(t),i=e%3*h-o.roadWidth/2+h/2,a=y(o.carWidthPercentage)*h;i+=y(o.carShiftX)*h;let u=y(o.carFloorSeparation)+1.3*n,c=-y(o.length);f.push(i-a/2),f.push(u),f.push(c),f.push(i+a/2),f.push(u),f.push(c),v.push(n),v.push(r),v.push(s),v.push(n),v.push(r),v.push(s);let d=x(l);p.push(d.r),p.push(d.g),p.push(d.b),p.push(d.r),p.push(d.g),p.push(d.b)}const L=new Float32Array(f),P=new Float32Array(v),w=new Float32Array(p),S=u.useRef(),k=i?-o.roadWidth/2-o.islandWidth/2:o.roadWidth/2+o.islandWidth/2;return u.useEffect((()=>{console.log(S.current),console.log(a.current)}),[]),e.jsx("group",{ref:S,rotation:[0,0,0],position:[k,0,0],children:e.jsxs("instancedMesh",{args:[null,null,2*o.lightPairsPerRoadWay],children:[e.jsxs("tubeGeometry",{args:[c,40,1,8,!1],children:[e.jsx("instancedBufferAttribute",{attach:"attributes-aOffset",args:[L,3]}),e.jsx("instancedBufferAttribute",{attach:"attributes-aMetrics",args:[P,3]}),e.jsx("instancedBufferAttribute",{attach:"attributes-aColor",args:[w,3]})]}),e.jsx("flyLineMaterial",{ref:a})]})})}function S(){return e.jsx("section",{className:"lab_show",children:e.jsxs(i,{shadows:!0,dpr:[1,1.5],camera:{position:[0,8,-5],fov:45,near:.1,far:1e4},children:[e.jsx("color",{attach:"background",args:["#000"]}),e.jsx(k,{}),e.jsx(b,{}),e.jsx(f,{}),e.jsx(w,{color:"#f00",pSpeed:L.movingCloserSpeed,options:L,pColor:L.colors.leftCars,isLeftSide:!0}),e.jsx(w,{color:"#00f",pSpeed:L.movingCloserSpeed,options:L,pColor:L.colors.rightCars,isLeftSide:!1}),e.jsx(a,{})]})})}function k(){return e.jsxs(e.Fragment,{children:[e.jsx("color",{attach:"background",args:["#15151a"]}),e.jsx("ambientLight",{intensity:.7}),e.jsx("directionalLight",{intensity:.5,position:[-5,5,5],castShadow:!0,"shadow-mapSize":1024}),e.jsx("pointLight",{intensity:1,position:[-.15,1,0]}),e.jsx("pointLight",{intensity:1,position:[2,1,0]})]})}function b({children:o}){const{gl:r,camera:t}=l(),i=u.useRef();let a=0,c=0;const h=L.fov;console.log(r,t);const{x:d,y:m,z:g}=n({x:{value:0,min:-100,max:10,step:.01},y:{value:5,min:-10,max:100,step:.01},z:{value:10,min:-100,max:100,step:.01}});return s(((e,n)=>{let o=Math.exp(60*Math.log2(.9)*n),r=P(t.fov,h,o);a+=P(a,0,o,1e-5),c+=a*n;let s=e.clock.getElapsedTime()+c;0!==r&&(t.fov+=r*n*6),t.position.x=d,t.position.y=m,t.position.z=g,p(.025,s)})),e.jsx("group",{ref:i,children:o})}t({FlyLineMaterial:r({uTime:0,uTravelLength:L.length,uFade:new h(0,1-L.carLightsFade),uFreq:new h(2,3),uAmp:new h(35,10)},"\nattribute vec3 aOffset;\nattribute vec3 aMetrics;\nattribute vec3 aColor;\n\n\n\nuniform float uTravelLength;\nuniform float uTime;\nuniform float uSpeed;\n\nvarying vec2 vUv; \nvarying vec3 vColor; \n\n\nuniform vec2 uFreq;\nuniform vec2 uAmp;\n#define PI 3.14159265358979\n\nvec3 getDistortion(float progress){\n\n        float camProgress = 0.0125;\n        return vec3( \n            sin(progress * PI * uFreq.x +uTime) * uAmp.x - sin(camProgress * PI * uFreq.x+uTime ) * uAmp.x,\n            sin(progress * PI * uFreq.y +uTime) * uAmp.y - sin(camProgress * PI * uFreq.y+uTime ) * uAmp.y,\n            0.\n        );\n    }\n\nvoid main() {\n    vec3 transformed = position.xyz;\n    float radius = aMetrics.r;\n    float myLength = aMetrics.g;\n    float speed = aMetrics.b;\n\n    transformed.xy *= radius ;\n    transformed.z *= myLength;\n  \n    // Add my length to make sure it loops after the lights hits the end\n    transformed.z += myLength-mod( uTime *speed + aOffset.z, uTravelLength);\n    transformed.xy += aOffset.xy;\n\n\n    float progress = abs(transformed.z / uTravelLength);\n    transformed.xyz += getDistortion(progress);\n\n    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n    vColor = aColor;\n}\n","\nvarying vec3 vColor;\nvarying vec2 vUv; \nuniform vec2 uFade;\nvoid main() {\n    vec3 color = vec3(vColor);\n    float fadeStart = 0.4;\n    float maxFade = 0.;\n    float alpha = 1.;\n\n    alpha = smoothstep(uFade.x, uFade.y, vUv.x);\n    gl_FragColor = vec4(color,alpha);\n    if (gl_FragColor.a < 0.0001) discard;\n}\n")});export{S as default};
